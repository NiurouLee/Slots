// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: spinx_extra_info.proto
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.ilruntime.Protobuf;
using pbc = global::Google.ilruntime.Protobuf.Collections;
using scg = global::System.Collections.Generic;
namespace DragonU3DSDK.Network.API.ILProtocol {

  #region Enums
  public enum WarriorKingActionType {
    /// <summary>
    /// 未知类型
    /// </summary>
    Unknown = 0,
    /// <summary>
    /// 免费游戏进入时的选择
    /// </summary>
    FreeGameEnterChoose = 1,
    /// <summary>
    /// 免费游戏中选择武士
    /// </summary>
    FreeGameWarriorChoose = 2,
    /// <summary>
    /// bonus game中的选择
    /// </summary>
    BonusGameChoose = 3,
    /// <summary>
    /// 升级选择
    /// </summary>
    LevelUpChoose = 4,
  }

  /// <summary>
  /// 阵营枚举
  /// </summary>
  public enum ZeusVsHadesCampType {
    CampZeus = 0,
    CampHades = 1,
  }

  /// <summary>
  /// 免费游戏类型
  /// </summary>
  public enum MasterOfWealthFreeGameType {
    UnknownType = 0,
    Fu = 1,
    Lu = 2,
    Shou = 3,
    Xi = 4,
  }

  #endregion

  #region Messages
  /// <summary>
  ///================= 1001: GoldOfJackpot ====================================
  /// </summary>
  public sealed class GoldOfJackpotGameResultExtraInfo : pb::IMessage {
    private static readonly pb::MessageParser<GoldOfJackpotGameResultExtraInfo> _parser = new pb::MessageParser<GoldOfJackpotGameResultExtraInfo>(() => new GoldOfJackpotGameResultExtraInfo());
    public static pb::MessageParser<GoldOfJackpotGameResultExtraInfo> Parser { get { return _parser; } }

    private static readonly pb::FieldCodec<string> _repeated_miniGameReelsSequences_codec
        = pb::FieldCodec.ForString(10);
    private readonly pbc::RepeatedField<string> miniGameReelsSequences_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// 未玩miniGame卷轴id
    /// </summary>
    public pbc::RepeatedField<string> MiniGameReelsSequences {
      get { return miniGameReelsSequences_; }
    }

    private static readonly pb::FieldCodec<string> _repeated_miniGameReelsSequencesUsed_codec
        = pb::FieldCodec.ForString(18);
    private readonly pbc::RepeatedField<string> miniGameReelsSequencesUsed_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// 已玩miniGame卷轴id
    /// </summary>
    public pbc::RepeatedField<string> MiniGameReelsSequencesUsed {
      get { return miniGameReelsSequencesUsed_; }
    }

    private ulong miniGameTotalWin_;
    /// <summary>
    /// mini游戏总赢钱
    /// </summary>
    public ulong MiniGameTotalWin {
      get { return miniGameTotalWin_; }
      set {
        miniGameTotalWin_ = value;
      }
    }

    private bool isOver_;
    /// <summary>
    /// miniGame是否结束
    /// </summary>
    public bool IsOver {
      get { return isOver_; }
      set {
        isOver_ = value;
      }
    }

    private ulong miniGameBet_;
    /// <summary>
    /// 中mini game时的bet
    /// </summary>
    public ulong MiniGameBet {
      get { return miniGameBet_; }
      set {
        miniGameBet_ = value;
      }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      miniGameReelsSequences_.WriteTo(output, _repeated_miniGameReelsSequences_codec);
      miniGameReelsSequencesUsed_.WriteTo(output, _repeated_miniGameReelsSequencesUsed_codec);
      if (MiniGameTotalWin != 0UL) {
        output.WriteRawTag(24);
        output.WriteUInt64(MiniGameTotalWin);
      }
      if (IsOver != false) {
        output.WriteRawTag(32);
        output.WriteBool(IsOver);
      }
      if (MiniGameBet != 0UL) {
        output.WriteRawTag(40);
        output.WriteUInt64(MiniGameBet);
      }
    }

    public int CalculateSize() {
      int size = 0;
      size += miniGameReelsSequences_.CalculateSize(_repeated_miniGameReelsSequences_codec);
      size += miniGameReelsSequencesUsed_.CalculateSize(_repeated_miniGameReelsSequencesUsed_codec);
      if (MiniGameTotalWin != 0UL) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(MiniGameTotalWin);
      }
      if (IsOver != false) {
        size += 1 + 1;
      }
      if (MiniGameBet != 0UL) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(MiniGameBet);
      }
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            miniGameReelsSequences_.AddEntriesFrom(input, _repeated_miniGameReelsSequences_codec);
            break;
          }
          case 18: {
            miniGameReelsSequencesUsed_.AddEntriesFrom(input, _repeated_miniGameReelsSequencesUsed_codec);
            break;
          }
          case 24: {
            MiniGameTotalWin = input.ReadUInt64();
            break;
          }
          case 32: {
            IsOver = input.ReadBool();
            break;
          }
          case 40: {
            MiniGameBet = input.ReadUInt64();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///================= 1002: UncleSam ====================================
  /// </summary>
  public sealed class UncleSamGameResultExtraInfo : pb::IMessage {
    private static readonly pb::MessageParser<UncleSamGameResultExtraInfo> _parser = new pb::MessageParser<UncleSamGameResultExtraInfo>(() => new UncleSamGameResultExtraInfo());
    public static pb::MessageParser<UncleSamGameResultExtraInfo> Parser { get { return _parser; } }

    private global::DragonU3DSDK.Network.API.ILProtocol.Panel lockedPanel_;
    /// <summary>
    /// 锁定的Panel
    /// </summary>
    public global::DragonU3DSDK.Network.API.ILProtocol.Panel LockedPanel {
      get { return lockedPanel_; }
      set {
        lockedPanel_ = value;
      }
    }

    private uint collectedBonusSymbolCount_;
    /// <summary>
    /// 收集的Bonus图标个数
    /// </summary>
    public uint CollectedBonusSymbolCount {
      get { return collectedBonusSymbolCount_; }
      set {
        collectedBonusSymbolCount_ = value;
      }
    }

    private static readonly pb::FieldCodec<uint> _repeated_miniGameSequences_codec
        = pb::FieldCodec.ForUInt32(26);
    private readonly pbc::RepeatedField<uint> miniGameSequences_ = new pbc::RepeatedField<uint>();
    /// <summary>
    /// 未玩miniGame序列
    /// </summary>
    public pbc::RepeatedField<uint> MiniGameSequences {
      get { return miniGameSequences_; }
    }

    private static readonly pb::FieldCodec<uint> _repeated_miniGameSequencesUsed_codec
        = pb::FieldCodec.ForUInt32(34);
    private readonly pbc::RepeatedField<uint> miniGameSequencesUsed_ = new pbc::RepeatedField<uint>();
    /// <summary>
    /// 已玩miniGame序列
    /// </summary>
    public pbc::RepeatedField<uint> MiniGameSequencesUsed {
      get { return miniGameSequencesUsed_; }
    }

    private ulong miniGameTotalWin_;
    /// <summary>
    /// 小游戏总赢钱：respin + mini
    /// </summary>
    public ulong MiniGameTotalWin {
      get { return miniGameTotalWin_; }
      set {
        miniGameTotalWin_ = value;
      }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (lockedPanel_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(LockedPanel);
      }
      if (CollectedBonusSymbolCount != 0) {
        output.WriteRawTag(16);
        output.WriteUInt32(CollectedBonusSymbolCount);
      }
      miniGameSequences_.WriteTo(output, _repeated_miniGameSequences_codec);
      miniGameSequencesUsed_.WriteTo(output, _repeated_miniGameSequencesUsed_codec);
      if (MiniGameTotalWin != 0UL) {
        output.WriteRawTag(40);
        output.WriteUInt64(MiniGameTotalWin);
      }
    }

    public int CalculateSize() {
      int size = 0;
      if (lockedPanel_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(LockedPanel);
      }
      if (CollectedBonusSymbolCount != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(CollectedBonusSymbolCount);
      }
      size += miniGameSequences_.CalculateSize(_repeated_miniGameSequences_codec);
      size += miniGameSequencesUsed_.CalculateSize(_repeated_miniGameSequencesUsed_codec);
      if (MiniGameTotalWin != 0UL) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(MiniGameTotalWin);
      }
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            if (lockedPanel_ == null) {
              lockedPanel_ = new global::DragonU3DSDK.Network.API.ILProtocol.Panel();
            }
            input.ReadMessage(lockedPanel_);
            break;
          }
          case 16: {
            CollectedBonusSymbolCount = input.ReadUInt32();
            break;
          }
          case 26:
          case 24: {
            miniGameSequences_.AddEntriesFrom(input, _repeated_miniGameSequences_codec);
            break;
          }
          case 34:
          case 32: {
            miniGameSequencesUsed_.AddEntriesFrom(input, _repeated_miniGameSequencesUsed_codec);
            break;
          }
          case 40: {
            MiniGameTotalWin = input.ReadUInt64();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///================= 1003: TigerLoot ====================================
  /// </summary>
  public sealed class TigerLootGameConfigExtraInfo : pb::IMessage {
    private static readonly pb::MessageParser<TigerLootGameConfigExtraInfo> _parser = new pb::MessageParser<TigerLootGameConfigExtraInfo>(() => new TigerLootGameConfigExtraInfo());
    public static pb::MessageParser<TigerLootGameConfigExtraInfo> Parser { get { return _parser; } }

    private static readonly pb::FieldCodec<global::DragonU3DSDK.Network.API.ILProtocol.TigerLootGameConfigExtraInfo.Types.ReelUnlockConfig> _repeated_reelUnlock_codec
        = pb::FieldCodec.ForMessage(10, global::DragonU3DSDK.Network.API.ILProtocol.TigerLootGameConfigExtraInfo.Types.ReelUnlockConfig.Parser);
    private readonly pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.TigerLootGameConfigExtraInfo.Types.ReelUnlockConfig> reelUnlock_ = new pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.TigerLootGameConfigExtraInfo.Types.ReelUnlockConfig>();
    public pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.TigerLootGameConfigExtraInfo.Types.ReelUnlockConfig> ReelUnlock {
      get { return reelUnlock_; }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      reelUnlock_.WriteTo(output, _repeated_reelUnlock_codec);
    }

    public int CalculateSize() {
      int size = 0;
      size += reelUnlock_.CalculateSize(_repeated_reelUnlock_codec);
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            reelUnlock_.AddEntriesFrom(input, _repeated_reelUnlock_codec);
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the TigerLootGameConfigExtraInfo message type.</summary>
    public static class Types {
      public sealed class ReelUnlockConfig : pb::IMessage {
        private static readonly pb::MessageParser<ReelUnlockConfig> _parser = new pb::MessageParser<ReelUnlockConfig>(() => new ReelUnlockConfig());
        public static pb::MessageParser<ReelUnlockConfig> Parser { get { return _parser; } }

        private uint levelMin_;
        public uint LevelMin {
          get { return levelMin_; }
          set {
            levelMin_ = value;
          }
        }

        private uint levelMax_;
        public uint LevelMax {
          get { return levelMax_; }
          set {
            levelMax_ = value;
          }
        }

        private static readonly pb::FieldCodec<ulong> _repeated_unlockBet_codec
            = pb::FieldCodec.ForUInt64(26);
        private readonly pbc::RepeatedField<ulong> unlockBet_ = new pbc::RepeatedField<ulong>();
        public pbc::RepeatedField<ulong> UnlockBet {
          get { return unlockBet_; }
        }

        public void WriteTo(pb::CodedOutputStream output) {
          if (LevelMin != 0) {
            output.WriteRawTag(8);
            output.WriteUInt32(LevelMin);
          }
          if (LevelMax != 0) {
            output.WriteRawTag(16);
            output.WriteUInt32(LevelMax);
          }
          unlockBet_.WriteTo(output, _repeated_unlockBet_codec);
        }

        public int CalculateSize() {
          int size = 0;
          if (LevelMin != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(LevelMin);
          }
          if (LevelMax != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(LevelMax);
          }
          size += unlockBet_.CalculateSize(_repeated_unlockBet_codec);
          return size;
        }

        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                input.SkipLastField();
                break;
              case 8: {
                LevelMin = input.ReadUInt32();
                break;
              }
              case 16: {
                LevelMax = input.ReadUInt32();
                break;
              }
              case 26:
              case 24: {
                unlockBet_.AddEntriesFrom(input, _repeated_unlockBet_codec);
                break;
              }
            }
          }
        }

      }

    }
    #endregion

  }

  public sealed class TigerLootGameResultExtraInfo : pb::IMessage {
    private static readonly pb::MessageParser<TigerLootGameResultExtraInfo> _parser = new pb::MessageParser<TigerLootGameResultExtraInfo>(() => new TigerLootGameResultExtraInfo());
    public static pb::MessageParser<TigerLootGameResultExtraInfo> Parser { get { return _parser; } }

    private bool bonusGameCompleted_;
    /// <summary>
    /// bonus是否已结束
    /// </summary>
    public bool BonusGameCompleted {
      get { return bonusGameCompleted_; }
      set {
        bonusGameCompleted_ = value;
      }
    }

    private uint bonusFinishType_;
    /// <summary>
    /// 结束时中奖的icon类型
    /// </summary>
    public uint BonusFinishType {
      get { return bonusFinishType_; }
      set {
        bonusFinishType_ = value;
      }
    }

    private static readonly pb::FieldCodec<uint> _repeated_icons_codec
        = pb::FieldCodec.ForUInt32(34);
    private readonly pbc::RepeatedField<uint> icons_ = new pbc::RepeatedField<uint>();
    /// <summary>
    /// 玩家已开启的图标
    /// </summary>
    public pbc::RepeatedField<uint> Icons {
      get { return icons_; }
    }

    private static readonly pb::FieldCodec<uint> _repeated_userChoices_codec
        = pb::FieldCodec.ForUInt32(42);
    private readonly pbc::RepeatedField<uint> userChoices_ = new pbc::RepeatedField<uint>();
    /// <summary>
    /// 用户选择的索引序列
    /// </summary>
    public pbc::RepeatedField<uint> UserChoices {
      get { return userChoices_; }
    }

    private ulong totalBet_;
    /// <summary>
    /// </summary>
    public ulong TotalBet {
      get { return totalBet_; }
      set {
        totalBet_ = value;
      }
    }

    private uint winRate_;
    /// <summary>
    /// </summary>
    public uint WinRate {
      get { return winRate_; }
      set {
        winRate_ = value;
      }
    }

    private ulong totalWin_;
    /// <summary>
    /// </summary>
    public ulong TotalWin {
      get { return totalWin_; }
      set {
        totalWin_ = value;
      }
    }

    private uint userSelection_;
    /// <summary>
    /// 玩家最后一次选择的索引
    /// </summary>
    public uint UserSelection {
      get { return userSelection_; }
      set {
        userSelection_ = value;
      }
    }

    private static readonly pb::FieldCodec<uint> _repeated_sequences_codec
        = pb::FieldCodec.ForUInt32(82);
    private readonly pbc::RepeatedField<uint> sequences_ = new pbc::RepeatedField<uint>();
    public pbc::RepeatedField<uint> Sequences {
      get { return sequences_; }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (BonusGameCompleted != false) {
        output.WriteRawTag(8);
        output.WriteBool(BonusGameCompleted);
      }
      if (BonusFinishType != 0) {
        output.WriteRawTag(16);
        output.WriteUInt32(BonusFinishType);
      }
      icons_.WriteTo(output, _repeated_icons_codec);
      userChoices_.WriteTo(output, _repeated_userChoices_codec);
      if (TotalBet != 0UL) {
        output.WriteRawTag(48);
        output.WriteUInt64(TotalBet);
      }
      if (WinRate != 0) {
        output.WriteRawTag(56);
        output.WriteUInt32(WinRate);
      }
      if (TotalWin != 0UL) {
        output.WriteRawTag(64);
        output.WriteUInt64(TotalWin);
      }
      if (UserSelection != 0) {
        output.WriteRawTag(72);
        output.WriteUInt32(UserSelection);
      }
      sequences_.WriteTo(output, _repeated_sequences_codec);
    }

    public int CalculateSize() {
      int size = 0;
      if (BonusGameCompleted != false) {
        size += 1 + 1;
      }
      if (BonusFinishType != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(BonusFinishType);
      }
      size += icons_.CalculateSize(_repeated_icons_codec);
      size += userChoices_.CalculateSize(_repeated_userChoices_codec);
      if (TotalBet != 0UL) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(TotalBet);
      }
      if (WinRate != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(WinRate);
      }
      if (TotalWin != 0UL) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(TotalWin);
      }
      if (UserSelection != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(UserSelection);
      }
      size += sequences_.CalculateSize(_repeated_sequences_codec);
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            BonusGameCompleted = input.ReadBool();
            break;
          }
          case 16: {
            BonusFinishType = input.ReadUInt32();
            break;
          }
          case 34:
          case 32: {
            icons_.AddEntriesFrom(input, _repeated_icons_codec);
            break;
          }
          case 42:
          case 40: {
            userChoices_.AddEntriesFrom(input, _repeated_userChoices_codec);
            break;
          }
          case 48: {
            TotalBet = input.ReadUInt64();
            break;
          }
          case 56: {
            WinRate = input.ReadUInt32();
            break;
          }
          case 64: {
            TotalWin = input.ReadUInt64();
            break;
          }
          case 72: {
            UserSelection = input.ReadUInt32();
            break;
          }
          case 82:
          case 80: {
            sequences_.AddEntriesFrom(input, _repeated_sequences_codec);
            break;
          }
        }
      }
    }

  }

  public sealed class TigerLootBonusGameRequest : pb::IMessage {
    private static readonly pb::MessageParser<TigerLootBonusGameRequest> _parser = new pb::MessageParser<TigerLootBonusGameRequest>(() => new TigerLootBonusGameRequest());
    public static pb::MessageParser<TigerLootBonusGameRequest> Parser { get { return _parser; } }

    private uint choose_;
    /// <summary>
    /// 玩家选择的索引，从0开始
    /// </summary>
    public uint Choose {
      get { return choose_; }
      set {
        choose_ = value;
      }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (Choose != 0) {
        output.WriteRawTag(8);
        output.WriteUInt32(Choose);
      }
    }

    public int CalculateSize() {
      int size = 0;
      if (Choose != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Choose);
      }
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            Choose = input.ReadUInt32();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///================= 1004: LavaBounty ====================================
  /// </summary>
  public sealed class LockedFrame : pb::IMessage {
    private static readonly pb::MessageParser<LockedFrame> _parser = new pb::MessageParser<LockedFrame>(() => new LockedFrame());
    public static pb::MessageParser<LockedFrame> Parser { get { return _parser; } }

    private ulong bet_;
    /// <summary>
    /// 对应的bet
    /// </summary>
    public ulong Bet {
      get { return bet_; }
      set {
        bet_ = value;
      }
    }

    private static readonly pb::FieldCodec<uint> _repeated_positions_codec
        = pb::FieldCodec.ForUInt32(18);
    private readonly pbc::RepeatedField<uint> positions_ = new pbc::RepeatedField<uint>();
    /// <summary>
    /// frame的id， 1～22
    /// </summary>
    public pbc::RepeatedField<uint> Positions {
      get { return positions_; }
    }

    private static readonly pb::FieldCodec<uint> _repeated_prePositions_codec
        = pb::FieldCodec.ForUInt32(26);
    private readonly pbc::RepeatedField<uint> prePositions_ = new pbc::RepeatedField<uint>();
    /// <summary>
    /// 上一局的框
    /// </summary>
    public pbc::RepeatedField<uint> PrePositions {
      get { return prePositions_; }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (Bet != 0UL) {
        output.WriteRawTag(8);
        output.WriteUInt64(Bet);
      }
      positions_.WriteTo(output, _repeated_positions_codec);
      prePositions_.WriteTo(output, _repeated_prePositions_codec);
    }

    public int CalculateSize() {
      int size = 0;
      if (Bet != 0UL) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(Bet);
      }
      size += positions_.CalculateSize(_repeated_positions_codec);
      size += prePositions_.CalculateSize(_repeated_prePositions_codec);
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            Bet = input.ReadUInt64();
            break;
          }
          case 18:
          case 16: {
            positions_.AddEntriesFrom(input, _repeated_positions_codec);
            break;
          }
          case 26:
          case 24: {
            prePositions_.AddEntriesFrom(input, _repeated_prePositions_codec);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// LavaBounty游戏结果扩展数据
  /// </summary>
  public sealed class LavaBountyGameResultExtraInfo : pb::IMessage {
    private static readonly pb::MessageParser<LavaBountyGameResultExtraInfo> _parser = new pb::MessageParser<LavaBountyGameResultExtraInfo>(() => new LavaBountyGameResultExtraInfo());
    public static pb::MessageParser<LavaBountyGameResultExtraInfo> Parser { get { return _parser; } }

    private static readonly pb::FieldCodec<uint> _repeated_startWildFrames_codec
        = pb::FieldCodec.ForUInt32(10);
    private readonly pbc::RepeatedField<uint> startWildFrames_ = new pbc::RepeatedField<uint>();
    /// <summary>
    /// 起点wild
    /// </summary>
    public pbc::RepeatedField<uint> StartWildFrames {
      get { return startWildFrames_; }
    }

    private static readonly pb::FieldCodec<uint> _repeated_wildFrames_codec
        = pb::FieldCodec.ForUInt32(18);
    private readonly pbc::RepeatedField<uint> wildFrames_ = new pbc::RepeatedField<uint>();
    /// <summary>
    /// 变成wild图标的框
    /// </summary>
    public pbc::RepeatedField<uint> WildFrames {
      get { return wildFrames_; }
    }

    private static readonly pb::FieldCodec<uint> _repeated_randomFrames_codec
        = pb::FieldCodec.ForUInt32(26);
    private readonly pbc::RepeatedField<uint> randomFrames_ = new pbc::RepeatedField<uint>();
    /// <summary>
    /// 本次spin随机出现的框
    /// </summary>
    public pbc::RepeatedField<uint> RandomFrames {
      get { return randomFrames_; }
    }

    private static readonly pb::FieldCodec<uint> _repeated_randomLions_codec
        = pb::FieldCodec.ForUInt32(34);
    private readonly pbc::RepeatedField<uint> randomLions_ = new pbc::RepeatedField<uint>();
    /// <summary>
    /// 随机出现的狮子
    /// </summary>
    public pbc::RepeatedField<uint> RandomLions {
      get { return randomLions_; }
    }

    private uint bonusSymbolCount_;
    /// <summary>
    /// 本次要随机出狮子图标的数量，freeGame才有
    /// </summary>
    public uint BonusSymbolCount {
      get { return bonusSymbolCount_; }
      set {
        bonusSymbolCount_ = value;
      }
    }

    private int rouletteId_;
    /// <summary>
    /// super bonus锁定的轮盘id
    /// </summary>
    public int RouletteId {
      get { return rouletteId_; }
      set {
        rouletteId_ = value;
      }
    }

    private static readonly pbc::MapField<ulong, global::DragonU3DSDK.Network.API.ILProtocol.LockedFrame>.Codec _map_frames_codec
        = new pbc::MapField<ulong, global::DragonU3DSDK.Network.API.ILProtocol.LockedFrame>.Codec(pb::FieldCodec.ForUInt64(8), pb::FieldCodec.ForMessage(18, global::DragonU3DSDK.Network.API.ILProtocol.LockedFrame.Parser), 58);
    private readonly pbc::MapField<ulong, global::DragonU3DSDK.Network.API.ILProtocol.LockedFrame> frames_ = new pbc::MapField<ulong, global::DragonU3DSDK.Network.API.ILProtocol.LockedFrame>();
    /// <summary>
    /// 普通锁定的框
    /// </summary>
    public pbc::MapField<ulong, global::DragonU3DSDK.Network.API.ILProtocol.LockedFrame> Frames {
      get { return frames_; }
    }

    private global::DragonU3DSDK.Network.API.ILProtocol.LockedFrame superBonusLockedFrames_;
    /// <summary>
    /// super bonus锁定的框
    /// </summary>
    public global::DragonU3DSDK.Network.API.ILProtocol.LockedFrame SuperBonusLockedFrames {
      get { return superBonusLockedFrames_; }
      set {
        superBonusLockedFrames_ = value;
      }
    }

    private uint newFrameCount_;
    /// <summary>
    /// 本次spin新增的框的数量
    /// </summary>
    public uint NewFrameCount {
      get { return newFrameCount_; }
      set {
        newFrameCount_ = value;
      }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      startWildFrames_.WriteTo(output, _repeated_startWildFrames_codec);
      wildFrames_.WriteTo(output, _repeated_wildFrames_codec);
      randomFrames_.WriteTo(output, _repeated_randomFrames_codec);
      randomLions_.WriteTo(output, _repeated_randomLions_codec);
      if (BonusSymbolCount != 0) {
        output.WriteRawTag(40);
        output.WriteUInt32(BonusSymbolCount);
      }
      if (RouletteId != 0) {
        output.WriteRawTag(48);
        output.WriteInt32(RouletteId);
      }
      frames_.WriteTo(output, _map_frames_codec);
      if (superBonusLockedFrames_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(SuperBonusLockedFrames);
      }
      if (NewFrameCount != 0) {
        output.WriteRawTag(72);
        output.WriteUInt32(NewFrameCount);
      }
    }

    public int CalculateSize() {
      int size = 0;
      size += startWildFrames_.CalculateSize(_repeated_startWildFrames_codec);
      size += wildFrames_.CalculateSize(_repeated_wildFrames_codec);
      size += randomFrames_.CalculateSize(_repeated_randomFrames_codec);
      size += randomLions_.CalculateSize(_repeated_randomLions_codec);
      if (BonusSymbolCount != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(BonusSymbolCount);
      }
      if (RouletteId != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(RouletteId);
      }
      size += frames_.CalculateSize(_map_frames_codec);
      if (superBonusLockedFrames_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(SuperBonusLockedFrames);
      }
      if (NewFrameCount != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(NewFrameCount);
      }
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10:
          case 8: {
            startWildFrames_.AddEntriesFrom(input, _repeated_startWildFrames_codec);
            break;
          }
          case 18:
          case 16: {
            wildFrames_.AddEntriesFrom(input, _repeated_wildFrames_codec);
            break;
          }
          case 26:
          case 24: {
            randomFrames_.AddEntriesFrom(input, _repeated_randomFrames_codec);
            break;
          }
          case 34:
          case 32: {
            randomLions_.AddEntriesFrom(input, _repeated_randomLions_codec);
            break;
          }
          case 40: {
            BonusSymbolCount = input.ReadUInt32();
            break;
          }
          case 48: {
            RouletteId = input.ReadInt32();
            break;
          }
          case 58: {
            frames_.AddEntriesFrom(input, _map_frames_codec);
            break;
          }
          case 66: {
            if (superBonusLockedFrames_ == null) {
              superBonusLockedFrames_ = new global::DragonU3DSDK.Network.API.ILProtocol.LockedFrame();
            }
            input.ReadMessage(superBonusLockedFrames_);
            break;
          }
          case 72: {
            NewFrameCount = input.ReadUInt32();
            break;
          }
        }
      }
    }

  }

  public sealed class LavaBounty2GameResultExtraInfo : pb::IMessage {
    private static readonly pb::MessageParser<LavaBounty2GameResultExtraInfo> _parser = new pb::MessageParser<LavaBounty2GameResultExtraInfo>(() => new LavaBounty2GameResultExtraInfo());
    public static pb::MessageParser<LavaBounty2GameResultExtraInfo> Parser { get { return _parser; } }

    private static readonly pb::FieldCodec<uint> _repeated_startWildFrames_codec
        = pb::FieldCodec.ForUInt32(10);
    private readonly pbc::RepeatedField<uint> startWildFrames_ = new pbc::RepeatedField<uint>();
    /// <summary>
    /// 起点wild
    /// </summary>
    public pbc::RepeatedField<uint> StartWildFrames {
      get { return startWildFrames_; }
    }

    private static readonly pb::FieldCodec<uint> _repeated_wildFrames_codec
        = pb::FieldCodec.ForUInt32(18);
    private readonly pbc::RepeatedField<uint> wildFrames_ = new pbc::RepeatedField<uint>();
    /// <summary>
    /// 变成wild图标的框
    /// </summary>
    public pbc::RepeatedField<uint> WildFrames {
      get { return wildFrames_; }
    }

    private static readonly pb::FieldCodec<uint> _repeated_randomFrames_codec
        = pb::FieldCodec.ForUInt32(26);
    private readonly pbc::RepeatedField<uint> randomFrames_ = new pbc::RepeatedField<uint>();
    /// <summary>
    /// 本次spin随机出现的框
    /// </summary>
    public pbc::RepeatedField<uint> RandomFrames {
      get { return randomFrames_; }
    }

    private static readonly pb::FieldCodec<uint> _repeated_randomLions_codec
        = pb::FieldCodec.ForUInt32(34);
    private readonly pbc::RepeatedField<uint> randomLions_ = new pbc::RepeatedField<uint>();
    /// <summary>
    /// 随机出现的狮子
    /// </summary>
    public pbc::RepeatedField<uint> RandomLions {
      get { return randomLions_; }
    }

    private uint bonusSymbolCount_;
    /// <summary>
    /// 本次要随机出狮子图标的数量，freeGame才有
    /// </summary>
    public uint BonusSymbolCount {
      get { return bonusSymbolCount_; }
      set {
        bonusSymbolCount_ = value;
      }
    }

    private int rouletteId_;
    /// <summary>
    /// super bonus锁定的轮盘id
    /// </summary>
    public int RouletteId {
      get { return rouletteId_; }
      set {
        rouletteId_ = value;
      }
    }

    private static readonly pbc::MapField<ulong, global::DragonU3DSDK.Network.API.ILProtocol.LockedFrame>.Codec _map_frames_codec
        = new pbc::MapField<ulong, global::DragonU3DSDK.Network.API.ILProtocol.LockedFrame>.Codec(pb::FieldCodec.ForUInt64(8), pb::FieldCodec.ForMessage(18, global::DragonU3DSDK.Network.API.ILProtocol.LockedFrame.Parser), 58);
    private readonly pbc::MapField<ulong, global::DragonU3DSDK.Network.API.ILProtocol.LockedFrame> frames_ = new pbc::MapField<ulong, global::DragonU3DSDK.Network.API.ILProtocol.LockedFrame>();
    /// <summary>
    /// 普通锁定的框
    /// </summary>
    public pbc::MapField<ulong, global::DragonU3DSDK.Network.API.ILProtocol.LockedFrame> Frames {
      get { return frames_; }
    }

    private global::DragonU3DSDK.Network.API.ILProtocol.LockedFrame superBonusLockedFrames_;
    /// <summary>
    /// super bonus锁定的框
    /// </summary>
    public global::DragonU3DSDK.Network.API.ILProtocol.LockedFrame SuperBonusLockedFrames {
      get { return superBonusLockedFrames_; }
      set {
        superBonusLockedFrames_ = value;
      }
    }

    private uint newFrameCount_;
    /// <summary>
    /// 本次spin新增的框的数量
    /// </summary>
    public uint NewFrameCount {
      get { return newFrameCount_; }
      set {
        newFrameCount_ = value;
      }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      startWildFrames_.WriteTo(output, _repeated_startWildFrames_codec);
      wildFrames_.WriteTo(output, _repeated_wildFrames_codec);
      randomFrames_.WriteTo(output, _repeated_randomFrames_codec);
      randomLions_.WriteTo(output, _repeated_randomLions_codec);
      if (BonusSymbolCount != 0) {
        output.WriteRawTag(40);
        output.WriteUInt32(BonusSymbolCount);
      }
      if (RouletteId != 0) {
        output.WriteRawTag(48);
        output.WriteInt32(RouletteId);
      }
      frames_.WriteTo(output, _map_frames_codec);
      if (superBonusLockedFrames_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(SuperBonusLockedFrames);
      }
      if (NewFrameCount != 0) {
        output.WriteRawTag(72);
        output.WriteUInt32(NewFrameCount);
      }
    }

    public int CalculateSize() {
      int size = 0;
      size += startWildFrames_.CalculateSize(_repeated_startWildFrames_codec);
      size += wildFrames_.CalculateSize(_repeated_wildFrames_codec);
      size += randomFrames_.CalculateSize(_repeated_randomFrames_codec);
      size += randomLions_.CalculateSize(_repeated_randomLions_codec);
      if (BonusSymbolCount != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(BonusSymbolCount);
      }
      if (RouletteId != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(RouletteId);
      }
      size += frames_.CalculateSize(_map_frames_codec);
      if (superBonusLockedFrames_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(SuperBonusLockedFrames);
      }
      if (NewFrameCount != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(NewFrameCount);
      }
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10:
          case 8: {
            startWildFrames_.AddEntriesFrom(input, _repeated_startWildFrames_codec);
            break;
          }
          case 18:
          case 16: {
            wildFrames_.AddEntriesFrom(input, _repeated_wildFrames_codec);
            break;
          }
          case 26:
          case 24: {
            randomFrames_.AddEntriesFrom(input, _repeated_randomFrames_codec);
            break;
          }
          case 34:
          case 32: {
            randomLions_.AddEntriesFrom(input, _repeated_randomLions_codec);
            break;
          }
          case 40: {
            BonusSymbolCount = input.ReadUInt32();
            break;
          }
          case 48: {
            RouletteId = input.ReadInt32();
            break;
          }
          case 58: {
            frames_.AddEntriesFrom(input, _map_frames_codec);
            break;
          }
          case 66: {
            if (superBonusLockedFrames_ == null) {
              superBonusLockedFrames_ = new global::DragonU3DSDK.Network.API.ILProtocol.LockedFrame();
            }
            input.ReadMessage(superBonusLockedFrames_);
            break;
          }
          case 72: {
            NewFrameCount = input.ReadUInt32();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// IrishPrincess不同bet分开存储的信息
  /// </summary>
  public sealed class IrishPrincessBetInfo : pb::IMessage {
    private static readonly pb::MessageParser<IrishPrincessBetInfo> _parser = new pb::MessageParser<IrishPrincessBetInfo>(() => new IrishPrincessBetInfo());
    public static pb::MessageParser<IrishPrincessBetInfo> Parser { get { return _parser; } }

    private uint counter_;
    /// <summary>
    /// 游戏局数计数器
    /// </summary>
    public uint Counter {
      get { return counter_; }
      set {
        counter_ = value;
      }
    }

    private static readonly pb::FieldCodec<uint> _repeated_frames_codec
        = pb::FieldCodec.ForUInt32(18);
    private readonly pbc::RepeatedField<uint> frames_ = new pbc::RepeatedField<uint>();
    /// <summary>
    /// 对应的框
    /// </summary>
    public pbc::RepeatedField<uint> Frames {
      get { return frames_; }
    }

    private static readonly pb::FieldCodec<uint> _repeated_randomFrameAppearSpin_codec
        = pb::FieldCodec.ForUInt32(26);
    private readonly pbc::RepeatedField<uint> randomFrameAppearSpin_ = new pbc::RepeatedField<uint>();
    /// <summary>
    /// 本轮游戏中出现random frame的局数，1 ～ 10
    /// </summary>
    public pbc::RepeatedField<uint> RandomFrameAppearSpin {
      get { return randomFrameAppearSpin_; }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (Counter != 0) {
        output.WriteRawTag(8);
        output.WriteUInt32(Counter);
      }
      frames_.WriteTo(output, _repeated_frames_codec);
      randomFrameAppearSpin_.WriteTo(output, _repeated_randomFrameAppearSpin_codec);
    }

    public int CalculateSize() {
      int size = 0;
      if (Counter != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Counter);
      }
      size += frames_.CalculateSize(_repeated_frames_codec);
      size += randomFrameAppearSpin_.CalculateSize(_repeated_randomFrameAppearSpin_codec);
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            Counter = input.ReadUInt32();
            break;
          }
          case 18:
          case 16: {
            frames_.AddEntriesFrom(input, _repeated_frames_codec);
            break;
          }
          case 26:
          case 24: {
            randomFrameAppearSpin_.AddEntriesFrom(input, _repeated_randomFrameAppearSpin_codec);
            break;
          }
        }
      }
    }

  }

  public sealed class IrishPrincessSuperBonusInfo : pb::IMessage {
    private static readonly pb::MessageParser<IrishPrincessSuperBonusInfo> _parser = new pb::MessageParser<IrishPrincessSuperBonusInfo>(() => new IrishPrincessSuperBonusInfo());
    public static pb::MessageParser<IrishPrincessSuperBonusInfo> Parser { get { return _parser; } }

    private global::DragonU3DSDK.Network.API.ILProtocol.Panel lastPanel_;
    /// <summary>
    /// 最后一次super bonus的panel
    /// </summary>
    public global::DragonU3DSDK.Network.API.ILProtocol.Panel LastPanel {
      get { return lastPanel_; }
      set {
        lastPanel_ = value;
      }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (lastPanel_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(LastPanel);
      }
    }

    public int CalculateSize() {
      int size = 0;
      if (lastPanel_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(LastPanel);
      }
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            if (lastPanel_ == null) {
              lastPanel_ = new global::DragonU3DSDK.Network.API.ILProtocol.Panel();
            }
            input.ReadMessage(lastPanel_);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// IrishPrincess游戏结果扩展信息
  /// </summary>
  public sealed class IrishPrincessGameResultExtraInfo : pb::IMessage {
    private static readonly pb::MessageParser<IrishPrincessGameResultExtraInfo> _parser = new pb::MessageParser<IrishPrincessGameResultExtraInfo>(() => new IrishPrincessGameResultExtraInfo());
    public static pb::MessageParser<IrishPrincessGameResultExtraInfo> Parser { get { return _parser; } }

    private static readonly pbc::MapField<uint, global::DragonU3DSDK.Network.API.ILProtocol.IrishPrincessBetInfo>.Codec _map_betInfos_codec
        = new pbc::MapField<uint, global::DragonU3DSDK.Network.API.ILProtocol.IrishPrincessBetInfo>.Codec(pb::FieldCodec.ForUInt32(8), pb::FieldCodec.ForMessage(18, global::DragonU3DSDK.Network.API.ILProtocol.IrishPrincessBetInfo.Parser), 10);
    private readonly pbc::MapField<uint, global::DragonU3DSDK.Network.API.ILProtocol.IrishPrincessBetInfo> betInfos_ = new pbc::MapField<uint, global::DragonU3DSDK.Network.API.ILProtocol.IrishPrincessBetInfo>();
    /// <summary>
    /// 记录普通游戏的框
    /// </summary>
    public pbc::MapField<uint, global::DragonU3DSDK.Network.API.ILProtocol.IrishPrincessBetInfo> BetInfos {
      get { return betInfos_; }
    }

    private static readonly pb::FieldCodec<uint> _repeated_freeSpinFrames_codec
        = pb::FieldCodec.ForUInt32(18);
    private readonly pbc::RepeatedField<uint> freeSpinFrames_ = new pbc::RepeatedField<uint>();
    /// <summary>
    /// free game的框
    /// </summary>
    public pbc::RepeatedField<uint> FreeSpinFrames {
      get { return freeSpinFrames_; }
    }

    private static readonly pbc::MapField<uint, uint>.Codec _map_reSpinFrames_codec
        = new pbc::MapField<uint, uint>.Codec(pb::FieldCodec.ForUInt32(8), pb::FieldCodec.ForUInt32(16), 26);
    private readonly pbc::MapField<uint, uint> reSpinFrames_ = new pbc::MapField<uint, uint>();
    /// <summary>
    /// 记录re spin的格子，key为格子id，value为对应symbol id
    /// </summary>
    public pbc::MapField<uint, uint> ReSpinFrames {
      get { return reSpinFrames_; }
    }

    private global::DragonU3DSDK.Network.API.ILProtocol.IrishPrincessSuperBonusInfo superBonusInfo_;
    /// <summary>
    /// super bonus信息
    /// </summary>
    public global::DragonU3DSDK.Network.API.ILProtocol.IrishPrincessSuperBonusInfo SuperBonusInfo {
      get { return superBonusInfo_; }
      set {
        superBonusInfo_ = value;
      }
    }

    private int superBonusChoose_;
    /// <summary>
    /// 用户当前选择
    /// </summary>
    public int SuperBonusChoose {
      get { return superBonusChoose_; }
      set {
        superBonusChoose_ = value;
      }
    }

    private static readonly pb::FieldCodec<uint> _repeated_superBonusSequences_codec
        = pb::FieldCodec.ForUInt32(50);
    private readonly pbc::RepeatedField<uint> superBonusSequences_ = new pbc::RepeatedField<uint>();
    /// <summary>
    /// 生成的心心序列
    /// </summary>
    public pbc::RepeatedField<uint> SuperBonusSequences {
      get { return superBonusSequences_; }
    }

    private static readonly pb::FieldCodec<uint> _repeated_randomFrames_codec
        = pb::FieldCodec.ForUInt32(58);
    private readonly pbc::RepeatedField<uint> randomFrames_ = new pbc::RepeatedField<uint>();
    /// <summary>
    /// 本次spin随机出现的框
    /// </summary>
    public pbc::RepeatedField<uint> RandomFrames {
      get { return randomFrames_; }
    }

    private static readonly pbc::MapField<uint, uint>.Codec _map_wildFrames_codec
        = new pbc::MapField<uint, uint>.Codec(pb::FieldCodec.ForUInt32(8), pb::FieldCodec.ForUInt32(16), 66);
    private readonly pbc::MapField<uint, uint> wildFrames_ = new pbc::MapField<uint, uint>();
    /// <summary>
    /// 变成wild或者具体数字的框，key为格子id，value为对应symbol id
    /// </summary>
    public pbc::MapField<uint, uint> WildFrames {
      get { return wildFrames_; }
    }

    private uint newNormalFrameCount_;
    /// <summary>
    /// 新增的四叶草变的框的数量
    /// </summary>
    public uint NewNormalFrameCount {
      get { return newNormalFrameCount_; }
      set {
        newNormalFrameCount_ = value;
      }
    }

    private ulong superBonusExternalWin_;
    /// <summary>
    /// 免费游戏4选1赢的钱
    /// </summary>
    public ulong SuperBonusExternalWin {
      get { return superBonusExternalWin_; }
      set {
        superBonusExternalWin_ = value;
      }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      betInfos_.WriteTo(output, _map_betInfos_codec);
      freeSpinFrames_.WriteTo(output, _repeated_freeSpinFrames_codec);
      reSpinFrames_.WriteTo(output, _map_reSpinFrames_codec);
      if (superBonusInfo_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(SuperBonusInfo);
      }
      if (SuperBonusChoose != 0) {
        output.WriteRawTag(40);
        output.WriteInt32(SuperBonusChoose);
      }
      superBonusSequences_.WriteTo(output, _repeated_superBonusSequences_codec);
      randomFrames_.WriteTo(output, _repeated_randomFrames_codec);
      wildFrames_.WriteTo(output, _map_wildFrames_codec);
      if (NewNormalFrameCount != 0) {
        output.WriteRawTag(72);
        output.WriteUInt32(NewNormalFrameCount);
      }
      if (SuperBonusExternalWin != 0UL) {
        output.WriteRawTag(80);
        output.WriteUInt64(SuperBonusExternalWin);
      }
    }

    public int CalculateSize() {
      int size = 0;
      size += betInfos_.CalculateSize(_map_betInfos_codec);
      size += freeSpinFrames_.CalculateSize(_repeated_freeSpinFrames_codec);
      size += reSpinFrames_.CalculateSize(_map_reSpinFrames_codec);
      if (superBonusInfo_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(SuperBonusInfo);
      }
      if (SuperBonusChoose != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(SuperBonusChoose);
      }
      size += superBonusSequences_.CalculateSize(_repeated_superBonusSequences_codec);
      size += randomFrames_.CalculateSize(_repeated_randomFrames_codec);
      size += wildFrames_.CalculateSize(_map_wildFrames_codec);
      if (NewNormalFrameCount != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(NewNormalFrameCount);
      }
      if (SuperBonusExternalWin != 0UL) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(SuperBonusExternalWin);
      }
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            betInfos_.AddEntriesFrom(input, _map_betInfos_codec);
            break;
          }
          case 18:
          case 16: {
            freeSpinFrames_.AddEntriesFrom(input, _repeated_freeSpinFrames_codec);
            break;
          }
          case 26: {
            reSpinFrames_.AddEntriesFrom(input, _map_reSpinFrames_codec);
            break;
          }
          case 34: {
            if (superBonusInfo_ == null) {
              superBonusInfo_ = new global::DragonU3DSDK.Network.API.ILProtocol.IrishPrincessSuperBonusInfo();
            }
            input.ReadMessage(superBonusInfo_);
            break;
          }
          case 40: {
            SuperBonusChoose = input.ReadInt32();
            break;
          }
          case 50:
          case 48: {
            superBonusSequences_.AddEntriesFrom(input, _repeated_superBonusSequences_codec);
            break;
          }
          case 58:
          case 56: {
            randomFrames_.AddEntriesFrom(input, _repeated_randomFrames_codec);
            break;
          }
          case 66: {
            wildFrames_.AddEntriesFrom(input, _map_wildFrames_codec);
            break;
          }
          case 72: {
            NewNormalFrameCount = input.ReadUInt32();
            break;
          }
          case 80: {
            SuperBonusExternalWin = input.ReadUInt64();
            break;
          }
        }
      }
    }

  }

  public sealed class IrishPrincessBonusGameRequest : pb::IMessage {
    private static readonly pb::MessageParser<IrishPrincessBonusGameRequest> _parser = new pb::MessageParser<IrishPrincessBonusGameRequest>(() => new IrishPrincessBonusGameRequest());
    public static pb::MessageParser<IrishPrincessBonusGameRequest> Parser { get { return _parser; } }

    private uint choose_;
    /// <summary>
    /// 玩家选择的索引，从0开始
    /// </summary>
    public uint Choose {
      get { return choose_; }
      set {
        choose_ = value;
      }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (Choose != 0) {
        output.WriteRawTag(8);
        output.WriteUInt32(Choose);
      }
    }

    public int CalculateSize() {
      int size = 0;
      if (Choose != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Choose);
      }
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            Choose = input.ReadUInt32();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///================= 1006: QuestOfLegends ====================================
  /// </summary>
  public sealed class QuestOfLegendsGameResultExtraInfo : pb::IMessage {
    private static readonly pb::MessageParser<QuestOfLegendsGameResultExtraInfo> _parser = new pb::MessageParser<QuestOfLegendsGameResultExtraInfo>(() => new QuestOfLegendsGameResultExtraInfo());
    public static pb::MessageParser<QuestOfLegendsGameResultExtraInfo> Parser { get { return _parser; } }

    private uint bigSymbolId_;
    /// <summary>
    /// 大图标id
    /// </summary>
    public uint BigSymbolId {
      get { return bigSymbolId_; }
      set {
        bigSymbolId_ = value;
      }
    }

    private static readonly pb::FieldCodec<uint> _repeated_bigSymbolStartPosition_codec
        = pb::FieldCodec.ForUInt32(18);
    private readonly pbc::RepeatedField<uint> bigSymbolStartPosition_ = new pbc::RepeatedField<uint>();
    /// <summary>
    /// 大图标起点位置
    /// </summary>
    public pbc::RepeatedField<uint> BigSymbolStartPosition {
      get { return bigSymbolStartPosition_; }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (BigSymbolId != 0) {
        output.WriteRawTag(8);
        output.WriteUInt32(BigSymbolId);
      }
      bigSymbolStartPosition_.WriteTo(output, _repeated_bigSymbolStartPosition_codec);
    }

    public int CalculateSize() {
      int size = 0;
      if (BigSymbolId != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(BigSymbolId);
      }
      size += bigSymbolStartPosition_.CalculateSize(_repeated_bigSymbolStartPosition_codec);
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            BigSymbolId = input.ReadUInt32();
            break;
          }
          case 18:
          case 16: {
            bigSymbolStartPosition_.AddEntriesFrom(input, _repeated_bigSymbolStartPosition_codec);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// 代币收集数据
  /// </summary>
  public sealed class WarriorKingItemData : pb::IMessage {
    private static readonly pb::MessageParser<WarriorKingItemData> _parser = new pb::MessageParser<WarriorKingItemData>(() => new WarriorKingItemData());
    public static pb::MessageParser<WarriorKingItemData> Parser { get { return _parser; } }

    private ulong avgBet_;
    /// <summary>
    /// 当前平均值
    /// </summary>
    public ulong AvgBet {
      get { return avgBet_; }
      set {
        avgBet_ = value;
      }
    }

    private uint totalSpinCount_;
    /// <summary>
    /// 统计的总次数
    /// </summary>
    public uint TotalSpinCount {
      get { return totalSpinCount_; }
      set {
        totalSpinCount_ = value;
      }
    }

    private uint itemCount_;
    /// <summary>
    /// 当前剩余的桃子数
    /// </summary>
    public uint ItemCount {
      get { return itemCount_; }
      set {
        itemCount_ = value;
      }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (AvgBet != 0UL) {
        output.WriteRawTag(8);
        output.WriteUInt64(AvgBet);
      }
      if (TotalSpinCount != 0) {
        output.WriteRawTag(16);
        output.WriteUInt32(TotalSpinCount);
      }
      if (ItemCount != 0) {
        output.WriteRawTag(24);
        output.WriteUInt32(ItemCount);
      }
    }

    public int CalculateSize() {
      int size = 0;
      if (AvgBet != 0UL) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(AvgBet);
      }
      if (TotalSpinCount != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(TotalSpinCount);
      }
      if (ItemCount != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(ItemCount);
      }
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            AvgBet = input.ReadUInt64();
            break;
          }
          case 16: {
            TotalSpinCount = input.ReadUInt32();
            break;
          }
          case 24: {
            ItemCount = input.ReadUInt32();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// 角色对应的格子信息
  /// </summary>
  public sealed class WarriorKingLevelSlot : pb::IMessage {
    private static readonly pb::MessageParser<WarriorKingLevelSlot> _parser = new pb::MessageParser<WarriorKingLevelSlot>(() => new WarriorKingLevelSlot());
    public static pb::MessageParser<WarriorKingLevelSlot> Parser { get { return _parser; } }

    private uint slotType_;
    /// <summary>
    /// 格子信息类型，0 具体的钱 1 freeGame 2 bonusGame
    /// </summary>
    public uint SlotType {
      get { return slotType_; }
      set {
        slotType_ = value;
      }
    }

    private ulong slotValue_;
    /// <summary>
    /// 钱的数量
    /// </summary>
    public ulong SlotValue {
      get { return slotValue_; }
      set {
        slotValue_ = value;
      }
    }

    private bool opened_;
    /// <summary>
    /// 是否开启
    /// </summary>
    public bool Opened {
      get { return opened_; }
      set {
        opened_ = value;
      }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (SlotType != 0) {
        output.WriteRawTag(8);
        output.WriteUInt32(SlotType);
      }
      if (SlotValue != 0UL) {
        output.WriteRawTag(16);
        output.WriteUInt64(SlotValue);
      }
      if (Opened != false) {
        output.WriteRawTag(24);
        output.WriteBool(Opened);
      }
    }

    public int CalculateSize() {
      int size = 0;
      if (SlotType != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(SlotType);
      }
      if (SlotValue != 0UL) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(SlotValue);
      }
      if (Opened != false) {
        size += 1 + 1;
      }
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            SlotType = input.ReadUInt32();
            break;
          }
          case 16: {
            SlotValue = input.ReadUInt64();
            break;
          }
          case 24: {
            Opened = input.ReadBool();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// 角色数据
  /// </summary>
  public sealed class WarriorKingRoleData : pb::IMessage {
    private static readonly pb::MessageParser<WarriorKingRoleData> _parser = new pb::MessageParser<WarriorKingRoleData>(() => new WarriorKingRoleData());
    public static pb::MessageParser<WarriorKingRoleData> Parser { get { return _parser; } }

    private uint id_;
    /// <summary>
    /// role id
    /// </summary>
    public uint Id {
      get { return id_; }
      set {
        id_ = value;
      }
    }

    private uint rank_;
    /// <summary>
    /// 当前等级
    /// </summary>
    public uint Rank {
      get { return rank_; }
      set {
        rank_ = value;
      }
    }

    private static readonly pb::FieldCodec<uint> _repeated_equips_codec
        = pb::FieldCodec.ForUInt32(26);
    private readonly pbc::RepeatedField<uint> equips_ = new pbc::RepeatedField<uint>();
    /// <summary>
    /// 当前装备
    /// </summary>
    public pbc::RepeatedField<uint> Equips {
      get { return equips_; }
    }

    private static readonly pb::FieldCodec<global::DragonU3DSDK.Network.API.ILProtocol.WarriorKingLevelSlot> _repeated_levelSlots_codec
        = pb::FieldCodec.ForMessage(34, global::DragonU3DSDK.Network.API.ILProtocol.WarriorKingLevelSlot.Parser);
    private readonly pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.WarriorKingLevelSlot> levelSlots_ = new pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.WarriorKingLevelSlot>();
    /// <summary>
    /// 升级格子列表，下标0～8
    /// </summary>
    public pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.WarriorKingLevelSlot> LevelSlots {
      get { return levelSlots_; }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (Id != 0) {
        output.WriteRawTag(8);
        output.WriteUInt32(Id);
      }
      if (Rank != 0) {
        output.WriteRawTag(16);
        output.WriteUInt32(Rank);
      }
      equips_.WriteTo(output, _repeated_equips_codec);
      levelSlots_.WriteTo(output, _repeated_levelSlots_codec);
    }

    public int CalculateSize() {
      int size = 0;
      if (Id != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Id);
      }
      if (Rank != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Rank);
      }
      size += equips_.CalculateSize(_repeated_equips_codec);
      size += levelSlots_.CalculateSize(_repeated_levelSlots_codec);
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            Id = input.ReadUInt32();
            break;
          }
          case 16: {
            Rank = input.ReadUInt32();
            break;
          }
          case 26:
          case 24: {
            equips_.AddEntriesFrom(input, _repeated_equips_codec);
            break;
          }
          case 34: {
            levelSlots_.AddEntriesFrom(input, _repeated_levelSlots_codec);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// bonus game某一层的数据
  /// </summary>
  public sealed class WarriorKingBonusGameLayer : pb::IMessage {
    private static readonly pb::MessageParser<WarriorKingBonusGameLayer> _parser = new pb::MessageParser<WarriorKingBonusGameLayer>(() => new WarriorKingBonusGameLayer());
    public static pb::MessageParser<WarriorKingBonusGameLayer> Parser { get { return _parser; } }

    private uint choose_;
    public uint Choose {
      get { return choose_; }
      set {
        choose_ = value;
      }
    }

    private static readonly pb::FieldCodec<uint> _repeated_sequences_codec
        = pb::FieldCodec.ForUInt32(18);
    private readonly pbc::RepeatedField<uint> sequences_ = new pbc::RepeatedField<uint>();
    /// <summary>
    /// 这一层的元素列表
    /// </summary>
    public pbc::RepeatedField<uint> Sequences {
      get { return sequences_; }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (Choose != 0) {
        output.WriteRawTag(8);
        output.WriteUInt32(Choose);
      }
      sequences_.WriteTo(output, _repeated_sequences_codec);
    }

    public int CalculateSize() {
      int size = 0;
      if (Choose != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Choose);
      }
      size += sequences_.CalculateSize(_repeated_sequences_codec);
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            Choose = input.ReadUInt32();
            break;
          }
          case 18:
          case 16: {
            sequences_.AddEntriesFrom(input, _repeated_sequences_codec);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// bonus game数据
  /// </summary>
  public sealed class WarriorKingBonusGameData : pb::IMessage {
    private static readonly pb::MessageParser<WarriorKingBonusGameData> _parser = new pb::MessageParser<WarriorKingBonusGameData>(() => new WarriorKingBonusGameData());
    public static pb::MessageParser<WarriorKingBonusGameData> Parser { get { return _parser; } }

    private ulong bet_;
    /// <summary>
    /// 中bonus game时的bet参数
    /// </summary>
    public ulong Bet {
      get { return bet_; }
      set {
        bet_ = value;
      }
    }

    private static readonly pb::FieldCodec<global::DragonU3DSDK.Network.API.ILProtocol.WarriorKingBonusGameLayer> _repeated_layers_codec
        = pb::FieldCodec.ForMessage(18, global::DragonU3DSDK.Network.API.ILProtocol.WarriorKingBonusGameLayer.Parser);
    private readonly pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.WarriorKingBonusGameLayer> layers_ = new pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.WarriorKingBonusGameLayer>();
    /// <summary>
    /// 每一层的信息
    /// </summary>
    public pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.WarriorKingBonusGameLayer> Layers {
      get { return layers_; }
    }

    private uint multiple_;
    /// <summary>
    /// 当前倍数
    /// </summary>
    public uint Multiple {
      get { return multiple_; }
      set {
        multiple_ = value;
      }
    }

    private uint base_;
    /// <summary>
    /// 当前基数
    /// </summary>
    public uint Base {
      get { return base_; }
      set {
        base_ = value;
      }
    }

    private bool isEnd_;
    /// <summary>
    /// 是否已结束
    /// </summary>
    public bool IsEnd {
      get { return isEnd_; }
      set {
        isEnd_ = value;
      }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (Bet != 0UL) {
        output.WriteRawTag(8);
        output.WriteUInt64(Bet);
      }
      layers_.WriteTo(output, _repeated_layers_codec);
      if (Multiple != 0) {
        output.WriteRawTag(24);
        output.WriteUInt32(Multiple);
      }
      if (Base != 0) {
        output.WriteRawTag(32);
        output.WriteUInt32(Base);
      }
      if (IsEnd != false) {
        output.WriteRawTag(40);
        output.WriteBool(IsEnd);
      }
    }

    public int CalculateSize() {
      int size = 0;
      if (Bet != 0UL) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(Bet);
      }
      size += layers_.CalculateSize(_repeated_layers_codec);
      if (Multiple != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Multiple);
      }
      if (Base != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Base);
      }
      if (IsEnd != false) {
        size += 1 + 1;
      }
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            Bet = input.ReadUInt64();
            break;
          }
          case 18: {
            layers_.AddEntriesFrom(input, _repeated_layers_codec);
            break;
          }
          case 24: {
            Multiple = input.ReadUInt32();
            break;
          }
          case 32: {
            Base = input.ReadUInt32();
            break;
          }
          case 40: {
            IsEnd = input.ReadBool();
            break;
          }
        }
      }
    }

  }

  public sealed class WarriorKingFreeGameChoice : pb::IMessage {
    private static readonly pb::MessageParser<WarriorKingFreeGameChoice> _parser = new pb::MessageParser<WarriorKingFreeGameChoice>(() => new WarriorKingFreeGameChoice());
    public static pb::MessageParser<WarriorKingFreeGameChoice> Parser { get { return _parser; } }

    private uint mainType_;
    public uint MainType {
      get { return mainType_; }
      set {
        mainType_ = value;
      }
    }

    private uint subType_;
    public uint SubType {
      get { return subType_; }
      set {
        subType_ = value;
      }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (MainType != 0) {
        output.WriteRawTag(8);
        output.WriteUInt32(MainType);
      }
      if (SubType != 0) {
        output.WriteRawTag(16);
        output.WriteUInt32(SubType);
      }
    }

    public int CalculateSize() {
      int size = 0;
      if (MainType != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(MainType);
      }
      if (SubType != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(SubType);
      }
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            MainType = input.ReadUInt32();
            break;
          }
          case 16: {
            SubType = input.ReadUInt32();
            break;
          }
        }
      }
    }

  }

  public sealed class WarriorKingSymbolReplace : pb::IMessage {
    private static readonly pb::MessageParser<WarriorKingSymbolReplace> _parser = new pb::MessageParser<WarriorKingSymbolReplace>(() => new WarriorKingSymbolReplace());
    public static pb::MessageParser<WarriorKingSymbolReplace> Parser { get { return _parser; } }

    private uint from_;
    /// <summary>
    /// 原始图标id
    /// </summary>
    public uint From {
      get { return from_; }
      set {
        from_ = value;
      }
    }

    private uint to_;
    /// <summary>
    /// 替换后的图标id
    /// </summary>
    public uint To {
      get { return to_; }
      set {
        to_ = value;
      }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (From != 0) {
        output.WriteRawTag(8);
        output.WriteUInt32(From);
      }
      if (To != 0) {
        output.WriteRawTag(16);
        output.WriteUInt32(To);
      }
    }

    public int CalculateSize() {
      int size = 0;
      if (From != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(From);
      }
      if (To != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(To);
      }
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            From = input.ReadUInt32();
            break;
          }
          case 16: {
            To = input.ReadUInt32();
            break;
          }
        }
      }
    }

  }

  public sealed class WarriorKingFreeGameEnterChoice : pb::IMessage {
    private static readonly pb::MessageParser<WarriorKingFreeGameEnterChoice> _parser = new pb::MessageParser<WarriorKingFreeGameEnterChoice>(() => new WarriorKingFreeGameEnterChoice());
    public static pb::MessageParser<WarriorKingFreeGameEnterChoice> Parser { get { return _parser; } }

    private uint freeSpinCount_;
    /// <summary>
    /// 免费游戏次数
    /// </summary>
    public uint FreeSpinCount {
      get { return freeSpinCount_; }
      set {
        freeSpinCount_ = value;
      }
    }

    private ulong itemCount_;
    /// <summary>
    /// 奖励代币的数量
    /// </summary>
    public ulong ItemCount {
      get { return itemCount_; }
      set {
        itemCount_ = value;
      }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (FreeSpinCount != 0) {
        output.WriteRawTag(8);
        output.WriteUInt32(FreeSpinCount);
      }
      if (ItemCount != 0UL) {
        output.WriteRawTag(16);
        output.WriteUInt64(ItemCount);
      }
    }

    public int CalculateSize() {
      int size = 0;
      if (FreeSpinCount != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(FreeSpinCount);
      }
      if (ItemCount != 0UL) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(ItemCount);
      }
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            FreeSpinCount = input.ReadUInt32();
            break;
          }
          case 16: {
            ItemCount = input.ReadUInt64();
            break;
          }
        }
      }
    }

  }

  public sealed class WarriorKingGameResultExtraInfo : pb::IMessage {
    private static readonly pb::MessageParser<WarriorKingGameResultExtraInfo> _parser = new pb::MessageParser<WarriorKingGameResultExtraInfo>(() => new WarriorKingGameResultExtraInfo());
    public static pb::MessageParser<WarriorKingGameResultExtraInfo> Parser { get { return _parser; } }

    private static readonly pb::FieldCodec<uint> _repeated_stickyWild_codec
        = pb::FieldCodec.ForUInt32(10);
    private readonly pbc::RepeatedField<uint> stickyWild_ = new pbc::RepeatedField<uint>();
    /// <summary>
    /// free game里面的sticky wilds
    /// </summary>
    public pbc::RepeatedField<uint> StickyWild {
      get { return stickyWild_; }
    }

    private global::DragonU3DSDK.Network.API.ILProtocol.WarriorKingItemData itemData_;
    /// <summary>
    /// item数据
    /// </summary>
    public global::DragonU3DSDK.Network.API.ILProtocol.WarriorKingItemData ItemData {
      get { return itemData_; }
      set {
        itemData_ = value;
      }
    }

    private static readonly pbc::MapField<uint, global::DragonU3DSDK.Network.API.ILProtocol.WarriorKingRoleData>.Codec _map_roles_codec
        = new pbc::MapField<uint, global::DragonU3DSDK.Network.API.ILProtocol.WarriorKingRoleData>.Codec(pb::FieldCodec.ForUInt32(8), pb::FieldCodec.ForMessage(18, global::DragonU3DSDK.Network.API.ILProtocol.WarriorKingRoleData.Parser), 26);
    private readonly pbc::MapField<uint, global::DragonU3DSDK.Network.API.ILProtocol.WarriorKingRoleData> roles_ = new pbc::MapField<uint, global::DragonU3DSDK.Network.API.ILProtocol.WarriorKingRoleData>();
    /// <summary>
    /// 角色列表
    /// </summary>
    public pbc::MapField<uint, global::DragonU3DSDK.Network.API.ILProtocol.WarriorKingRoleData> Roles {
      get { return roles_; }
    }

    private uint currentRole_;
    /// <summary>
    /// 当前使用的角色id
    /// </summary>
    public uint CurrentRole {
      get { return currentRole_; }
      set {
        currentRole_ = value;
      }
    }

    private static readonly pb::FieldCodec<global::DragonU3DSDK.Network.API.ILProtocol.WarriorKingFreeGameChoice> _repeated_freeChoices_codec
        = pb::FieldCodec.ForMessage(42, global::DragonU3DSDK.Network.API.ILProtocol.WarriorKingFreeGameChoice.Parser);
    private readonly pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.WarriorKingFreeGameChoice> freeChoices_ = new pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.WarriorKingFreeGameChoice>();
    /// <summary>
    /// 武士选项列表
    /// </summary>
    public pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.WarriorKingFreeGameChoice> FreeChoices {
      get { return freeChoices_; }
    }

    private global::DragonU3DSDK.Network.API.ILProtocol.WarriorKingBonusGameData bonusData_;
    /// <summary>
    /// bonus game 数据
    /// </summary>
    public global::DragonU3DSDK.Network.API.ILProtocol.WarriorKingBonusGameData BonusData {
      get { return bonusData_; }
      set {
        bonusData_ = value;
      }
    }

    private bool isAvgBet_;
    /// <summary>
    /// 是否使用avgBet，比如角色升级中freeGame时
    /// </summary>
    public bool IsAvgBet {
      get { return isAvgBet_; }
      set {
        isAvgBet_ = value;
      }
    }

    private static readonly pb::FieldCodec<global::DragonU3DSDK.Network.API.ILProtocol.WarriorKingSymbolReplace> _repeated_symbolReplace_codec
        = pb::FieldCodec.ForMessage(66, global::DragonU3DSDK.Network.API.ILProtocol.WarriorKingSymbolReplace.Parser);
    private readonly pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.WarriorKingSymbolReplace> symbolReplace_ = new pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.WarriorKingSymbolReplace>();
    /// <summary>
    /// 卷轴图标替换
    /// </summary>
    public pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.WarriorKingSymbolReplace> SymbolReplace {
      get { return symbolReplace_; }
    }

    private static readonly pb::FieldCodec<global::DragonU3DSDK.Network.API.ILProtocol.WarriorKingFreeGameEnterChoice> _repeated_enterChoices_codec
        = pb::FieldCodec.ForMessage(74, global::DragonU3DSDK.Network.API.ILProtocol.WarriorKingFreeGameEnterChoice.Parser);
    private readonly pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.WarriorKingFreeGameEnterChoice> enterChoices_ = new pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.WarriorKingFreeGameEnterChoice>();
    /// <summary>
    /// 进入免费游戏时的选项列表
    /// </summary>
    public pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.WarriorKingFreeGameEnterChoice> EnterChoices {
      get { return enterChoices_; }
    }

    private uint levelUpWinRate_;
    /// <summary>
    /// 升级加钱
    /// </summary>
    public uint LevelUpWinRate {
      get { return levelUpWinRate_; }
      set {
        levelUpWinRate_ = value;
      }
    }

    private uint wildReelsCount_;
    /// <summary>
    /// full wild 个数
    /// </summary>
    public uint WildReelsCount {
      get { return wildReelsCount_; }
      set {
        wildReelsCount_ = value;
      }
    }

    private uint symbolPeachCount_;
    /// <summary>
    /// 桃子图标获得的桃子数
    /// </summary>
    public uint SymbolPeachCount {
      get { return symbolPeachCount_; }
      set {
        symbolPeachCount_ = value;
      }
    }

    private uint freeGameChoosePeachCount_;
    /// <summary>
    /// 免费游戏选择时获得的桃子数
    /// </summary>
    public uint FreeGameChoosePeachCount {
      get { return freeGameChoosePeachCount_; }
      set {
        freeGameChoosePeachCount_ = value;
      }
    }

    private ulong roleLevelUpWin_;
    /// <summary>
    /// 角色升级时获得的金币
    /// </summary>
    public ulong RoleLevelUpWin {
      get { return roleLevelUpWin_; }
      set {
        roleLevelUpWin_ = value;
      }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      stickyWild_.WriteTo(output, _repeated_stickyWild_codec);
      if (itemData_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(ItemData);
      }
      roles_.WriteTo(output, _map_roles_codec);
      if (CurrentRole != 0) {
        output.WriteRawTag(32);
        output.WriteUInt32(CurrentRole);
      }
      freeChoices_.WriteTo(output, _repeated_freeChoices_codec);
      if (bonusData_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(BonusData);
      }
      if (IsAvgBet != false) {
        output.WriteRawTag(56);
        output.WriteBool(IsAvgBet);
      }
      symbolReplace_.WriteTo(output, _repeated_symbolReplace_codec);
      enterChoices_.WriteTo(output, _repeated_enterChoices_codec);
      if (LevelUpWinRate != 0) {
        output.WriteRawTag(80);
        output.WriteUInt32(LevelUpWinRate);
      }
      if (WildReelsCount != 0) {
        output.WriteRawTag(88);
        output.WriteUInt32(WildReelsCount);
      }
      if (SymbolPeachCount != 0) {
        output.WriteRawTag(96);
        output.WriteUInt32(SymbolPeachCount);
      }
      if (FreeGameChoosePeachCount != 0) {
        output.WriteRawTag(104);
        output.WriteUInt32(FreeGameChoosePeachCount);
      }
      if (RoleLevelUpWin != 0UL) {
        output.WriteRawTag(112);
        output.WriteUInt64(RoleLevelUpWin);
      }
    }

    public int CalculateSize() {
      int size = 0;
      size += stickyWild_.CalculateSize(_repeated_stickyWild_codec);
      if (itemData_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ItemData);
      }
      size += roles_.CalculateSize(_map_roles_codec);
      if (CurrentRole != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(CurrentRole);
      }
      size += freeChoices_.CalculateSize(_repeated_freeChoices_codec);
      if (bonusData_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(BonusData);
      }
      if (IsAvgBet != false) {
        size += 1 + 1;
      }
      size += symbolReplace_.CalculateSize(_repeated_symbolReplace_codec);
      size += enterChoices_.CalculateSize(_repeated_enterChoices_codec);
      if (LevelUpWinRate != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(LevelUpWinRate);
      }
      if (WildReelsCount != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(WildReelsCount);
      }
      if (SymbolPeachCount != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(SymbolPeachCount);
      }
      if (FreeGameChoosePeachCount != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(FreeGameChoosePeachCount);
      }
      if (RoleLevelUpWin != 0UL) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(RoleLevelUpWin);
      }
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10:
          case 8: {
            stickyWild_.AddEntriesFrom(input, _repeated_stickyWild_codec);
            break;
          }
          case 18: {
            if (itemData_ == null) {
              itemData_ = new global::DragonU3DSDK.Network.API.ILProtocol.WarriorKingItemData();
            }
            input.ReadMessage(itemData_);
            break;
          }
          case 26: {
            roles_.AddEntriesFrom(input, _map_roles_codec);
            break;
          }
          case 32: {
            CurrentRole = input.ReadUInt32();
            break;
          }
          case 42: {
            freeChoices_.AddEntriesFrom(input, _repeated_freeChoices_codec);
            break;
          }
          case 50: {
            if (bonusData_ == null) {
              bonusData_ = new global::DragonU3DSDK.Network.API.ILProtocol.WarriorKingBonusGameData();
            }
            input.ReadMessage(bonusData_);
            break;
          }
          case 56: {
            IsAvgBet = input.ReadBool();
            break;
          }
          case 66: {
            symbolReplace_.AddEntriesFrom(input, _repeated_symbolReplace_codec);
            break;
          }
          case 74: {
            enterChoices_.AddEntriesFrom(input, _repeated_enterChoices_codec);
            break;
          }
          case 80: {
            LevelUpWinRate = input.ReadUInt32();
            break;
          }
          case 88: {
            WildReelsCount = input.ReadUInt32();
            break;
          }
          case 96: {
            SymbolPeachCount = input.ReadUInt32();
            break;
          }
          case 104: {
            FreeGameChoosePeachCount = input.ReadUInt32();
            break;
          }
          case 112: {
            RoleLevelUpWin = input.ReadUInt64();
            break;
          }
        }
      }
    }

  }

  public sealed class WarriorKingBonusGameRequest : pb::IMessage {
    private static readonly pb::MessageParser<WarriorKingBonusGameRequest> _parser = new pb::MessageParser<WarriorKingBonusGameRequest>(() => new WarriorKingBonusGameRequest());
    public static pb::MessageParser<WarriorKingBonusGameRequest> Parser { get { return _parser; } }

    private uint actionType_;
    /// <summary>
    /// 操作类型，参考WarriorKingActionType
    /// </summary>
    public uint ActionType {
      get { return actionType_; }
      set {
        actionType_ = value;
      }
    }

    private uint choose_;
    /// <summary>
    /// 玩家选择的索引，从0开始
    /// </summary>
    public uint Choose {
      get { return choose_; }
      set {
        choose_ = value;
      }
    }

    private uint layer_;
    /// <summary>
    /// bonus game层数， 0～4
    /// </summary>
    public uint Layer {
      get { return layer_; }
      set {
        layer_ = value;
      }
    }

    private uint roleId_;
    /// <summary>
    /// 要升级的角色id
    /// </summary>
    public uint RoleId {
      get { return roleId_; }
      set {
        roleId_ = value;
      }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (ActionType != 0) {
        output.WriteRawTag(8);
        output.WriteUInt32(ActionType);
      }
      if (Choose != 0) {
        output.WriteRawTag(16);
        output.WriteUInt32(Choose);
      }
      if (Layer != 0) {
        output.WriteRawTag(24);
        output.WriteUInt32(Layer);
      }
      if (RoleId != 0) {
        output.WriteRawTag(32);
        output.WriteUInt32(RoleId);
      }
    }

    public int CalculateSize() {
      int size = 0;
      if (ActionType != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(ActionType);
      }
      if (Choose != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Choose);
      }
      if (Layer != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Layer);
      }
      if (RoleId != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(RoleId);
      }
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            ActionType = input.ReadUInt32();
            break;
          }
          case 16: {
            Choose = input.ReadUInt32();
            break;
          }
          case 24: {
            Layer = input.ReadUInt32();
            break;
          }
          case 32: {
            RoleId = input.ReadUInt32();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///================= 1008: CelestialRoar ====================================
  /// </summary>
  public sealed class CelestialRoarBetData : pb::IMessage {
    private static readonly pb::MessageParser<CelestialRoarBetData> _parser = new pb::MessageParser<CelestialRoarBetData>(() => new CelestialRoarBetData());
    public static pb::MessageParser<CelestialRoarBetData> Parser { get { return _parser; } }

    private static readonly pb::FieldCodec<uint> _repeated_heights_codec
        = pb::FieldCodec.ForUInt32(10);
    private readonly pbc::RepeatedField<uint> heights_ = new pbc::RepeatedField<uint>();
    /// <summary>
    /// 2,3,4列的高度，对应下标0，1，2
    /// </summary>
    public pbc::RepeatedField<uint> Heights {
      get { return heights_; }
    }

    private uint spinCount_;
    /// <summary>
    /// 2,3,4列剩余的spin次数
    /// </summary>
    public uint SpinCount {
      get { return spinCount_; }
      set {
        spinCount_ = value;
      }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      heights_.WriteTo(output, _repeated_heights_codec);
      if (SpinCount != 0) {
        output.WriteRawTag(16);
        output.WriteUInt32(SpinCount);
      }
    }

    public int CalculateSize() {
      int size = 0;
      size += heights_.CalculateSize(_repeated_heights_codec);
      if (SpinCount != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(SpinCount);
      }
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10:
          case 8: {
            heights_.AddEntriesFrom(input, _repeated_heights_codec);
            break;
          }
          case 16: {
            SpinCount = input.ReadUInt32();
            break;
          }
        }
      }
    }

  }

  public sealed class CelestialRoarFrenzyData : pb::IMessage {
    private static readonly pb::MessageParser<CelestialRoarFrenzyData> _parser = new pb::MessageParser<CelestialRoarFrenzyData>(() => new CelestialRoarFrenzyData());
    public static pb::MessageParser<CelestialRoarFrenzyData> Parser { get { return _parser; } }

    private ulong bet_;
    /// <summary>
    /// 中frenzy时的bet
    /// </summary>
    public ulong Bet {
      get { return bet_; }
      set {
        bet_ = value;
      }
    }

    private uint spinCount_;
    /// <summary>
    /// 剩余次数
    /// </summary>
    public uint SpinCount {
      get { return spinCount_; }
      set {
        spinCount_ = value;
      }
    }

    private uint totalSpinCount_;
    /// <summary>
    /// 总的次数
    /// </summary>
    public uint TotalSpinCount {
      get { return totalSpinCount_; }
      set {
        totalSpinCount_ = value;
      }
    }

    private ulong totalWin_;
    /// <summary>
    /// 本次frenzy mode总的赢钱数
    /// </summary>
    public ulong TotalWin {
      get { return totalWin_; }
      set {
        totalWin_ = value;
      }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (Bet != 0UL) {
        output.WriteRawTag(8);
        output.WriteUInt64(Bet);
      }
      if (SpinCount != 0) {
        output.WriteRawTag(16);
        output.WriteUInt32(SpinCount);
      }
      if (TotalSpinCount != 0) {
        output.WriteRawTag(24);
        output.WriteUInt32(TotalSpinCount);
      }
      if (TotalWin != 0UL) {
        output.WriteRawTag(32);
        output.WriteUInt64(TotalWin);
      }
    }

    public int CalculateSize() {
      int size = 0;
      if (Bet != 0UL) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(Bet);
      }
      if (SpinCount != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(SpinCount);
      }
      if (TotalSpinCount != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(TotalSpinCount);
      }
      if (TotalWin != 0UL) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(TotalWin);
      }
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            Bet = input.ReadUInt64();
            break;
          }
          case 16: {
            SpinCount = input.ReadUInt32();
            break;
          }
          case 24: {
            TotalSpinCount = input.ReadUInt32();
            break;
          }
          case 32: {
            TotalWin = input.ReadUInt64();
            break;
          }
        }
      }
    }

  }

  public sealed class CelestialRoarWildExpandElement : pb::IMessage {
    private static readonly pb::MessageParser<CelestialRoarWildExpandElement> _parser = new pb::MessageParser<CelestialRoarWildExpandElement>(() => new CelestialRoarWildExpandElement());
    public static pb::MessageParser<CelestialRoarWildExpandElement> Parser { get { return _parser; } }

    private uint from_;
    /// <summary>
    /// 替换后起始位置
    /// </summary>
    public uint From {
      get { return from_; }
      set {
        from_ = value;
      }
    }

    private uint to_;
    /// <summary>
    /// 替换后结束位置
    /// </summary>
    public uint To {
      get { return to_; }
      set {
        to_ = value;
      }
    }

    private uint origin_;
    /// <summary>
    /// 图标原始位置
    /// </summary>
    public uint Origin {
      get { return origin_; }
      set {
        origin_ = value;
      }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (From != 0) {
        output.WriteRawTag(8);
        output.WriteUInt32(From);
      }
      if (To != 0) {
        output.WriteRawTag(16);
        output.WriteUInt32(To);
      }
      if (Origin != 0) {
        output.WriteRawTag(24);
        output.WriteUInt32(Origin);
      }
    }

    public int CalculateSize() {
      int size = 0;
      if (From != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(From);
      }
      if (To != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(To);
      }
      if (Origin != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Origin);
      }
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            From = input.ReadUInt32();
            break;
          }
          case 16: {
            To = input.ReadUInt32();
            break;
          }
          case 24: {
            Origin = input.ReadUInt32();
            break;
          }
        }
      }
    }

  }

  public sealed class CelestialRoarWildExpand : pb::IMessage {
    private static readonly pb::MessageParser<CelestialRoarWildExpand> _parser = new pb::MessageParser<CelestialRoarWildExpand>(() => new CelestialRoarWildExpand());
    public static pb::MessageParser<CelestialRoarWildExpand> Parser { get { return _parser; } }

    private static readonly pb::FieldCodec<global::DragonU3DSDK.Network.API.ILProtocol.CelestialRoarWildExpandElement> _repeated_elements_codec
        = pb::FieldCodec.ForMessage(10, global::DragonU3DSDK.Network.API.ILProtocol.CelestialRoarWildExpandElement.Parser);
    private readonly pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.CelestialRoarWildExpandElement> elements_ = new pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.CelestialRoarWildExpandElement>();
    public pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.CelestialRoarWildExpandElement> Elements {
      get { return elements_; }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      elements_.WriteTo(output, _repeated_elements_codec);
    }

    public int CalculateSize() {
      int size = 0;
      size += elements_.CalculateSize(_repeated_elements_codec);
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            elements_.AddEntriesFrom(input, _repeated_elements_codec);
            break;
          }
        }
      }
    }

  }

  public sealed class CelestialRoarGameResultExtraInfo : pb::IMessage {
    private static readonly pb::MessageParser<CelestialRoarGameResultExtraInfo> _parser = new pb::MessageParser<CelestialRoarGameResultExtraInfo>(() => new CelestialRoarGameResultExtraInfo());
    public static pb::MessageParser<CelestialRoarGameResultExtraInfo> Parser { get { return _parser; } }

    private bool hasUnlockSlot_;
    /// <summary>
    /// 本次spin是否有解锁格子，可能是图标解锁，也可能是随机解锁
    /// </summary>
    public bool HasUnlockSlot {
      get { return hasUnlockSlot_; }
      set {
        hasUnlockSlot_ = value;
      }
    }

    private static readonly pb::FieldCodec<global::DragonU3DSDK.Network.API.ILProtocol.CelestialRoarWildExpand> _repeated_wildExpand_codec
        = pb::FieldCodec.ForMessage(18, global::DragonU3DSDK.Network.API.ILProtocol.CelestialRoarWildExpand.Parser);
    private readonly pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.CelestialRoarWildExpand> wildExpand_ = new pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.CelestialRoarWildExpand>();
    /// <summary>
    /// wild图标扩展
    /// </summary>
    public pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.CelestialRoarWildExpand> WildExpand {
      get { return wildExpand_; }
    }

    private static readonly pbc::MapField<ulong, global::DragonU3DSDK.Network.API.ILProtocol.CelestialRoarBetData>.Codec _map_betData_codec
        = new pbc::MapField<ulong, global::DragonU3DSDK.Network.API.ILProtocol.CelestialRoarBetData>.Codec(pb::FieldCodec.ForUInt64(8), pb::FieldCodec.ForMessage(18, global::DragonU3DSDK.Network.API.ILProtocol.CelestialRoarBetData.Parser), 26);
    private readonly pbc::MapField<ulong, global::DragonU3DSDK.Network.API.ILProtocol.CelestialRoarBetData> betData_ = new pbc::MapField<ulong, global::DragonU3DSDK.Network.API.ILProtocol.CelestialRoarBetData>();
    public pbc::MapField<ulong, global::DragonU3DSDK.Network.API.ILProtocol.CelestialRoarBetData> BetData {
      get { return betData_; }
    }

    private global::DragonU3DSDK.Network.API.ILProtocol.CelestialRoarFrenzyData frenzyData_;
    public global::DragonU3DSDK.Network.API.ILProtocol.CelestialRoarFrenzyData FrenzyData {
      get { return frenzyData_; }
      set {
        frenzyData_ = value;
      }
    }

    private bool hasRandomUnlock_;
    /// <summary>
    /// 是否有随机开格子
    /// </summary>
    public bool HasRandomUnlock {
      get { return hasRandomUnlock_; }
      set {
        hasRandomUnlock_ = value;
      }
    }

    private bool triggerFrenzyMode_;
    /// <summary>
    /// 是否触发狂暴模式
    /// </summary>
    public bool TriggerFrenzyMode {
      get { return triggerFrenzyMode_; }
      set {
        triggerFrenzyMode_ = value;
      }
    }

    private uint unlockSlotCount_;
    /// <summary>
    /// 本次spin开启的格子数
    /// </summary>
    public uint UnlockSlotCount {
      get { return unlockSlotCount_; }
      set {
        unlockSlotCount_ = value;
      }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (HasUnlockSlot != false) {
        output.WriteRawTag(8);
        output.WriteBool(HasUnlockSlot);
      }
      wildExpand_.WriteTo(output, _repeated_wildExpand_codec);
      betData_.WriteTo(output, _map_betData_codec);
      if (frenzyData_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(FrenzyData);
      }
      if (HasRandomUnlock != false) {
        output.WriteRawTag(40);
        output.WriteBool(HasRandomUnlock);
      }
      if (TriggerFrenzyMode != false) {
        output.WriteRawTag(48);
        output.WriteBool(TriggerFrenzyMode);
      }
      if (UnlockSlotCount != 0) {
        output.WriteRawTag(56);
        output.WriteUInt32(UnlockSlotCount);
      }
    }

    public int CalculateSize() {
      int size = 0;
      if (HasUnlockSlot != false) {
        size += 1 + 1;
      }
      size += wildExpand_.CalculateSize(_repeated_wildExpand_codec);
      size += betData_.CalculateSize(_map_betData_codec);
      if (frenzyData_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(FrenzyData);
      }
      if (HasRandomUnlock != false) {
        size += 1 + 1;
      }
      if (TriggerFrenzyMode != false) {
        size += 1 + 1;
      }
      if (UnlockSlotCount != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(UnlockSlotCount);
      }
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            HasUnlockSlot = input.ReadBool();
            break;
          }
          case 18: {
            wildExpand_.AddEntriesFrom(input, _repeated_wildExpand_codec);
            break;
          }
          case 26: {
            betData_.AddEntriesFrom(input, _map_betData_codec);
            break;
          }
          case 34: {
            if (frenzyData_ == null) {
              frenzyData_ = new global::DragonU3DSDK.Network.API.ILProtocol.CelestialRoarFrenzyData();
            }
            input.ReadMessage(frenzyData_);
            break;
          }
          case 40: {
            HasRandomUnlock = input.ReadBool();
            break;
          }
          case 48: {
            TriggerFrenzyMode = input.ReadBool();
            break;
          }
          case 56: {
            UnlockSlotCount = input.ReadUInt32();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///================= 1009: MermaidPearls ====================================
  /// </summary>
  public sealed class MermaidPearlsGameResultExtraInfo : pb::IMessage {
    private static readonly pb::MessageParser<MermaidPearlsGameResultExtraInfo> _parser = new pb::MessageParser<MermaidPearlsGameResultExtraInfo>(() => new MermaidPearlsGameResultExtraInfo());
    public static pb::MessageParser<MermaidPearlsGameResultExtraInfo> Parser { get { return _parser; } }

    private static readonly pbc::MapField<ulong, global::DragonU3DSDK.Network.API.ILProtocol.MermaidPearlsGameResultExtraInfo.Types.ReSpinSlot>.Codec _map_pearlSlots_codec
        = new pbc::MapField<ulong, global::DragonU3DSDK.Network.API.ILProtocol.MermaidPearlsGameResultExtraInfo.Types.ReSpinSlot>.Codec(pb::FieldCodec.ForUInt64(8), pb::FieldCodec.ForMessage(18, global::DragonU3DSDK.Network.API.ILProtocol.MermaidPearlsGameResultExtraInfo.Types.ReSpinSlot.Parser), 10);
    private readonly pbc::MapField<ulong, global::DragonU3DSDK.Network.API.ILProtocol.MermaidPearlsGameResultExtraInfo.Types.ReSpinSlot> pearlSlots_ = new pbc::MapField<ulong, global::DragonU3DSDK.Network.API.ILProtocol.MermaidPearlsGameResultExtraInfo.Types.ReSpinSlot>();
    /// <summary>
    /// 普通游戏中的珍珠图标
    /// </summary>
    public pbc::MapField<ulong, global::DragonU3DSDK.Network.API.ILProtocol.MermaidPearlsGameResultExtraInfo.Types.ReSpinSlot> PearlSlots {
      get { return pearlSlots_; }
    }

    private static readonly pbc::MapField<ulong, global::DragonU3DSDK.Network.API.ILProtocol.MermaidPearlsGameResultExtraInfo.Types.ReSpinSlot>.Codec _map_reSpinPanel_codec
        = new pbc::MapField<ulong, global::DragonU3DSDK.Network.API.ILProtocol.MermaidPearlsGameResultExtraInfo.Types.ReSpinSlot>.Codec(pb::FieldCodec.ForUInt64(8), pb::FieldCodec.ForMessage(18, global::DragonU3DSDK.Network.API.ILProtocol.MermaidPearlsGameResultExtraInfo.Types.ReSpinSlot.Parser), 18);
    private readonly pbc::MapField<ulong, global::DragonU3DSDK.Network.API.ILProtocol.MermaidPearlsGameResultExtraInfo.Types.ReSpinSlot> reSpinPanel_ = new pbc::MapField<ulong, global::DragonU3DSDK.Network.API.ILProtocol.MermaidPearlsGameResultExtraInfo.Types.ReSpinSlot>();
    /// <summary>
    /// reSpin面板信息
    /// </summary>
    public pbc::MapField<ulong, global::DragonU3DSDK.Network.API.ILProtocol.MermaidPearlsGameResultExtraInfo.Types.ReSpinSlot> ReSpinPanel {
      get { return reSpinPanel_; }
    }

    private uint reSpinSymbolCount_;
    /// <summary>
    /// 当前reSpin图标数量
    /// </summary>
    public uint ReSpinSymbolCount {
      get { return reSpinSymbolCount_; }
      set {
        reSpinSymbolCount_ = value;
      }
    }

    private uint unlockRow_;
    /// <summary>
    /// 当前已经解锁行数
    /// </summary>
    public uint UnlockRow {
      get { return unlockRow_; }
      set {
        unlockRow_ = value;
      }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      pearlSlots_.WriteTo(output, _map_pearlSlots_codec);
      reSpinPanel_.WriteTo(output, _map_reSpinPanel_codec);
      if (ReSpinSymbolCount != 0) {
        output.WriteRawTag(24);
        output.WriteUInt32(ReSpinSymbolCount);
      }
      if (UnlockRow != 0) {
        output.WriteRawTag(32);
        output.WriteUInt32(UnlockRow);
      }
    }

    public int CalculateSize() {
      int size = 0;
      size += pearlSlots_.CalculateSize(_map_pearlSlots_codec);
      size += reSpinPanel_.CalculateSize(_map_reSpinPanel_codec);
      if (ReSpinSymbolCount != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(ReSpinSymbolCount);
      }
      if (UnlockRow != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(UnlockRow);
      }
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            pearlSlots_.AddEntriesFrom(input, _map_pearlSlots_codec);
            break;
          }
          case 18: {
            reSpinPanel_.AddEntriesFrom(input, _map_reSpinPanel_codec);
            break;
          }
          case 24: {
            ReSpinSymbolCount = input.ReadUInt32();
            break;
          }
          case 32: {
            UnlockRow = input.ReadUInt32();
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the MermaidPearlsGameResultExtraInfo message type.</summary>
    public static class Types {
      public sealed class ReSpinSlot : pb::IMessage {
        private static readonly pb::MessageParser<ReSpinSlot> _parser = new pb::MessageParser<ReSpinSlot>(() => new ReSpinSlot());
        public static pb::MessageParser<ReSpinSlot> Parser { get { return _parser; } }

        private uint symbolId_;
        public uint SymbolId {
          get { return symbolId_; }
          set {
            symbolId_ = value;
          }
        }

        private uint winRate_;
        public uint WinRate {
          get { return winRate_; }
          set {
            winRate_ = value;
          }
        }

        private uint jackpotId_;
        public uint JackpotId {
          get { return jackpotId_; }
          set {
            jackpotId_ = value;
          }
        }

        public void WriteTo(pb::CodedOutputStream output) {
          if (SymbolId != 0) {
            output.WriteRawTag(8);
            output.WriteUInt32(SymbolId);
          }
          if (WinRate != 0) {
            output.WriteRawTag(16);
            output.WriteUInt32(WinRate);
          }
          if (JackpotId != 0) {
            output.WriteRawTag(24);
            output.WriteUInt32(JackpotId);
          }
        }

        public int CalculateSize() {
          int size = 0;
          if (SymbolId != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(SymbolId);
          }
          if (WinRate != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(WinRate);
          }
          if (JackpotId != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(JackpotId);
          }
          return size;
        }

        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                input.SkipLastField();
                break;
              case 8: {
                SymbolId = input.ReadUInt32();
                break;
              }
              case 16: {
                WinRate = input.ReadUInt32();
                break;
              }
              case 24: {
                JackpotId = input.ReadUInt32();
                break;
              }
            }
          }
        }

      }

    }
    #endregion

  }

  /// <summary>
  /// 配置扩展数据
  /// </summary>
  public sealed class PoseidonGameConfigExtraInfo : pb::IMessage {
    private static readonly pb::MessageParser<PoseidonGameConfigExtraInfo> _parser = new pb::MessageParser<PoseidonGameConfigExtraInfo>(() => new PoseidonGameConfigExtraInfo());
    public static pb::MessageParser<PoseidonGameConfigExtraInfo> Parser { get { return _parser; } }

    private static readonly pbc::MapField<uint, global::DragonU3DSDK.Network.API.ILProtocol.PoseidonGameConfigExtraInfo.Types.JackpotWheelConfig>.Codec _map_jackpotWheels_codec
        = new pbc::MapField<uint, global::DragonU3DSDK.Network.API.ILProtocol.PoseidonGameConfigExtraInfo.Types.JackpotWheelConfig>.Codec(pb::FieldCodec.ForUInt32(8), pb::FieldCodec.ForMessage(18, global::DragonU3DSDK.Network.API.ILProtocol.PoseidonGameConfigExtraInfo.Types.JackpotWheelConfig.Parser), 10);
    private readonly pbc::MapField<uint, global::DragonU3DSDK.Network.API.ILProtocol.PoseidonGameConfigExtraInfo.Types.JackpotWheelConfig> jackpotWheels_ = new pbc::MapField<uint, global::DragonU3DSDK.Network.API.ILProtocol.PoseidonGameConfigExtraInfo.Types.JackpotWheelConfig>();
    public pbc::MapField<uint, global::DragonU3DSDK.Network.API.ILProtocol.PoseidonGameConfigExtraInfo.Types.JackpotWheelConfig> JackpotWheels {
      get { return jackpotWheels_; }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      jackpotWheels_.WriteTo(output, _map_jackpotWheels_codec);
    }

    public int CalculateSize() {
      int size = 0;
      size += jackpotWheels_.CalculateSize(_map_jackpotWheels_codec);
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            jackpotWheels_.AddEntriesFrom(input, _map_jackpotWheels_codec);
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the PoseidonGameConfigExtraInfo message type.</summary>
    public static class Types {
      public sealed class JackpotWheelNode : pb::IMessage {
        private static readonly pb::MessageParser<JackpotWheelNode> _parser = new pb::MessageParser<JackpotWheelNode>(() => new JackpotWheelNode());
        public static pb::MessageParser<JackpotWheelNode> Parser { get { return _parser; } }

        private uint id_;
        public uint Id {
          get { return id_; }
          set {
            id_ = value;
          }
        }

        private uint wheelId_;
        public uint WheelId {
          get { return wheelId_; }
          set {
            wheelId_ = value;
          }
        }

        private uint betMultiply_;
        public uint BetMultiply {
          get { return betMultiply_; }
          set {
            betMultiply_ = value;
          }
        }

        private uint jackpotId_;
        public uint JackpotId {
          get { return jackpotId_; }
          set {
            jackpotId_ = value;
          }
        }

        public void WriteTo(pb::CodedOutputStream output) {
          if (Id != 0) {
            output.WriteRawTag(8);
            output.WriteUInt32(Id);
          }
          if (WheelId != 0) {
            output.WriteRawTag(16);
            output.WriteUInt32(WheelId);
          }
          if (BetMultiply != 0) {
            output.WriteRawTag(24);
            output.WriteUInt32(BetMultiply);
          }
          if (JackpotId != 0) {
            output.WriteRawTag(32);
            output.WriteUInt32(JackpotId);
          }
        }

        public int CalculateSize() {
          int size = 0;
          if (Id != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Id);
          }
          if (WheelId != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(WheelId);
          }
          if (BetMultiply != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(BetMultiply);
          }
          if (JackpotId != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(JackpotId);
          }
          return size;
        }

        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                input.SkipLastField();
                break;
              case 8: {
                Id = input.ReadUInt32();
                break;
              }
              case 16: {
                WheelId = input.ReadUInt32();
                break;
              }
              case 24: {
                BetMultiply = input.ReadUInt32();
                break;
              }
              case 32: {
                JackpotId = input.ReadUInt32();
                break;
              }
            }
          }
        }

      }

      public sealed class JackpotWheelConfig : pb::IMessage {
        private static readonly pb::MessageParser<JackpotWheelConfig> _parser = new pb::MessageParser<JackpotWheelConfig>(() => new JackpotWheelConfig());
        public static pb::MessageParser<JackpotWheelConfig> Parser { get { return _parser; } }

        private static readonly pb::FieldCodec<global::DragonU3DSDK.Network.API.ILProtocol.PoseidonGameConfigExtraInfo.Types.JackpotWheelNode> _repeated_wheels_codec
            = pb::FieldCodec.ForMessage(10, global::DragonU3DSDK.Network.API.ILProtocol.PoseidonGameConfigExtraInfo.Types.JackpotWheelNode.Parser);
        private readonly pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.PoseidonGameConfigExtraInfo.Types.JackpotWheelNode> wheels_ = new pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.PoseidonGameConfigExtraInfo.Types.JackpotWheelNode>();
        public pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.PoseidonGameConfigExtraInfo.Types.JackpotWheelNode> Wheels {
          get { return wheels_; }
        }

        public void WriteTo(pb::CodedOutputStream output) {
          wheels_.WriteTo(output, _repeated_wheels_codec);
        }

        public int CalculateSize() {
          int size = 0;
          size += wheels_.CalculateSize(_repeated_wheels_codec);
          return size;
        }

        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                input.SkipLastField();
                break;
              case 10: {
                wheels_.AddEntriesFrom(input, _repeated_wheels_codec);
                break;
              }
            }
          }
        }

      }

    }
    #endregion

  }

  public sealed class PoseidonGameResultExtraInfo : pb::IMessage {
    private static readonly pb::MessageParser<PoseidonGameResultExtraInfo> _parser = new pb::MessageParser<PoseidonGameResultExtraInfo>(() => new PoseidonGameResultExtraInfo());
    public static pb::MessageParser<PoseidonGameResultExtraInfo> Parser { get { return _parser; } }

    private static readonly pbc::MapField<uint, global::DragonU3DSDK.Network.API.ILProtocol.PoseidonGameResultExtraInfo.Types.ScatterInfo>.Codec _map_freeCountMap_codec
        = new pbc::MapField<uint, global::DragonU3DSDK.Network.API.ILProtocol.PoseidonGameResultExtraInfo.Types.ScatterInfo>.Codec(pb::FieldCodec.ForUInt32(8), pb::FieldCodec.ForMessage(18, global::DragonU3DSDK.Network.API.ILProtocol.PoseidonGameResultExtraInfo.Types.ScatterInfo.Parser), 10);
    private readonly pbc::MapField<uint, global::DragonU3DSDK.Network.API.ILProtocol.PoseidonGameResultExtraInfo.Types.ScatterInfo> freeCountMap_ = new pbc::MapField<uint, global::DragonU3DSDK.Network.API.ILProtocol.PoseidonGameResultExtraInfo.Types.ScatterInfo>();
    /// <summary>
    /// 中免费游戏时的次数分布，id和次数
    /// </summary>
    public pbc::MapField<uint, global::DragonU3DSDK.Network.API.ILProtocol.PoseidonGameResultExtraInfo.Types.ScatterInfo> FreeCountMap {
      get { return freeCountMap_; }
    }

    private global::DragonU3DSDK.Network.API.ILProtocol.PoseidonGameResultExtraInfo.Types.ReSpinPanel reSpinPanel_;
    /// <summary>
    /// reSpin信息
    /// </summary>
    public global::DragonU3DSDK.Network.API.ILProtocol.PoseidonGameResultExtraInfo.Types.ReSpinPanel ReSpinPanel {
      get { return reSpinPanel_; }
      set {
        reSpinPanel_ = value;
      }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      freeCountMap_.WriteTo(output, _map_freeCountMap_codec);
      if (reSpinPanel_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(ReSpinPanel);
      }
    }

    public int CalculateSize() {
      int size = 0;
      size += freeCountMap_.CalculateSize(_map_freeCountMap_codec);
      if (reSpinPanel_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ReSpinPanel);
      }
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            freeCountMap_.AddEntriesFrom(input, _map_freeCountMap_codec);
            break;
          }
          case 18: {
            if (reSpinPanel_ == null) {
              reSpinPanel_ = new global::DragonU3DSDK.Network.API.ILProtocol.PoseidonGameResultExtraInfo.Types.ReSpinPanel();
            }
            input.ReadMessage(reSpinPanel_);
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the PoseidonGameResultExtraInfo message type.</summary>
    public static class Types {
      public sealed class JackpotInfo : pb::IMessage {
        private static readonly pb::MessageParser<JackpotInfo> _parser = new pb::MessageParser<JackpotInfo>(() => new JackpotInfo());
        public static pb::MessageParser<JackpotInfo> Parser { get { return _parser; } }

        private bool isOver_;
        public bool IsOver {
          get { return isOver_; }
          set {
            isOver_ = value;
          }
        }

        private ulong totalWin_;
        public ulong TotalWin {
          get { return totalWin_; }
          set {
            totalWin_ = value;
          }
        }

        private uint winRate_;
        public uint WinRate {
          get { return winRate_; }
          set {
            winRate_ = value;
          }
        }

        private static readonly pb::FieldCodec<uint> _repeated_jackpotWheels_codec
            = pb::FieldCodec.ForUInt32(34);
        private readonly pbc::RepeatedField<uint> jackpotWheels_ = new pbc::RepeatedField<uint>();
        public pbc::RepeatedField<uint> JackpotWheels {
          get { return jackpotWheels_; }
        }

        private uint id_;
        /// <summary>
        /// 中jackpot的格子id
        /// </summary>
        public uint Id {
          get { return id_; }
          set {
            id_ = value;
          }
        }

        private ulong bet_;
        public ulong Bet {
          get { return bet_; }
          set {
            bet_ = value;
          }
        }

        public void WriteTo(pb::CodedOutputStream output) {
          if (IsOver != false) {
            output.WriteRawTag(8);
            output.WriteBool(IsOver);
          }
          if (TotalWin != 0UL) {
            output.WriteRawTag(16);
            output.WriteUInt64(TotalWin);
          }
          if (WinRate != 0) {
            output.WriteRawTag(24);
            output.WriteUInt32(WinRate);
          }
          jackpotWheels_.WriteTo(output, _repeated_jackpotWheels_codec);
          if (Id != 0) {
            output.WriteRawTag(40);
            output.WriteUInt32(Id);
          }
          if (Bet != 0UL) {
            output.WriteRawTag(48);
            output.WriteUInt64(Bet);
          }
        }

        public int CalculateSize() {
          int size = 0;
          if (IsOver != false) {
            size += 1 + 1;
          }
          if (TotalWin != 0UL) {
            size += 1 + pb::CodedOutputStream.ComputeUInt64Size(TotalWin);
          }
          if (WinRate != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(WinRate);
          }
          size += jackpotWheels_.CalculateSize(_repeated_jackpotWheels_codec);
          if (Id != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Id);
          }
          if (Bet != 0UL) {
            size += 1 + pb::CodedOutputStream.ComputeUInt64Size(Bet);
          }
          return size;
        }

        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                input.SkipLastField();
                break;
              case 8: {
                IsOver = input.ReadBool();
                break;
              }
              case 16: {
                TotalWin = input.ReadUInt64();
                break;
              }
              case 24: {
                WinRate = input.ReadUInt32();
                break;
              }
              case 34:
              case 32: {
                jackpotWheels_.AddEntriesFrom(input, _repeated_jackpotWheels_codec);
                break;
              }
              case 40: {
                Id = input.ReadUInt32();
                break;
              }
              case 48: {
                Bet = input.ReadUInt64();
                break;
              }
            }
          }
        }

      }

      public sealed class JackpotWinValue : pb::IMessage {
        private static readonly pb::MessageParser<JackpotWinValue> _parser = new pb::MessageParser<JackpotWinValue>(() => new JackpotWinValue());
        public static pb::MessageParser<JackpotWinValue> Parser { get { return _parser; } }

        private ulong totalWin_;
        public ulong TotalWin {
          get { return totalWin_; }
          set {
            totalWin_ = value;
          }
        }

        public void WriteTo(pb::CodedOutputStream output) {
          if (TotalWin != 0UL) {
            output.WriteRawTag(8);
            output.WriteUInt64(TotalWin);
          }
        }

        public int CalculateSize() {
          int size = 0;
          if (TotalWin != 0UL) {
            size += 1 + pb::CodedOutputStream.ComputeUInt64Size(TotalWin);
          }
          return size;
        }

        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                input.SkipLastField();
                break;
              case 8: {
                TotalWin = input.ReadUInt64();
                break;
              }
            }
          }
        }

      }

      public sealed class ReSpinPanel : pb::IMessage {
        private static readonly pb::MessageParser<ReSpinPanel> _parser = new pb::MessageParser<ReSpinPanel>(() => new ReSpinPanel());
        public static pb::MessageParser<ReSpinPanel> Parser { get { return _parser; } }

        private static readonly pbc::MapField<uint, uint>.Codec _map_symbols_codec
            = new pbc::MapField<uint, uint>.Codec(pb::FieldCodec.ForUInt32(8), pb::FieldCodec.ForUInt32(16), 10);
        private readonly pbc::MapField<uint, uint> symbols_ = new pbc::MapField<uint, uint>();
        /// <summary>
        /// 已经出现的图标
        /// </summary>
        public pbc::MapField<uint, uint> Symbols {
          get { return symbols_; }
        }

        private uint height_;
        /// <summary>
        /// reSpin面板高度
        /// </summary>
        public uint Height {
          get { return height_; }
          set {
            height_ = value;
          }
        }

        private uint symbolLevel_;
        /// <summary>
        /// 图标等级，出现升级图标时会升一级
        /// </summary>
        public uint SymbolLevel {
          get { return symbolLevel_; }
          set {
            symbolLevel_ = value;
          }
        }

        private static readonly pb::FieldCodec<uint> _repeated_specialSymbolSeq_codec
            = pb::FieldCodec.ForUInt32(34);
        private readonly pbc::RepeatedField<uint> specialSymbolSeq_ = new pbc::RepeatedField<uint>();
        /// <summary>
        /// 已经出现的特殊图标
        /// </summary>
        public pbc::RepeatedField<uint> SpecialSymbolSeq {
          get { return specialSymbolSeq_; }
        }

        private uint existSymbolCount_;
        /// <summary>
        /// 不为空的图标数量
        /// </summary>
        public uint ExistSymbolCount {
          get { return existSymbolCount_; }
          set {
            existSymbolCount_ = value;
          }
        }

        private static readonly pbc::MapField<uint, uint>.Codec _map_randomSymbols_codec
            = new pbc::MapField<uint, uint>.Codec(pb::FieldCodec.ForUInt32(8), pb::FieldCodec.ForUInt32(16), 50);
        private readonly pbc::MapField<uint, uint> randomSymbols_ = new pbc::MapField<uint, uint>();
        /// <summary>
        /// 本次spin随机出来的图标
        /// </summary>
        public pbc::MapField<uint, uint> RandomSymbols {
          get { return randomSymbols_; }
        }

        private static readonly pbc::MapField<uint, uint>.Codec _map_expandSymbols_codec
            = new pbc::MapField<uint, uint>.Codec(pb::FieldCodec.ForUInt32(8), pb::FieldCodec.ForUInt32(16), 58);
        private readonly pbc::MapField<uint, uint> expandSymbols_ = new pbc::MapField<uint, uint>();
        /// <summary>
        /// 本次spin特殊图标扩展出来的图标
        /// </summary>
        public pbc::MapField<uint, uint> ExpandSymbols {
          get { return expandSymbols_; }
        }

        private global::DragonU3DSDK.Network.API.ILProtocol.PoseidonGameResultExtraInfo.Types.JackpotInfo jackpotInfo_;
        /// <summary>
        /// reSpin里面中jackpot
        /// </summary>
        public global::DragonU3DSDK.Network.API.ILProtocol.PoseidonGameResultExtraInfo.Types.JackpotInfo JackpotInfo {
          get { return jackpotInfo_; }
          set {
            jackpotInfo_ = value;
          }
        }

        private bool hasNewSymbol_;
        /// <summary>
        /// 本次spin是否有随机到新的图标
        /// </summary>
        public bool HasNewSymbol {
          get { return hasNewSymbol_; }
          set {
            hasNewSymbol_ = value;
          }
        }

        private static readonly pbc::MapField<uint, uint>.Codec _map_jackpotTotalWin_codec
            = new pbc::MapField<uint, uint>.Codec(pb::FieldCodec.ForUInt32(8), pb::FieldCodec.ForUInt32(16), 82);
        private readonly pbc::MapField<uint, uint> jackpotTotalWin_ = new pbc::MapField<uint, uint>();
        /// <summary>
        /// jackpot的赢钱 
        /// </summary>
        public pbc::MapField<uint, uint> JackpotTotalWin {
          get { return jackpotTotalWin_; }
        }

        private static readonly pbc::MapField<uint, global::DragonU3DSDK.Network.API.ILProtocol.PoseidonGameResultExtraInfo.Types.JackpotWinValue>.Codec _map_jackpotTotalWinNew_codec
            = new pbc::MapField<uint, global::DragonU3DSDK.Network.API.ILProtocol.PoseidonGameResultExtraInfo.Types.JackpotWinValue>.Codec(pb::FieldCodec.ForUInt32(8), pb::FieldCodec.ForMessage(18, global::DragonU3DSDK.Network.API.ILProtocol.PoseidonGameResultExtraInfo.Types.JackpotWinValue.Parser), 90);
        private readonly pbc::MapField<uint, global::DragonU3DSDK.Network.API.ILProtocol.PoseidonGameResultExtraInfo.Types.JackpotWinValue> jackpotTotalWinNew_ = new pbc::MapField<uint, global::DragonU3DSDK.Network.API.ILProtocol.PoseidonGameResultExtraInfo.Types.JackpotWinValue>();
        /// <summary>
        /// jackpot的赢钱 
        /// </summary>
        public pbc::MapField<uint, global::DragonU3DSDK.Network.API.ILProtocol.PoseidonGameResultExtraInfo.Types.JackpotWinValue> JackpotTotalWinNew {
          get { return jackpotTotalWinNew_; }
        }

        public void WriteTo(pb::CodedOutputStream output) {
          symbols_.WriteTo(output, _map_symbols_codec);
          if (Height != 0) {
            output.WriteRawTag(16);
            output.WriteUInt32(Height);
          }
          if (SymbolLevel != 0) {
            output.WriteRawTag(24);
            output.WriteUInt32(SymbolLevel);
          }
          specialSymbolSeq_.WriteTo(output, _repeated_specialSymbolSeq_codec);
          if (ExistSymbolCount != 0) {
            output.WriteRawTag(40);
            output.WriteUInt32(ExistSymbolCount);
          }
          randomSymbols_.WriteTo(output, _map_randomSymbols_codec);
          expandSymbols_.WriteTo(output, _map_expandSymbols_codec);
          if (jackpotInfo_ != null) {
            output.WriteRawTag(66);
            output.WriteMessage(JackpotInfo);
          }
          if (HasNewSymbol != false) {
            output.WriteRawTag(72);
            output.WriteBool(HasNewSymbol);
          }
          jackpotTotalWin_.WriteTo(output, _map_jackpotTotalWin_codec);
          jackpotTotalWinNew_.WriteTo(output, _map_jackpotTotalWinNew_codec);
        }

        public int CalculateSize() {
          int size = 0;
          size += symbols_.CalculateSize(_map_symbols_codec);
          if (Height != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Height);
          }
          if (SymbolLevel != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(SymbolLevel);
          }
          size += specialSymbolSeq_.CalculateSize(_repeated_specialSymbolSeq_codec);
          if (ExistSymbolCount != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(ExistSymbolCount);
          }
          size += randomSymbols_.CalculateSize(_map_randomSymbols_codec);
          size += expandSymbols_.CalculateSize(_map_expandSymbols_codec);
          if (jackpotInfo_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(JackpotInfo);
          }
          if (HasNewSymbol != false) {
            size += 1 + 1;
          }
          size += jackpotTotalWin_.CalculateSize(_map_jackpotTotalWin_codec);
          size += jackpotTotalWinNew_.CalculateSize(_map_jackpotTotalWinNew_codec);
          return size;
        }

        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                input.SkipLastField();
                break;
              case 10: {
                symbols_.AddEntriesFrom(input, _map_symbols_codec);
                break;
              }
              case 16: {
                Height = input.ReadUInt32();
                break;
              }
              case 24: {
                SymbolLevel = input.ReadUInt32();
                break;
              }
              case 34:
              case 32: {
                specialSymbolSeq_.AddEntriesFrom(input, _repeated_specialSymbolSeq_codec);
                break;
              }
              case 40: {
                ExistSymbolCount = input.ReadUInt32();
                break;
              }
              case 50: {
                randomSymbols_.AddEntriesFrom(input, _map_randomSymbols_codec);
                break;
              }
              case 58: {
                expandSymbols_.AddEntriesFrom(input, _map_expandSymbols_codec);
                break;
              }
              case 66: {
                if (jackpotInfo_ == null) {
                  jackpotInfo_ = new global::DragonU3DSDK.Network.API.ILProtocol.PoseidonGameResultExtraInfo.Types.JackpotInfo();
                }
                input.ReadMessage(jackpotInfo_);
                break;
              }
              case 72: {
                HasNewSymbol = input.ReadBool();
                break;
              }
              case 82: {
                jackpotTotalWin_.AddEntriesFrom(input, _map_jackpotTotalWin_codec);
                break;
              }
              case 90: {
                jackpotTotalWinNew_.AddEntriesFrom(input, _map_jackpotTotalWinNew_codec);
                break;
              }
            }
          }
        }

      }

      public sealed class ScatterInfo : pb::IMessage {
        private static readonly pb::MessageParser<ScatterInfo> _parser = new pb::MessageParser<ScatterInfo>(() => new ScatterInfo());
        public static pb::MessageParser<ScatterInfo> Parser { get { return _parser; } }

        private static readonly pb::FieldCodec<int> _repeated_counts_codec
            = pb::FieldCodec.ForInt32(10);
        private readonly pbc::RepeatedField<int> counts_ = new pbc::RepeatedField<int>();
        public pbc::RepeatedField<int> Counts {
          get { return counts_; }
        }

        public void WriteTo(pb::CodedOutputStream output) {
          counts_.WriteTo(output, _repeated_counts_codec);
        }

        public int CalculateSize() {
          int size = 0;
          size += counts_.CalculateSize(_repeated_counts_codec);
          return size;
        }

        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                input.SkipLastField();
                break;
              case 10:
              case 8: {
                counts_.AddEntriesFrom(input, _repeated_counts_codec);
                break;
              }
            }
          }
        }

      }

    }
    #endregion

  }

  /// <summary>
  /// 房间信息
  /// </summary>
  public sealed class ZeusVsHadesRoomInfo : pb::IMessage {
    private static readonly pb::MessageParser<ZeusVsHadesRoomInfo> _parser = new pb::MessageParser<ZeusVsHadesRoomInfo>(() => new ZeusVsHadesRoomInfo());
    public static pb::MessageParser<ZeusVsHadesRoomInfo> Parser { get { return _parser; } }

    private string roomId_ = "";
    /// <summary>
    /// 房间id
    /// </summary>
    public string RoomId {
      get { return roomId_; }
      set {
        roomId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    private static readonly pb::FieldCodec<uint> _repeated_seats_codec
        = pb::FieldCodec.ForUInt32(18);
    private readonly pbc::RepeatedField<uint> seats_ = new pbc::RepeatedField<uint>();
    /// <summary>
    /// 座位列表
    /// </summary>
    public pbc::RepeatedField<uint> Seats {
      get { return seats_; }
    }

    private static readonly pb::FieldCodec<global::DragonU3DSDK.Network.API.ILProtocol.ZeusVsHadesRoomInfo.Types.PlayerInfo> _repeated_players_codec
        = pb::FieldCodec.ForMessage(26, global::DragonU3DSDK.Network.API.ILProtocol.ZeusVsHadesRoomInfo.Types.PlayerInfo.Parser);
    private readonly pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.ZeusVsHadesRoomInfo.Types.PlayerInfo> players_ = new pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.ZeusVsHadesRoomInfo.Types.PlayerInfo>();
    /// <summary>
    /// 玩家列表
    /// </summary>
    public pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.ZeusVsHadesRoomInfo.Types.PlayerInfo> Players {
      get { return players_; }
    }

    private uint playerCount0_;
    /// <summary>
    /// 阵营0的玩家数量
    /// </summary>
    public uint PlayerCount0 {
      get { return playerCount0_; }
      set {
        playerCount0_ = value;
      }
    }

    private uint playerCount1_;
    /// <summary>
    /// 阵营1的玩家数量
    /// </summary>
    public uint PlayerCount1 {
      get { return playerCount1_; }
      set {
        playerCount1_ = value;
      }
    }

    private uint expireTime_;
    /// <summary>
    /// 房间数据过期时间
    /// </summary>
    public uint ExpireTime {
      get { return expireTime_; }
      set {
        expireTime_ = value;
      }
    }

    private uint status_;
    /// <summary>
    /// 房间状态
    /// </summary>
    public uint Status {
      get { return status_; }
      set {
        status_ = value;
      }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (RoomId.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(RoomId);
      }
      seats_.WriteTo(output, _repeated_seats_codec);
      players_.WriteTo(output, _repeated_players_codec);
      if (PlayerCount0 != 0) {
        output.WriteRawTag(32);
        output.WriteUInt32(PlayerCount0);
      }
      if (PlayerCount1 != 0) {
        output.WriteRawTag(40);
        output.WriteUInt32(PlayerCount1);
      }
      if (ExpireTime != 0) {
        output.WriteRawTag(48);
        output.WriteUInt32(ExpireTime);
      }
      if (Status != 0) {
        output.WriteRawTag(56);
        output.WriteUInt32(Status);
      }
    }

    public int CalculateSize() {
      int size = 0;
      if (RoomId.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(RoomId);
      }
      size += seats_.CalculateSize(_repeated_seats_codec);
      size += players_.CalculateSize(_repeated_players_codec);
      if (PlayerCount0 != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(PlayerCount0);
      }
      if (PlayerCount1 != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(PlayerCount1);
      }
      if (ExpireTime != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(ExpireTime);
      }
      if (Status != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Status);
      }
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            RoomId = input.ReadString();
            break;
          }
          case 18:
          case 16: {
            seats_.AddEntriesFrom(input, _repeated_seats_codec);
            break;
          }
          case 26: {
            players_.AddEntriesFrom(input, _repeated_players_codec);
            break;
          }
          case 32: {
            PlayerCount0 = input.ReadUInt32();
            break;
          }
          case 40: {
            PlayerCount1 = input.ReadUInt32();
            break;
          }
          case 48: {
            ExpireTime = input.ReadUInt32();
            break;
          }
          case 56: {
            Status = input.ReadUInt32();
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the ZeusVsHadesRoomInfo message type.</summary>
    public static class Types {
      public sealed class PlayerInfo : pb::IMessage {
        private static readonly pb::MessageParser<PlayerInfo> _parser = new pb::MessageParser<PlayerInfo>(() => new PlayerInfo());
        public static pb::MessageParser<PlayerInfo> Parser { get { return _parser; } }

        private ulong playerId_;
        /// <summary>
        /// 玩家id
        /// </summary>
        public ulong PlayerId {
          get { return playerId_; }
          set {
            playerId_ = value;
          }
        }

        private uint avatarId_;
        /// <summary>
        /// 头像id
        /// </summary>
        public uint AvatarId {
          get { return avatarId_; }
          set {
            avatarId_ = value;
          }
        }

        private uint avatarFrameId_;
        /// <summary>
        /// 头像框
        /// </summary>
        public uint AvatarFrameId {
          get { return avatarFrameId_; }
          set {
            avatarFrameId_ = value;
          }
        }

        private uint camp_;
        /// <summary>
        /// 阵营
        /// </summary>
        public uint Camp {
          get { return camp_; }
          set {
            camp_ = value;
          }
        }

        public void WriteTo(pb::CodedOutputStream output) {
          if (PlayerId != 0UL) {
            output.WriteRawTag(8);
            output.WriteUInt64(PlayerId);
          }
          if (AvatarId != 0) {
            output.WriteRawTag(16);
            output.WriteUInt32(AvatarId);
          }
          if (AvatarFrameId != 0) {
            output.WriteRawTag(24);
            output.WriteUInt32(AvatarFrameId);
          }
          if (Camp != 0) {
            output.WriteRawTag(32);
            output.WriteUInt32(Camp);
          }
        }

        public int CalculateSize() {
          int size = 0;
          if (PlayerId != 0UL) {
            size += 1 + pb::CodedOutputStream.ComputeUInt64Size(PlayerId);
          }
          if (AvatarId != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(AvatarId);
          }
          if (AvatarFrameId != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(AvatarFrameId);
          }
          if (Camp != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Camp);
          }
          return size;
        }

        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                input.SkipLastField();
                break;
              case 8: {
                PlayerId = input.ReadUInt64();
                break;
              }
              case 16: {
                AvatarId = input.ReadUInt32();
                break;
              }
              case 24: {
                AvatarFrameId = input.ReadUInt32();
                break;
              }
              case 32: {
                Camp = input.ReadUInt32();
                break;
              }
            }
          }
        }

      }

    }
    #endregion

  }

  /// <summary>
  /// bonus game单个格子的信息
  /// </summary>
  public sealed class ZeusVsHadesBonusGameSlotInfo : pb::IMessage {
    private static readonly pb::MessageParser<ZeusVsHadesBonusGameSlotInfo> _parser = new pb::MessageParser<ZeusVsHadesBonusGameSlotInfo>(() => new ZeusVsHadesBonusGameSlotInfo());
    public static pb::MessageParser<ZeusVsHadesBonusGameSlotInfo> Parser { get { return _parser; } }

    private uint id_;
    /// <summary>
    /// 位置id
    /// </summary>
    public uint Id {
      get { return id_; }
      set {
        id_ = value;
      }
    }

    private uint camp_;
    /// <summary>
    /// 阵营
    /// </summary>
    public uint Camp {
      get { return camp_; }
      set {
        camp_ = value;
      }
    }

    private uint symbolId_;
    /// <summary>
    /// 图标id
    /// </summary>
    public uint SymbolId {
      get { return symbolId_; }
      set {
        symbolId_ = value;
      }
    }

    private uint param_;
    /// <summary>
    /// 赔率/攻击次数
    /// </summary>
    public uint Param {
      get { return param_; }
      set {
        param_ = value;
      }
    }

    private static readonly pb::FieldCodec<uint> _repeated_attackSlots_codec
        = pb::FieldCodec.ForUInt32(42);
    private readonly pbc::RepeatedField<uint> attackSlots_ = new pbc::RepeatedField<uint>();
    /// <summary>
    /// 当symbol攻击图标时，该字段表示攻击了哪几个格子
    /// </summary>
    public pbc::RepeatedField<uint> AttackSlots {
      get { return attackSlots_; }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (Id != 0) {
        output.WriteRawTag(8);
        output.WriteUInt32(Id);
      }
      if (Camp != 0) {
        output.WriteRawTag(16);
        output.WriteUInt32(Camp);
      }
      if (SymbolId != 0) {
        output.WriteRawTag(24);
        output.WriteUInt32(SymbolId);
      }
      if (Param != 0) {
        output.WriteRawTag(32);
        output.WriteUInt32(Param);
      }
      attackSlots_.WriteTo(output, _repeated_attackSlots_codec);
    }

    public int CalculateSize() {
      int size = 0;
      if (Id != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Id);
      }
      if (Camp != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Camp);
      }
      if (SymbolId != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(SymbolId);
      }
      if (Param != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Param);
      }
      size += attackSlots_.CalculateSize(_repeated_attackSlots_codec);
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            Id = input.ReadUInt32();
            break;
          }
          case 16: {
            Camp = input.ReadUInt32();
            break;
          }
          case 24: {
            SymbolId = input.ReadUInt32();
            break;
          }
          case 32: {
            Param = input.ReadUInt32();
            break;
          }
          case 42:
          case 40: {
            attackSlots_.AddEntriesFrom(input, _repeated_attackSlots_codec);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// bonus game 每一步的详细信息
  /// </summary>
  public sealed class ZeusVsHadesBonusGameStepInfo : pb::IMessage {
    private static readonly pb::MessageParser<ZeusVsHadesBonusGameStepInfo> _parser = new pb::MessageParser<ZeusVsHadesBonusGameStepInfo>(() => new ZeusVsHadesBonusGameStepInfo());
    public static pb::MessageParser<ZeusVsHadesBonusGameStepInfo> Parser { get { return _parser; } }

    private uint spinCamp_;
    /// <summary>
    /// 当前spin的阵营，0-双方，1-zeus， 2-hades
    /// </summary>
    public uint SpinCamp {
      get { return spinCamp_; }
      set {
        spinCamp_ = value;
      }
    }

    private uint spinCount_;
    /// <summary>
    /// 剩余spin次数
    /// </summary>
    public uint SpinCount {
      get { return spinCount_; }
      set {
        spinCount_ = value;
      }
    }

    private uint totalSpinCount_;
    /// <summary>
    /// 总的spin次数
    /// </summary>
    public uint TotalSpinCount {
      get { return totalSpinCount_; }
      set {
        totalSpinCount_ = value;
      }
    }

    private static readonly pb::FieldCodec<uint> _repeated_arrows_codec
        = pb::FieldCodec.ForUInt32(34);
    private readonly pbc::RepeatedField<uint> arrows_ = new pbc::RepeatedField<uint>();
    /// <summary>
    /// 双方积攒的箭头
    /// </summary>
    public pbc::RepeatedField<uint> Arrows {
      get { return arrows_; }
    }

    private static readonly pbc::MapField<uint, global::DragonU3DSDK.Network.API.ILProtocol.ZeusVsHadesBonusGameSlotInfo>.Codec _map_slots_codec
        = new pbc::MapField<uint, global::DragonU3DSDK.Network.API.ILProtocol.ZeusVsHadesBonusGameSlotInfo>.Codec(pb::FieldCodec.ForUInt32(8), pb::FieldCodec.ForMessage(18, global::DragonU3DSDK.Network.API.ILProtocol.ZeusVsHadesBonusGameSlotInfo.Parser), 42);
    private readonly pbc::MapField<uint, global::DragonU3DSDK.Network.API.ILProtocol.ZeusVsHadesBonusGameSlotInfo> slots_ = new pbc::MapField<uint, global::DragonU3DSDK.Network.API.ILProtocol.ZeusVsHadesBonusGameSlotInfo>();
    /// <summary>
    /// 格子信息
    /// </summary>
    public pbc::MapField<uint, global::DragonU3DSDK.Network.API.ILProtocol.ZeusVsHadesBonusGameSlotInfo> Slots {
      get { return slots_; }
    }

    private static readonly pb::FieldCodec<global::DragonU3DSDK.Network.API.ILProtocol.ZeusVsHadesBonusGameSlotInfo> _repeated_specialSymbols_codec
        = pb::FieldCodec.ForMessage(50, global::DragonU3DSDK.Network.API.ILProtocol.ZeusVsHadesBonusGameSlotInfo.Parser);
    private readonly pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.ZeusVsHadesBonusGameSlotInfo> specialSymbols_ = new pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.ZeusVsHadesBonusGameSlotInfo>();
    /// <summary>
    /// 转到的特殊图标
    /// </summary>
    public pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.ZeusVsHadesBonusGameSlotInfo> SpecialSymbols {
      get { return specialSymbols_; }
    }

    private uint zeusSpinCount_;
    /// <summary>
    /// 宙斯一方单独的spin次数
    /// </summary>
    public uint ZeusSpinCount {
      get { return zeusSpinCount_; }
      set {
        zeusSpinCount_ = value;
      }
    }

    private uint zeusSpinTotalCount_;
    /// <summary>
    /// 宙斯一方单独的spin总次数
    /// </summary>
    public uint ZeusSpinTotalCount {
      get { return zeusSpinTotalCount_; }
      set {
        zeusSpinTotalCount_ = value;
      }
    }

    private uint attackerCamp_;
    /// <summary>
    /// 当前进攻方阵营
    /// </summary>
    public uint AttackerCamp {
      get { return attackerCamp_; }
      set {
        attackerCamp_ = value;
      }
    }

    private uint randomAddSpinCount_;
    /// <summary>
    /// 随机增加的spin次数，加的是双方的spin次数
    /// </summary>
    public uint RandomAddSpinCount {
      get { return randomAddSpinCount_; }
      set {
        randomAddSpinCount_ = value;
      }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (SpinCamp != 0) {
        output.WriteRawTag(8);
        output.WriteUInt32(SpinCamp);
      }
      if (SpinCount != 0) {
        output.WriteRawTag(16);
        output.WriteUInt32(SpinCount);
      }
      if (TotalSpinCount != 0) {
        output.WriteRawTag(24);
        output.WriteUInt32(TotalSpinCount);
      }
      arrows_.WriteTo(output, _repeated_arrows_codec);
      slots_.WriteTo(output, _map_slots_codec);
      specialSymbols_.WriteTo(output, _repeated_specialSymbols_codec);
      if (ZeusSpinCount != 0) {
        output.WriteRawTag(56);
        output.WriteUInt32(ZeusSpinCount);
      }
      if (ZeusSpinTotalCount != 0) {
        output.WriteRawTag(64);
        output.WriteUInt32(ZeusSpinTotalCount);
      }
      if (AttackerCamp != 0) {
        output.WriteRawTag(72);
        output.WriteUInt32(AttackerCamp);
      }
      if (RandomAddSpinCount != 0) {
        output.WriteRawTag(80);
        output.WriteUInt32(RandomAddSpinCount);
      }
    }

    public int CalculateSize() {
      int size = 0;
      if (SpinCamp != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(SpinCamp);
      }
      if (SpinCount != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(SpinCount);
      }
      if (TotalSpinCount != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(TotalSpinCount);
      }
      size += arrows_.CalculateSize(_repeated_arrows_codec);
      size += slots_.CalculateSize(_map_slots_codec);
      size += specialSymbols_.CalculateSize(_repeated_specialSymbols_codec);
      if (ZeusSpinCount != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(ZeusSpinCount);
      }
      if (ZeusSpinTotalCount != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(ZeusSpinTotalCount);
      }
      if (AttackerCamp != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(AttackerCamp);
      }
      if (RandomAddSpinCount != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(RandomAddSpinCount);
      }
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            SpinCamp = input.ReadUInt32();
            break;
          }
          case 16: {
            SpinCount = input.ReadUInt32();
            break;
          }
          case 24: {
            TotalSpinCount = input.ReadUInt32();
            break;
          }
          case 34:
          case 32: {
            arrows_.AddEntriesFrom(input, _repeated_arrows_codec);
            break;
          }
          case 42: {
            slots_.AddEntriesFrom(input, _map_slots_codec);
            break;
          }
          case 50: {
            specialSymbols_.AddEntriesFrom(input, _repeated_specialSymbols_codec);
            break;
          }
          case 56: {
            ZeusSpinCount = input.ReadUInt32();
            break;
          }
          case 64: {
            ZeusSpinTotalCount = input.ReadUInt32();
            break;
          }
          case 72: {
            AttackerCamp = input.ReadUInt32();
            break;
          }
          case 80: {
            RandomAddSpinCount = input.ReadUInt32();
            break;
          }
        }
      }
    }

  }

  public sealed class ZeusVsHadesBonusGameInfo : pb::IMessage {
    private static readonly pb::MessageParser<ZeusVsHadesBonusGameInfo> _parser = new pb::MessageParser<ZeusVsHadesBonusGameInfo>(() => new ZeusVsHadesBonusGameInfo());
    public static pb::MessageParser<ZeusVsHadesBonusGameInfo> Parser { get { return _parser; } }

    private global::DragonU3DSDK.Network.API.ILProtocol.ZeusVsHadesBonusGameStepInfo preStep_;
    /// <summary>
    /// 上一步的信息
    /// </summary>
    public global::DragonU3DSDK.Network.API.ILProtocol.ZeusVsHadesBonusGameStepInfo PreStep {
      get { return preStep_; }
      set {
        preStep_ = value;
      }
    }

    private global::DragonU3DSDK.Network.API.ILProtocol.ZeusVsHadesBonusGameStepInfo curStep_;
    /// <summary>
    /// 当前这一步的信息
    /// </summary>
    public global::DragonU3DSDK.Network.API.ILProtocol.ZeusVsHadesBonusGameStepInfo CurStep {
      get { return curStep_; }
      set {
        curStep_ = value;
      }
    }

    private bool isOver_;
    /// <summary>
    /// 是否已结束
    /// </summary>
    public bool IsOver {
      get { return isOver_; }
      set {
        isOver_ = value;
      }
    }

    private static readonly pb::FieldCodec<ulong> _repeated_totalWin_codec
        = pb::FieldCodec.ForUInt64(34);
    private readonly pbc::RepeatedField<ulong> totalWin_ = new pbc::RepeatedField<ulong>();
    public pbc::RepeatedField<ulong> TotalWin {
      get { return totalWin_; }
    }

    private uint winCamp_;
    public uint WinCamp {
      get { return winCamp_; }
      set {
        winCamp_ = value;
      }
    }

    private static readonly pb::FieldCodec<uint> _repeated_winRate_codec
        = pb::FieldCodec.ForUInt32(50);
    private readonly pbc::RepeatedField<uint> winRate_ = new pbc::RepeatedField<uint>();
    public pbc::RepeatedField<uint> WinRate {
      get { return winRate_; }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (preStep_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(PreStep);
      }
      if (curStep_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(CurStep);
      }
      if (IsOver != false) {
        output.WriteRawTag(24);
        output.WriteBool(IsOver);
      }
      totalWin_.WriteTo(output, _repeated_totalWin_codec);
      if (WinCamp != 0) {
        output.WriteRawTag(40);
        output.WriteUInt32(WinCamp);
      }
      winRate_.WriteTo(output, _repeated_winRate_codec);
    }

    public int CalculateSize() {
      int size = 0;
      if (preStep_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(PreStep);
      }
      if (curStep_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(CurStep);
      }
      if (IsOver != false) {
        size += 1 + 1;
      }
      size += totalWin_.CalculateSize(_repeated_totalWin_codec);
      if (WinCamp != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(WinCamp);
      }
      size += winRate_.CalculateSize(_repeated_winRate_codec);
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            if (preStep_ == null) {
              preStep_ = new global::DragonU3DSDK.Network.API.ILProtocol.ZeusVsHadesBonusGameStepInfo();
            }
            input.ReadMessage(preStep_);
            break;
          }
          case 18: {
            if (curStep_ == null) {
              curStep_ = new global::DragonU3DSDK.Network.API.ILProtocol.ZeusVsHadesBonusGameStepInfo();
            }
            input.ReadMessage(curStep_);
            break;
          }
          case 24: {
            IsOver = input.ReadBool();
            break;
          }
          case 34:
          case 32: {
            totalWin_.AddEntriesFrom(input, _repeated_totalWin_codec);
            break;
          }
          case 40: {
            WinCamp = input.ReadUInt32();
            break;
          }
          case 50:
          case 48: {
            winRate_.AddEntriesFrom(input, _repeated_winRate_codec);
            break;
          }
        }
      }
    }

  }

  public sealed class ZeusVsHadesSymbolReplace : pb::IMessage {
    private static readonly pb::MessageParser<ZeusVsHadesSymbolReplace> _parser = new pb::MessageParser<ZeusVsHadesSymbolReplace>(() => new ZeusVsHadesSymbolReplace());
    public static pb::MessageParser<ZeusVsHadesSymbolReplace> Parser { get { return _parser; } }

    private uint from_;
    public uint From {
      get { return from_; }
      set {
        from_ = value;
      }
    }

    private uint to_;
    public uint To {
      get { return to_; }
      set {
        to_ = value;
      }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (From != 0) {
        output.WriteRawTag(8);
        output.WriteUInt32(From);
      }
      if (To != 0) {
        output.WriteRawTag(16);
        output.WriteUInt32(To);
      }
    }

    public int CalculateSize() {
      int size = 0;
      if (From != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(From);
      }
      if (To != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(To);
      }
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            From = input.ReadUInt32();
            break;
          }
          case 16: {
            To = input.ReadUInt32();
            break;
          }
        }
      }
    }

  }

  public sealed class ZeusVsHadesGameResultExtraInfo : pb::IMessage {
    private static readonly pb::MessageParser<ZeusVsHadesGameResultExtraInfo> _parser = new pb::MessageParser<ZeusVsHadesGameResultExtraInfo>(() => new ZeusVsHadesGameResultExtraInfo());
    public static pb::MessageParser<ZeusVsHadesGameResultExtraInfo> Parser { get { return _parser; } }

    private static readonly pb::FieldCodec<uint> _repeated_leftToRightWilds_codec
        = pb::FieldCodec.ForUInt32(10);
    private readonly pbc::RepeatedField<uint> leftToRightWilds_ = new pbc::RepeatedField<uint>();
    /// <summary>
    /// 从左边飞到右边的wild列表
    /// </summary>
    public pbc::RepeatedField<uint> LeftToRightWilds {
      get { return leftToRightWilds_; }
    }

    private static readonly pb::FieldCodec<uint> _repeated_rightToLeftWilds_codec
        = pb::FieldCodec.ForUInt32(18);
    private readonly pbc::RepeatedField<uint> rightToLeftWilds_ = new pbc::RepeatedField<uint>();
    /// <summary>
    /// 从右边飞到左边的wild列表
    /// </summary>
    public pbc::RepeatedField<uint> RightToLeftWilds {
      get { return rightToLeftWilds_; }
    }

    private ulong bonusSymbolCollectCoins_;
    /// <summary>
    /// bonus symbol收集到的金币
    /// </summary>
    public ulong BonusSymbolCollectCoins {
      get { return bonusSymbolCollectCoins_; }
      set {
        bonusSymbolCollectCoins_ = value;
      }
    }

    private string bonusRoomId_ = "";
    /// <summary>
    /// bonusGame房间id
    /// </summary>
    public string BonusRoomId {
      get { return bonusRoomId_; }
      set {
        bonusRoomId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    private uint camp_;
    /// <summary>
    /// 所选阵营
    /// </summary>
    public uint Camp {
      get { return camp_; }
      set {
        camp_ = value;
      }
    }

    private uint bonusGameOffset_;
    /// <summary>
    /// 拉取bonus game的偏移
    /// </summary>
    public uint BonusGameOffset {
      get { return bonusGameOffset_; }
      set {
        bonusGameOffset_ = value;
      }
    }

    private global::DragonU3DSDK.Network.API.ILProtocol.ZeusVsHadesRoomInfo roomInfo_;
    /// <summary>
    /// 房间信息
    /// </summary>
    public global::DragonU3DSDK.Network.API.ILProtocol.ZeusVsHadesRoomInfo RoomInfo {
      get { return roomInfo_; }
      set {
        roomInfo_ = value;
      }
    }

    private global::DragonU3DSDK.Network.API.ILProtocol.ZeusVsHadesBonusGameInfo bonusGameInfo_;
    /// <summary>
    /// bonusGame信息
    /// </summary>
    public global::DragonU3DSDK.Network.API.ILProtocol.ZeusVsHadesBonusGameInfo BonusGameInfo {
      get { return bonusGameInfo_; }
      set {
        bonusGameInfo_ = value;
      }
    }

    private static readonly pb::FieldCodec<global::DragonU3DSDK.Network.API.ILProtocol.ZeusVsHadesSymbolReplace> _repeated_replaceSymbols_codec
        = pb::FieldCodec.ForMessage(74, global::DragonU3DSDK.Network.API.ILProtocol.ZeusVsHadesSymbolReplace.Parser);
    private readonly pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.ZeusVsHadesSymbolReplace> replaceSymbols_ = new pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.ZeusVsHadesSymbolReplace>();
    /// <summary>
    /// 图标替换
    /// </summary>
    public pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.ZeusVsHadesSymbolReplace> ReplaceSymbols {
      get { return replaceSymbols_; }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      leftToRightWilds_.WriteTo(output, _repeated_leftToRightWilds_codec);
      rightToLeftWilds_.WriteTo(output, _repeated_rightToLeftWilds_codec);
      if (BonusSymbolCollectCoins != 0UL) {
        output.WriteRawTag(24);
        output.WriteUInt64(BonusSymbolCollectCoins);
      }
      if (BonusRoomId.Length != 0) {
        output.WriteRawTag(34);
        output.WriteString(BonusRoomId);
      }
      if (Camp != 0) {
        output.WriteRawTag(40);
        output.WriteUInt32(Camp);
      }
      if (BonusGameOffset != 0) {
        output.WriteRawTag(48);
        output.WriteUInt32(BonusGameOffset);
      }
      if (roomInfo_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(RoomInfo);
      }
      if (bonusGameInfo_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(BonusGameInfo);
      }
      replaceSymbols_.WriteTo(output, _repeated_replaceSymbols_codec);
    }

    public int CalculateSize() {
      int size = 0;
      size += leftToRightWilds_.CalculateSize(_repeated_leftToRightWilds_codec);
      size += rightToLeftWilds_.CalculateSize(_repeated_rightToLeftWilds_codec);
      if (BonusSymbolCollectCoins != 0UL) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(BonusSymbolCollectCoins);
      }
      if (BonusRoomId.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(BonusRoomId);
      }
      if (Camp != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Camp);
      }
      if (BonusGameOffset != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(BonusGameOffset);
      }
      if (roomInfo_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(RoomInfo);
      }
      if (bonusGameInfo_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(BonusGameInfo);
      }
      size += replaceSymbols_.CalculateSize(_repeated_replaceSymbols_codec);
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10:
          case 8: {
            leftToRightWilds_.AddEntriesFrom(input, _repeated_leftToRightWilds_codec);
            break;
          }
          case 18:
          case 16: {
            rightToLeftWilds_.AddEntriesFrom(input, _repeated_rightToLeftWilds_codec);
            break;
          }
          case 24: {
            BonusSymbolCollectCoins = input.ReadUInt64();
            break;
          }
          case 34: {
            BonusRoomId = input.ReadString();
            break;
          }
          case 40: {
            Camp = input.ReadUInt32();
            break;
          }
          case 48: {
            BonusGameOffset = input.ReadUInt32();
            break;
          }
          case 58: {
            if (roomInfo_ == null) {
              roomInfo_ = new global::DragonU3DSDK.Network.API.ILProtocol.ZeusVsHadesRoomInfo();
            }
            input.ReadMessage(roomInfo_);
            break;
          }
          case 66: {
            if (bonusGameInfo_ == null) {
              bonusGameInfo_ = new global::DragonU3DSDK.Network.API.ILProtocol.ZeusVsHadesBonusGameInfo();
            }
            input.ReadMessage(bonusGameInfo_);
            break;
          }
          case 74: {
            replaceSymbols_.AddEntriesFrom(input, _repeated_replaceSymbols_codec);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///================= 1016: AngelVsDemon ====================================
  /// </summary>
  public sealed class AngelVsDemonSymbolReplace : pb::IMessage {
    private static readonly pb::MessageParser<AngelVsDemonSymbolReplace> _parser = new pb::MessageParser<AngelVsDemonSymbolReplace>(() => new AngelVsDemonSymbolReplace());
    public static pb::MessageParser<AngelVsDemonSymbolReplace> Parser { get { return _parser; } }

    private uint from_;
    public uint From {
      get { return from_; }
      set {
        from_ = value;
      }
    }

    private uint to_;
    public uint To {
      get { return to_; }
      set {
        to_ = value;
      }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (From != 0) {
        output.WriteRawTag(8);
        output.WriteUInt32(From);
      }
      if (To != 0) {
        output.WriteRawTag(16);
        output.WriteUInt32(To);
      }
    }

    public int CalculateSize() {
      int size = 0;
      if (From != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(From);
      }
      if (To != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(To);
      }
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            From = input.ReadUInt32();
            break;
          }
          case 16: {
            To = input.ReadUInt32();
            break;
          }
        }
      }
    }

  }

  public sealed class AngelVsDemonFlyWild : pb::IMessage {
    private static readonly pb::MessageParser<AngelVsDemonFlyWild> _parser = new pb::MessageParser<AngelVsDemonFlyWild>(() => new AngelVsDemonFlyWild());
    public static pb::MessageParser<AngelVsDemonFlyWild> Parser { get { return _parser; } }

    private uint id_;
    /// <summary>
    /// 被替换的格子id，0～24
    /// </summary>
    public uint Id {
      get { return id_; }
      set {
        id_ = value;
      }
    }

    private uint origin_;
    /// <summary>
    /// 替换前的图标
    /// </summary>
    public uint Origin {
      get { return origin_; }
      set {
        origin_ = value;
      }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (Id != 0) {
        output.WriteRawTag(8);
        output.WriteUInt32(Id);
      }
      if (Origin != 0) {
        output.WriteRawTag(16);
        output.WriteUInt32(Origin);
      }
    }

    public int CalculateSize() {
      int size = 0;
      if (Id != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Id);
      }
      if (Origin != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Origin);
      }
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            Id = input.ReadUInt32();
            break;
          }
          case 16: {
            Origin = input.ReadUInt32();
            break;
          }
        }
      }
    }

  }

  public sealed class AngelVsDemonGameResultExtraInfo : pb::IMessage {
    private static readonly pb::MessageParser<AngelVsDemonGameResultExtraInfo> _parser = new pb::MessageParser<AngelVsDemonGameResultExtraInfo>(() => new AngelVsDemonGameResultExtraInfo());
    public static pb::MessageParser<AngelVsDemonGameResultExtraInfo> Parser { get { return _parser; } }

    private static readonly pb::FieldCodec<global::DragonU3DSDK.Network.API.ILProtocol.AngelVsDemonFlyWild> _repeated_leftToRightWilds_codec
        = pb::FieldCodec.ForMessage(10, global::DragonU3DSDK.Network.API.ILProtocol.AngelVsDemonFlyWild.Parser);
    private readonly pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.AngelVsDemonFlyWild> leftToRightWilds_ = new pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.AngelVsDemonFlyWild>();
    /// <summary>
    /// 从左边飞到右边的wild列表，
    /// </summary>
    public pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.AngelVsDemonFlyWild> LeftToRightWilds {
      get { return leftToRightWilds_; }
    }

    private static readonly pb::FieldCodec<global::DragonU3DSDK.Network.API.ILProtocol.AngelVsDemonFlyWild> _repeated_rightToLeftWilds_codec
        = pb::FieldCodec.ForMessage(18, global::DragonU3DSDK.Network.API.ILProtocol.AngelVsDemonFlyWild.Parser);
    private readonly pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.AngelVsDemonFlyWild> rightToLeftWilds_ = new pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.AngelVsDemonFlyWild>();
    /// <summary>
    /// 从右边飞到左边的wild列表
    /// </summary>
    public pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.AngelVsDemonFlyWild> RightToLeftWilds {
      get { return rightToLeftWilds_; }
    }

    private static readonly pb::FieldCodec<global::DragonU3DSDK.Network.API.ILProtocol.ZeusVsHadesSymbolReplace> _repeated_leftReplaceSymbols_codec
        = pb::FieldCodec.ForMessage(26, global::DragonU3DSDK.Network.API.ILProtocol.ZeusVsHadesSymbolReplace.Parser);
    private readonly pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.ZeusVsHadesSymbolReplace> leftReplaceSymbols_ = new pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.ZeusVsHadesSymbolReplace>();
    /// <summary>
    /// 左边面板图标替换
    /// </summary>
    public pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.ZeusVsHadesSymbolReplace> LeftReplaceSymbols {
      get { return leftReplaceSymbols_; }
    }

    private static readonly pb::FieldCodec<global::DragonU3DSDK.Network.API.ILProtocol.ZeusVsHadesSymbolReplace> _repeated_rightReplaceSymbols_codec
        = pb::FieldCodec.ForMessage(34, global::DragonU3DSDK.Network.API.ILProtocol.ZeusVsHadesSymbolReplace.Parser);
    private readonly pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.ZeusVsHadesSymbolReplace> rightReplaceSymbols_ = new pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.ZeusVsHadesSymbolReplace>();
    /// <summary>
    /// 右边面板图标替换
    /// </summary>
    public pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.ZeusVsHadesSymbolReplace> RightReplaceSymbols {
      get { return rightReplaceSymbols_; }
    }

    private static readonly pb::FieldCodec<uint> _repeated_attachFlags_codec
        = pb::FieldCodec.ForUInt32(42);
    private readonly pbc::RepeatedField<uint> attachFlags_ = new pbc::RepeatedField<uint>();
    /// <summary>
    /// 右下角的金币，记录的是有金币的格子id（0～49）
    /// </summary>
    public pbc::RepeatedField<uint> AttachFlags {
      get { return attachFlags_; }
    }

    private bool isHGame_;
    /// <summary>
    /// 是否中HGame
    /// </summary>
    public bool IsHGame {
      get { return isHGame_; }
      set {
        isHGame_ = value;
      }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      leftToRightWilds_.WriteTo(output, _repeated_leftToRightWilds_codec);
      rightToLeftWilds_.WriteTo(output, _repeated_rightToLeftWilds_codec);
      leftReplaceSymbols_.WriteTo(output, _repeated_leftReplaceSymbols_codec);
      rightReplaceSymbols_.WriteTo(output, _repeated_rightReplaceSymbols_codec);
      attachFlags_.WriteTo(output, _repeated_attachFlags_codec);
      if (IsHGame != false) {
        output.WriteRawTag(48);
        output.WriteBool(IsHGame);
      }
    }

    public int CalculateSize() {
      int size = 0;
      size += leftToRightWilds_.CalculateSize(_repeated_leftToRightWilds_codec);
      size += rightToLeftWilds_.CalculateSize(_repeated_rightToLeftWilds_codec);
      size += leftReplaceSymbols_.CalculateSize(_repeated_leftReplaceSymbols_codec);
      size += rightReplaceSymbols_.CalculateSize(_repeated_rightReplaceSymbols_codec);
      size += attachFlags_.CalculateSize(_repeated_attachFlags_codec);
      if (IsHGame != false) {
        size += 1 + 1;
      }
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            leftToRightWilds_.AddEntriesFrom(input, _repeated_leftToRightWilds_codec);
            break;
          }
          case 18: {
            rightToLeftWilds_.AddEntriesFrom(input, _repeated_rightToLeftWilds_codec);
            break;
          }
          case 26: {
            leftReplaceSymbols_.AddEntriesFrom(input, _repeated_leftReplaceSymbols_codec);
            break;
          }
          case 34: {
            rightReplaceSymbols_.AddEntriesFrom(input, _repeated_rightReplaceSymbols_codec);
            break;
          }
          case 42:
          case 40: {
            attachFlags_.AddEntriesFrom(input, _repeated_attachFlags_codec);
            break;
          }
          case 48: {
            IsHGame = input.ReadBool();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///================= 1017: TrainTravel ====================================
  /// </summary>
  public sealed class TrainTravelBetInfo : pb::IMessage {
    private static readonly pb::MessageParser<TrainTravelBetInfo> _parser = new pb::MessageParser<TrainTravelBetInfo>(() => new TrainTravelBetInfo());
    public static pb::MessageParser<TrainTravelBetInfo> Parser { get { return _parser; } }

    private uint spinRound_;
    /// <summary>
    /// spin的轮数
    /// </summary>
    public uint SpinRound {
      get { return spinRound_; }
      set {
        spinRound_ = value;
      }
    }

    private static readonly pb::FieldCodec<uint> _repeated_lockedFrames_codec
        = pb::FieldCodec.ForUInt32(18);
    private readonly pbc::RepeatedField<uint> lockedFrames_ = new pbc::RepeatedField<uint>();
    /// <summary>
    /// 锁定的框
    /// </summary>
    public pbc::RepeatedField<uint> LockedFrames {
      get { return lockedFrames_; }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (SpinRound != 0) {
        output.WriteRawTag(8);
        output.WriteUInt32(SpinRound);
      }
      lockedFrames_.WriteTo(output, _repeated_lockedFrames_codec);
    }

    public int CalculateSize() {
      int size = 0;
      if (SpinRound != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(SpinRound);
      }
      size += lockedFrames_.CalculateSize(_repeated_lockedFrames_codec);
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            SpinRound = input.ReadUInt32();
            break;
          }
          case 18:
          case 16: {
            lockedFrames_.AddEntriesFrom(input, _repeated_lockedFrames_codec);
            break;
          }
        }
      }
    }

  }

  public sealed class TrainTravelGameResultExtraInfo : pb::IMessage {
    private static readonly pb::MessageParser<TrainTravelGameResultExtraInfo> _parser = new pb::MessageParser<TrainTravelGameResultExtraInfo>(() => new TrainTravelGameResultExtraInfo());
    public static pb::MessageParser<TrainTravelGameResultExtraInfo> Parser { get { return _parser; } }

    private uint collectProgress_;
    /// <summary>
    /// 当前收集的进度
    /// </summary>
    public uint CollectProgress {
      get { return collectProgress_; }
      set {
        collectProgress_ = value;
      }
    }

    private uint collectTarget_;
    /// <summary>
    /// 收集所要达到的目标值
    /// </summary>
    public uint CollectTarget {
      get { return collectTarget_; }
      set {
        collectTarget_ = value;
      }
    }

    private uint curMapNode_;
    /// <summary>
    /// 当前所在的地图节点
    /// </summary>
    public uint CurMapNode {
      get { return curMapNode_; }
      set {
        curMapNode_ = value;
      }
    }

    private uint newMapItem_;
    /// <summary>
    /// 是否有触发新的map节点，0表示这次spin没有触发，16表示金币奖励，17表示freeGame
    /// </summary>
    public uint NewMapItem {
      get { return newMapItem_; }
      set {
        newMapItem_ = value;
      }
    }

    private ulong mapCoins_;
    /// <summary>
    /// 地图节点给的次数
    /// </summary>
    public ulong MapCoins {
      get { return mapCoins_; }
      set {
        mapCoins_ = value;
      }
    }

    private uint mapFreeSpinCount_;
    /// <summary>
    /// mapFree游戏的次数
    /// </summary>
    public uint MapFreeSpinCount {
      get { return mapFreeSpinCount_; }
      set {
        mapFreeSpinCount_ = value;
      }
    }

    private static readonly pb::FieldCodec<uint> _repeated_mapFreeLockedWilds_codec
        = pb::FieldCodec.ForUInt32(58);
    private readonly pbc::RepeatedField<uint> mapFreeLockedWilds_ = new pbc::RepeatedField<uint>();
    /// <summary>
    /// 当前MapFreeGame锁定的wild
    /// </summary>
    public pbc::RepeatedField<uint> MapFreeLockedWilds {
      get { return mapFreeLockedWilds_; }
    }

    private static readonly pbc::MapField<ulong, global::DragonU3DSDK.Network.API.ILProtocol.TrainTravelBetInfo>.Codec _map_betInfos_codec
        = new pbc::MapField<ulong, global::DragonU3DSDK.Network.API.ILProtocol.TrainTravelBetInfo>.Codec(pb::FieldCodec.ForUInt64(8), pb::FieldCodec.ForMessage(18, global::DragonU3DSDK.Network.API.ILProtocol.TrainTravelBetInfo.Parser), 66);
    private readonly pbc::MapField<ulong, global::DragonU3DSDK.Network.API.ILProtocol.TrainTravelBetInfo> betInfos_ = new pbc::MapField<ulong, global::DragonU3DSDK.Network.API.ILProtocol.TrainTravelBetInfo>();
    /// <summary>
    /// 每个bet档位对应的信息
    /// </summary>
    public pbc::MapField<ulong, global::DragonU3DSDK.Network.API.ILProtocol.TrainTravelBetInfo> BetInfos {
      get { return betInfos_; }
    }

    private static readonly pb::FieldCodec<uint> _repeated_freeFrames_codec
        = pb::FieldCodec.ForUInt32(74);
    private readonly pbc::RepeatedField<uint> freeFrames_ = new pbc::RepeatedField<uint>();
    /// <summary>
    /// 免费游戏随机的框
    /// </summary>
    public pbc::RepeatedField<uint> FreeFrames {
      get { return freeFrames_; }
    }

    private static readonly pb::FieldCodec<uint> _repeated_newStars_codec
        = pb::FieldCodec.ForUInt32(82);
    private readonly pbc::RepeatedField<uint> newStars_ = new pbc::RepeatedField<uint>();
    /// <summary>
    /// 本次spin新出的星星
    /// </summary>
    public pbc::RepeatedField<uint> NewStars {
      get { return newStars_; }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (CollectProgress != 0) {
        output.WriteRawTag(8);
        output.WriteUInt32(CollectProgress);
      }
      if (CollectTarget != 0) {
        output.WriteRawTag(16);
        output.WriteUInt32(CollectTarget);
      }
      if (CurMapNode != 0) {
        output.WriteRawTag(24);
        output.WriteUInt32(CurMapNode);
      }
      if (NewMapItem != 0) {
        output.WriteRawTag(32);
        output.WriteUInt32(NewMapItem);
      }
      if (MapCoins != 0UL) {
        output.WriteRawTag(40);
        output.WriteUInt64(MapCoins);
      }
      if (MapFreeSpinCount != 0) {
        output.WriteRawTag(48);
        output.WriteUInt32(MapFreeSpinCount);
      }
      mapFreeLockedWilds_.WriteTo(output, _repeated_mapFreeLockedWilds_codec);
      betInfos_.WriteTo(output, _map_betInfos_codec);
      freeFrames_.WriteTo(output, _repeated_freeFrames_codec);
      newStars_.WriteTo(output, _repeated_newStars_codec);
    }

    public int CalculateSize() {
      int size = 0;
      if (CollectProgress != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(CollectProgress);
      }
      if (CollectTarget != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(CollectTarget);
      }
      if (CurMapNode != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(CurMapNode);
      }
      if (NewMapItem != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(NewMapItem);
      }
      if (MapCoins != 0UL) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(MapCoins);
      }
      if (MapFreeSpinCount != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(MapFreeSpinCount);
      }
      size += mapFreeLockedWilds_.CalculateSize(_repeated_mapFreeLockedWilds_codec);
      size += betInfos_.CalculateSize(_map_betInfos_codec);
      size += freeFrames_.CalculateSize(_repeated_freeFrames_codec);
      size += newStars_.CalculateSize(_repeated_newStars_codec);
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            CollectProgress = input.ReadUInt32();
            break;
          }
          case 16: {
            CollectTarget = input.ReadUInt32();
            break;
          }
          case 24: {
            CurMapNode = input.ReadUInt32();
            break;
          }
          case 32: {
            NewMapItem = input.ReadUInt32();
            break;
          }
          case 40: {
            MapCoins = input.ReadUInt64();
            break;
          }
          case 48: {
            MapFreeSpinCount = input.ReadUInt32();
            break;
          }
          case 58:
          case 56: {
            mapFreeLockedWilds_.AddEntriesFrom(input, _repeated_mapFreeLockedWilds_codec);
            break;
          }
          case 66: {
            betInfos_.AddEntriesFrom(input, _map_betInfos_codec);
            break;
          }
          case 74:
          case 72: {
            freeFrames_.AddEntriesFrom(input, _repeated_freeFrames_codec);
            break;
          }
          case 82:
          case 80: {
            newStars_.AddEntriesFrom(input, _repeated_newStars_codec);
            break;
          }
        }
      }
    }

  }

  public sealed class TrainTravelBonusGameRequest : pb::IMessage {
    private static readonly pb::MessageParser<TrainTravelBonusGameRequest> _parser = new pb::MessageParser<TrainTravelBonusGameRequest>(() => new TrainTravelBonusGameRequest());
    public static pb::MessageParser<TrainTravelBonusGameRequest> Parser { get { return _parser; } }

    private uint choose_;
    /// <summary>
    /// 玩家选择的索引，从0开始, 0对应freeGameId为1，1对应freeGameId为2，2对应freeGameId为3
    /// </summary>
    public uint Choose {
      get { return choose_; }
      set {
        choose_ = value;
      }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (Choose != 0) {
        output.WriteRawTag(8);
        output.WriteUInt32(Choose);
      }
    }

    public int CalculateSize() {
      int size = 0;
      if (Choose != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Choose);
      }
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            Choose = input.ReadUInt32();
            break;
          }
        }
      }
    }

  }

  public sealed class MasterOfWealthBonusGameInfo : pb::IMessage {
    private static readonly pb::MessageParser<MasterOfWealthBonusGameInfo> _parser = new pb::MessageParser<MasterOfWealthBonusGameInfo>(() => new MasterOfWealthBonusGameInfo());
    public static pb::MessageParser<MasterOfWealthBonusGameInfo> Parser { get { return _parser; } }

    private bool bonusGameCompleted_;
    /// <summary>
    /// bonus是否已结束
    /// </summary>
    public bool BonusGameCompleted {
      get { return bonusGameCompleted_; }
      set {
        bonusGameCompleted_ = value;
      }
    }

    private uint bonusFinishType_;
    /// <summary>
    /// 结束时中奖的icon类型
    /// </summary>
    public uint BonusFinishType {
      get { return bonusFinishType_; }
      set {
        bonusFinishType_ = value;
      }
    }

    private static readonly pb::FieldCodec<uint> _repeated_icons_codec
        = pb::FieldCodec.ForUInt32(26);
    private readonly pbc::RepeatedField<uint> icons_ = new pbc::RepeatedField<uint>();
    /// <summary>
    /// 玩家已开启的图标
    /// </summary>
    public pbc::RepeatedField<uint> Icons {
      get { return icons_; }
    }

    private static readonly pb::FieldCodec<uint> _repeated_userChoices_codec
        = pb::FieldCodec.ForUInt32(34);
    private readonly pbc::RepeatedField<uint> userChoices_ = new pbc::RepeatedField<uint>();
    /// <summary>
    /// 用户选择的索引序列
    /// </summary>
    public pbc::RepeatedField<uint> UserChoices {
      get { return userChoices_; }
    }

    private ulong totalBet_;
    /// <summary>
    /// </summary>
    public ulong TotalBet {
      get { return totalBet_; }
      set {
        totalBet_ = value;
      }
    }

    private uint winRate_;
    /// <summary>
    /// </summary>
    public uint WinRate {
      get { return winRate_; }
      set {
        winRate_ = value;
      }
    }

    private ulong totalWin_;
    /// <summary>
    /// </summary>
    public ulong TotalWin {
      get { return totalWin_; }
      set {
        totalWin_ = value;
      }
    }

    private uint userSelection_;
    /// <summary>
    /// 玩家最后一次选择的索引
    /// </summary>
    public uint UserSelection {
      get { return userSelection_; }
      set {
        userSelection_ = value;
      }
    }

    private static readonly pb::FieldCodec<uint> _repeated_sequences_codec
        = pb::FieldCodec.ForUInt32(74);
    private readonly pbc::RepeatedField<uint> sequences_ = new pbc::RepeatedField<uint>();
    public pbc::RepeatedField<uint> Sequences {
      get { return sequences_; }
    }

    private ulong baseWin_;
    public ulong BaseWin {
      get { return baseWin_; }
      set {
        baseWin_ = value;
      }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (BonusGameCompleted != false) {
        output.WriteRawTag(8);
        output.WriteBool(BonusGameCompleted);
      }
      if (BonusFinishType != 0) {
        output.WriteRawTag(16);
        output.WriteUInt32(BonusFinishType);
      }
      icons_.WriteTo(output, _repeated_icons_codec);
      userChoices_.WriteTo(output, _repeated_userChoices_codec);
      if (TotalBet != 0UL) {
        output.WriteRawTag(40);
        output.WriteUInt64(TotalBet);
      }
      if (WinRate != 0) {
        output.WriteRawTag(48);
        output.WriteUInt32(WinRate);
      }
      if (TotalWin != 0UL) {
        output.WriteRawTag(56);
        output.WriteUInt64(TotalWin);
      }
      if (UserSelection != 0) {
        output.WriteRawTag(64);
        output.WriteUInt32(UserSelection);
      }
      sequences_.WriteTo(output, _repeated_sequences_codec);
      if (BaseWin != 0UL) {
        output.WriteRawTag(80);
        output.WriteUInt64(BaseWin);
      }
    }

    public int CalculateSize() {
      int size = 0;
      if (BonusGameCompleted != false) {
        size += 1 + 1;
      }
      if (BonusFinishType != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(BonusFinishType);
      }
      size += icons_.CalculateSize(_repeated_icons_codec);
      size += userChoices_.CalculateSize(_repeated_userChoices_codec);
      if (TotalBet != 0UL) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(TotalBet);
      }
      if (WinRate != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(WinRate);
      }
      if (TotalWin != 0UL) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(TotalWin);
      }
      if (UserSelection != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(UserSelection);
      }
      size += sequences_.CalculateSize(_repeated_sequences_codec);
      if (BaseWin != 0UL) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(BaseWin);
      }
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            BonusGameCompleted = input.ReadBool();
            break;
          }
          case 16: {
            BonusFinishType = input.ReadUInt32();
            break;
          }
          case 26:
          case 24: {
            icons_.AddEntriesFrom(input, _repeated_icons_codec);
            break;
          }
          case 34:
          case 32: {
            userChoices_.AddEntriesFrom(input, _repeated_userChoices_codec);
            break;
          }
          case 40: {
            TotalBet = input.ReadUInt64();
            break;
          }
          case 48: {
            WinRate = input.ReadUInt32();
            break;
          }
          case 56: {
            TotalWin = input.ReadUInt64();
            break;
          }
          case 64: {
            UserSelection = input.ReadUInt32();
            break;
          }
          case 74:
          case 72: {
            sequences_.AddEntriesFrom(input, _repeated_sequences_codec);
            break;
          }
          case 80: {
            BaseWin = input.ReadUInt64();
            break;
          }
        }
      }
    }

  }

  public sealed class MasterOfWealthGameResultExtraInfo : pb::IMessage {
    private static readonly pb::MessageParser<MasterOfWealthGameResultExtraInfo> _parser = new pb::MessageParser<MasterOfWealthGameResultExtraInfo>(() => new MasterOfWealthGameResultExtraInfo());
    public static pb::MessageParser<MasterOfWealthGameResultExtraInfo> Parser { get { return _parser; } }

    private static readonly pb::FieldCodec<uint> _repeated_lockedWildsOfFu_codec
        = pb::FieldCodec.ForUInt32(10);
    private readonly pbc::RepeatedField<uint> lockedWildsOfFu_ = new pbc::RepeatedField<uint>();
    /// <summary>
    /// 福锁定的wild
    /// </summary>
    public pbc::RepeatedField<uint> LockedWildsOfFu {
      get { return lockedWildsOfFu_; }
    }

    private static readonly pb::FieldCodec<uint> _repeated_newWildsOfFu_codec
        = pb::FieldCodec.ForUInt32(18);
    private readonly pbc::RepeatedField<uint> newWildsOfFu_ = new pbc::RepeatedField<uint>();
    /// <summary>
    /// 本次spin新出现的wild
    /// </summary>
    public pbc::RepeatedField<uint> NewWildsOfFu {
      get { return newWildsOfFu_; }
    }

    private uint collectWildOfLu_;
    /// <summary>
    /// 禄收集的wild数量
    /// </summary>
    public uint CollectWildOfLu {
      get { return collectWildOfLu_; }
      set {
        collectWildOfLu_ = value;
      }
    }

    private static readonly pb::FieldCodec<uint> _repeated_wildPatternOfShou_codec
        = pb::FieldCodec.ForUInt32(34);
    private readonly pbc::RepeatedField<uint> wildPatternOfShou_ = new pbc::RepeatedField<uint>();
    /// <summary>
    /// 寿所出的wild
    /// </summary>
    public pbc::RepeatedField<uint> WildPatternOfShou {
      get { return wildPatternOfShou_; }
    }

    private uint panelHeightOfShou_;
    /// <summary>
    /// 寿的面板高度
    /// </summary>
    public uint PanelHeightOfShou {
      get { return panelHeightOfShou_; }
      set {
        panelHeightOfShou_ = value;
      }
    }

    private global::DragonU3DSDK.Network.API.ILProtocol.MasterOfWealthBonusGameInfo bonusGameInfo_;
    public global::DragonU3DSDK.Network.API.ILProtocol.MasterOfWealthBonusGameInfo BonusGameInfo {
      get { return bonusGameInfo_; }
      set {
        bonusGameInfo_ = value;
      }
    }

    private uint collectCoinCount_;
    /// <summary>
    /// bonus收集的金币数，一开始初始状态是空的，收集1个金币，变成半满，收集三个金币变成满，直到触发一直保持满的状态
    /// </summary>
    public uint CollectCoinCount {
      get { return collectCoinCount_; }
      set {
        collectCoinCount_ = value;
      }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      lockedWildsOfFu_.WriteTo(output, _repeated_lockedWildsOfFu_codec);
      newWildsOfFu_.WriteTo(output, _repeated_newWildsOfFu_codec);
      if (CollectWildOfLu != 0) {
        output.WriteRawTag(24);
        output.WriteUInt32(CollectWildOfLu);
      }
      wildPatternOfShou_.WriteTo(output, _repeated_wildPatternOfShou_codec);
      if (PanelHeightOfShou != 0) {
        output.WriteRawTag(40);
        output.WriteUInt32(PanelHeightOfShou);
      }
      if (bonusGameInfo_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(BonusGameInfo);
      }
      if (CollectCoinCount != 0) {
        output.WriteRawTag(56);
        output.WriteUInt32(CollectCoinCount);
      }
    }

    public int CalculateSize() {
      int size = 0;
      size += lockedWildsOfFu_.CalculateSize(_repeated_lockedWildsOfFu_codec);
      size += newWildsOfFu_.CalculateSize(_repeated_newWildsOfFu_codec);
      if (CollectWildOfLu != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(CollectWildOfLu);
      }
      size += wildPatternOfShou_.CalculateSize(_repeated_wildPatternOfShou_codec);
      if (PanelHeightOfShou != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(PanelHeightOfShou);
      }
      if (bonusGameInfo_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(BonusGameInfo);
      }
      if (CollectCoinCount != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(CollectCoinCount);
      }
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10:
          case 8: {
            lockedWildsOfFu_.AddEntriesFrom(input, _repeated_lockedWildsOfFu_codec);
            break;
          }
          case 18:
          case 16: {
            newWildsOfFu_.AddEntriesFrom(input, _repeated_newWildsOfFu_codec);
            break;
          }
          case 24: {
            CollectWildOfLu = input.ReadUInt32();
            break;
          }
          case 34:
          case 32: {
            wildPatternOfShou_.AddEntriesFrom(input, _repeated_wildPatternOfShou_codec);
            break;
          }
          case 40: {
            PanelHeightOfShou = input.ReadUInt32();
            break;
          }
          case 50: {
            if (bonusGameInfo_ == null) {
              bonusGameInfo_ = new global::DragonU3DSDK.Network.API.ILProtocol.MasterOfWealthBonusGameInfo();
            }
            input.ReadMessage(bonusGameInfo_);
            break;
          }
          case 56: {
            CollectCoinCount = input.ReadUInt32();
            break;
          }
        }
      }
    }

  }

  public sealed class MasterOfWealthBonusGameRequest : pb::IMessage {
    private static readonly pb::MessageParser<MasterOfWealthBonusGameRequest> _parser = new pb::MessageParser<MasterOfWealthBonusGameRequest>(() => new MasterOfWealthBonusGameRequest());
    public static pb::MessageParser<MasterOfWealthBonusGameRequest> Parser { get { return _parser; } }

    private uint choose_;
    /// <summary>
    /// 玩家选择的索引，从0开始
    /// </summary>
    public uint Choose {
      get { return choose_; }
      set {
        choose_ = value;
      }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (Choose != 0) {
        output.WriteRawTag(8);
        output.WriteUInt32(Choose);
      }
    }

    public int CalculateSize() {
      int size = 0;
      if (Choose != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Choose);
      }
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            Choose = input.ReadUInt32();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///================= 1020: CatInBoots ====================================
  /// </summary>
  public sealed class CatInBootsGameResultExtraInfo : pb::IMessage {
    private static readonly pb::MessageParser<CatInBootsGameResultExtraInfo> _parser = new pb::MessageParser<CatInBootsGameResultExtraInfo>(() => new CatInBootsGameResultExtraInfo());
    public static pb::MessageParser<CatInBootsGameResultExtraInfo> Parser { get { return _parser; } }

    private static readonly pb::FieldCodec<uint> _repeated_doorPositionIds_codec
        = pb::FieldCodec.ForUInt32(10);
    private readonly pbc::RepeatedField<uint> doorPositionIds_ = new pbc::RepeatedField<uint>();
    /// <summary>
    /// sticky doors
    /// </summary>
    public pbc::RepeatedField<uint> DoorPositionIds {
      get { return doorPositionIds_; }
    }

    private static readonly pb::FieldCodec<uint> _repeated_lastDoorPositionIds_codec
        = pb::FieldCodec.ForUInt32(18);
    private readonly pbc::RepeatedField<uint> lastDoorPositionIds_ = new pbc::RepeatedField<uint>();
    /// <summary>
    /// last sticky doors
    /// </summary>
    public pbc::RepeatedField<uint> LastDoorPositionIds {
      get { return lastDoorPositionIds_; }
    }

    private global::DragonU3DSDK.Network.API.ILProtocol.CatInBootsGameResultExtraInfo.Types.LinkData linkData_;
    /// <summary>
    /// link数据
    /// </summary>
    public global::DragonU3DSDK.Network.API.ILProtocol.CatInBootsGameResultExtraInfo.Types.LinkData LinkData {
      get { return linkData_; }
      set {
        linkData_ = value;
      }
    }

    private bool isMapFeature_;
    /// <summary>
    /// 是否是map
    /// </summary>
    public bool IsMapFeature {
      get { return isMapFeature_; }
      set {
        isMapFeature_ = value;
      }
    }

    private uint collectItems_;
    /// <summary>
    /// 当前剩余代币
    /// </summary>
    public uint CollectItems {
      get { return collectItems_; }
      set {
        collectItems_ = value;
      }
    }

    private static readonly pb::FieldCodec<global::DragonU3DSDK.Network.API.ILProtocol.CatInBootsGameResultExtraInfo.Types.RoleData> _repeated_roles_codec
        = pb::FieldCodec.ForMessage(50, global::DragonU3DSDK.Network.API.ILProtocol.CatInBootsGameResultExtraInfo.Types.RoleData.Parser);
    private readonly pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.CatInBootsGameResultExtraInfo.Types.RoleData> roles_ = new pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.CatInBootsGameResultExtraInfo.Types.RoleData>();
    /// <summary>
    /// 角色列表，按下标存，0～3
    /// </summary>
    public pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.CatInBootsGameResultExtraInfo.Types.RoleData> Roles {
      get { return roles_; }
    }

    private global::DragonU3DSDK.Network.API.ILProtocol.CatInBootsGameResultExtraInfo.Types.AvgBetData avgBet_;
    /// <summary>
    /// 平均下注信息
    /// </summary>
    public global::DragonU3DSDK.Network.API.ILProtocol.CatInBootsGameResultExtraInfo.Types.AvgBetData AvgBet {
      get { return avgBet_; }
      set {
        avgBet_ = value;
      }
    }

    private static readonly pbc::MapField<uint, uint>.Codec _map_attachItems_codec
        = new pbc::MapField<uint, uint>.Codec(pb::FieldCodec.ForUInt32(8), pb::FieldCodec.ForUInt32(16), 66);
    private readonly pbc::MapField<uint, uint> attachItems_ = new pbc::MapField<uint, uint>();
    /// <summary>
    /// 附带的角标，key为格子id，1～15，value为item数量
    /// </summary>
    public pbc::MapField<uint, uint> AttachItems {
      get { return attachItems_; }
    }

    private global::DragonU3DSDK.Network.API.ILProtocol.CatInBootsGameResultExtraInfo.Types.SuperFreeInfo cacheSuperFreeInfo_;
    /// <summary>
    /// 缓存的superFree信息
    /// </summary>
    public global::DragonU3DSDK.Network.API.ILProtocol.CatInBootsGameResultExtraInfo.Types.SuperFreeInfo CacheSuperFreeInfo {
      get { return cacheSuperFreeInfo_; }
      set {
        cacheSuperFreeInfo_ = value;
      }
    }

    private bool allOpened_;
    /// <summary>
    /// 是否所有的格子都开过了
    /// </summary>
    public bool AllOpened {
      get { return allOpened_; }
      set {
        allOpened_ = value;
      }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      doorPositionIds_.WriteTo(output, _repeated_doorPositionIds_codec);
      lastDoorPositionIds_.WriteTo(output, _repeated_lastDoorPositionIds_codec);
      if (linkData_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(LinkData);
      }
      if (IsMapFeature != false) {
        output.WriteRawTag(32);
        output.WriteBool(IsMapFeature);
      }
      if (CollectItems != 0) {
        output.WriteRawTag(40);
        output.WriteUInt32(CollectItems);
      }
      roles_.WriteTo(output, _repeated_roles_codec);
      if (avgBet_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(AvgBet);
      }
      attachItems_.WriteTo(output, _map_attachItems_codec);
      if (cacheSuperFreeInfo_ != null) {
        output.WriteRawTag(74);
        output.WriteMessage(CacheSuperFreeInfo);
      }
      if (AllOpened != false) {
        output.WriteRawTag(80);
        output.WriteBool(AllOpened);
      }
    }

    public int CalculateSize() {
      int size = 0;
      size += doorPositionIds_.CalculateSize(_repeated_doorPositionIds_codec);
      size += lastDoorPositionIds_.CalculateSize(_repeated_lastDoorPositionIds_codec);
      if (linkData_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(LinkData);
      }
      if (IsMapFeature != false) {
        size += 1 + 1;
      }
      if (CollectItems != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(CollectItems);
      }
      size += roles_.CalculateSize(_repeated_roles_codec);
      if (avgBet_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(AvgBet);
      }
      size += attachItems_.CalculateSize(_map_attachItems_codec);
      if (cacheSuperFreeInfo_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(CacheSuperFreeInfo);
      }
      if (AllOpened != false) {
        size += 1 + 1;
      }
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10:
          case 8: {
            doorPositionIds_.AddEntriesFrom(input, _repeated_doorPositionIds_codec);
            break;
          }
          case 18:
          case 16: {
            lastDoorPositionIds_.AddEntriesFrom(input, _repeated_lastDoorPositionIds_codec);
            break;
          }
          case 26: {
            if (linkData_ == null) {
              linkData_ = new global::DragonU3DSDK.Network.API.ILProtocol.CatInBootsGameResultExtraInfo.Types.LinkData();
            }
            input.ReadMessage(linkData_);
            break;
          }
          case 32: {
            IsMapFeature = input.ReadBool();
            break;
          }
          case 40: {
            CollectItems = input.ReadUInt32();
            break;
          }
          case 50: {
            roles_.AddEntriesFrom(input, _repeated_roles_codec);
            break;
          }
          case 58: {
            if (avgBet_ == null) {
              avgBet_ = new global::DragonU3DSDK.Network.API.ILProtocol.CatInBootsGameResultExtraInfo.Types.AvgBetData();
            }
            input.ReadMessage(avgBet_);
            break;
          }
          case 66: {
            attachItems_.AddEntriesFrom(input, _map_attachItems_codec);
            break;
          }
          case 74: {
            if (cacheSuperFreeInfo_ == null) {
              cacheSuperFreeInfo_ = new global::DragonU3DSDK.Network.API.ILProtocol.CatInBootsGameResultExtraInfo.Types.SuperFreeInfo();
            }
            input.ReadMessage(cacheSuperFreeInfo_);
            break;
          }
          case 80: {
            AllOpened = input.ReadBool();
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the CatInBootsGameResultExtraInfo message type.</summary>
    public static class Types {
      public enum RewardType {
        UnknownReward = 0,
        /// <summary>
        /// 金币奖励
        /// </summary>
        Coin = 1,
        /// <summary>
        /// 免费游戏
        /// </summary>
        FreeGame = 2,
        /// <summary>
        /// re spin
        /// </summary>
        Respin = 3,
      }

      public sealed class LinkData : pb::IMessage {
        private static readonly pb::MessageParser<LinkData> _parser = new pb::MessageParser<LinkData>(() => new LinkData());
        public static pb::MessageParser<LinkData> Parser { get { return _parser; } }

        private static readonly pb::FieldCodec<global::DragonU3DSDK.Network.API.ILProtocol.CatInBootsGameResultExtraInfo.Types.LinkData.Types.Item> _repeated_items_codec
            = pb::FieldCodec.ForMessage(10, global::DragonU3DSDK.Network.API.ILProtocol.CatInBootsGameResultExtraInfo.Types.LinkData.Types.Item.Parser);
        private readonly pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.CatInBootsGameResultExtraInfo.Types.LinkData.Types.Item> items_ = new pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.CatInBootsGameResultExtraInfo.Types.LinkData.Types.Item>();
        public pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.CatInBootsGameResultExtraInfo.Types.LinkData.Types.Item> Items {
          get { return items_; }
        }

        private uint fullWinRate_;
        /// <summary>
        /// grandJackpot winRate, 没中是0
        /// </summary>
        public uint FullWinRate {
          get { return fullWinRate_; }
          set {
            fullWinRate_ = value;
          }
        }

        public void WriteTo(pb::CodedOutputStream output) {
          items_.WriteTo(output, _repeated_items_codec);
          if (FullWinRate != 0) {
            output.WriteRawTag(16);
            output.WriteUInt32(FullWinRate);
          }
        }

        public int CalculateSize() {
          int size = 0;
          size += items_.CalculateSize(_repeated_items_codec);
          if (FullWinRate != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(FullWinRate);
          }
          return size;
        }

        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                input.SkipLastField();
                break;
              case 10: {
                items_.AddEntriesFrom(input, _repeated_items_codec);
                break;
              }
              case 16: {
                FullWinRate = input.ReadUInt32();
                break;
              }
            }
          }
        }

        #region Nested types
        /// <summary>Container for nested types declared in the LinkData message type.</summary>
        public static class Types {
          public sealed class Item : pb::IMessage {
            private static readonly pb::MessageParser<Item> _parser = new pb::MessageParser<Item>(() => new Item());
            public static pb::MessageParser<Item> Parser { get { return _parser; } }

            private uint positionId_;
            /// <summary>
            /// 位置
            /// </summary>
            public uint PositionId {
              get { return positionId_; }
              set {
                positionId_ = value;
              }
            }

            private uint symbolId_;
            /// <summary>
            /// 现实图标
            /// </summary>
            public uint SymbolId {
              get { return symbolId_; }
              set {
                symbolId_ = value;
              }
            }

            private ulong winRate_;
            /// <summary>
            /// 赢钱倍率
            /// </summary>
            public ulong WinRate {
              get { return winRate_; }
              set {
                winRate_ = value;
              }
            }

            private uint jackpotId_;
            /// <summary>
            /// jackpotId
            /// </summary>
            public uint JackpotId {
              get { return jackpotId_; }
              set {
                jackpotId_ = value;
              }
            }

            private ulong jackpotPay_;
            /// <summary>
            /// jackpot倍率
            /// </summary>
            public ulong JackpotPay {
              get { return jackpotPay_; }
              set {
                jackpotPay_ = value;
              }
            }

            public void WriteTo(pb::CodedOutputStream output) {
              if (PositionId != 0) {
                output.WriteRawTag(8);
                output.WriteUInt32(PositionId);
              }
              if (SymbolId != 0) {
                output.WriteRawTag(16);
                output.WriteUInt32(SymbolId);
              }
              if (WinRate != 0UL) {
                output.WriteRawTag(24);
                output.WriteUInt64(WinRate);
              }
              if (JackpotId != 0) {
                output.WriteRawTag(32);
                output.WriteUInt32(JackpotId);
              }
              if (JackpotPay != 0UL) {
                output.WriteRawTag(40);
                output.WriteUInt64(JackpotPay);
              }
            }

            public int CalculateSize() {
              int size = 0;
              if (PositionId != 0) {
                size += 1 + pb::CodedOutputStream.ComputeUInt32Size(PositionId);
              }
              if (SymbolId != 0) {
                size += 1 + pb::CodedOutputStream.ComputeUInt32Size(SymbolId);
              }
              if (WinRate != 0UL) {
                size += 1 + pb::CodedOutputStream.ComputeUInt64Size(WinRate);
              }
              if (JackpotId != 0) {
                size += 1 + pb::CodedOutputStream.ComputeUInt32Size(JackpotId);
              }
              if (JackpotPay != 0UL) {
                size += 1 + pb::CodedOutputStream.ComputeUInt64Size(JackpotPay);
              }
              return size;
            }

            public void MergeFrom(pb::CodedInputStream input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    input.SkipLastField();
                    break;
                  case 8: {
                    PositionId = input.ReadUInt32();
                    break;
                  }
                  case 16: {
                    SymbolId = input.ReadUInt32();
                    break;
                  }
                  case 24: {
                    WinRate = input.ReadUInt64();
                    break;
                  }
                  case 32: {
                    JackpotId = input.ReadUInt32();
                    break;
                  }
                  case 40: {
                    JackpotPay = input.ReadUInt64();
                    break;
                  }
                }
              }
            }

          }

        }
        #endregion

      }

      public sealed class RoleGridData : pb::IMessage {
        private static readonly pb::MessageParser<RoleGridData> _parser = new pb::MessageParser<RoleGridData>(() => new RoleGridData());
        public static pb::MessageParser<RoleGridData> Parser { get { return _parser; } }

        private global::DragonU3DSDK.Network.API.ILProtocol.CatInBootsGameResultExtraInfo.Types.RewardType rewardType_ = 0;
        /// <summary>
        /// 奖励类型
        /// </summary>
        public global::DragonU3DSDK.Network.API.ILProtocol.CatInBootsGameResultExtraInfo.Types.RewardType RewardType {
          get { return rewardType_; }
          set {
            rewardType_ = value;
          }
        }

        private uint rewardValue_;
        /// <summary>
        /// 奖励相关的数值
        /// </summary>
        public uint RewardValue {
          get { return rewardValue_; }
          set {
            rewardValue_ = value;
          }
        }

        private ulong avgBet_;
        /// <summary>
        /// 翻开的时候的avg bet
        /// </summary>
        public ulong AvgBet {
          get { return avgBet_; }
          set {
            avgBet_ = value;
          }
        }

        private bool opened_;
        /// <summary>
        /// 格子是否开启
        /// </summary>
        public bool Opened {
          get { return opened_; }
          set {
            opened_ = value;
          }
        }

        private uint price_;
        /// <summary>
        /// 格子价格
        /// </summary>
        public uint Price {
          get { return price_; }
          set {
            price_ = value;
          }
        }

        public void WriteTo(pb::CodedOutputStream output) {
          if (RewardType != 0) {
            output.WriteRawTag(8);
            output.WriteEnum((int) RewardType);
          }
          if (RewardValue != 0) {
            output.WriteRawTag(16);
            output.WriteUInt32(RewardValue);
          }
          if (AvgBet != 0UL) {
            output.WriteRawTag(24);
            output.WriteUInt64(AvgBet);
          }
          if (Opened != false) {
            output.WriteRawTag(32);
            output.WriteBool(Opened);
          }
          if (Price != 0) {
            output.WriteRawTag(40);
            output.WriteUInt32(Price);
          }
        }

        public int CalculateSize() {
          int size = 0;
          if (RewardType != 0) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) RewardType);
          }
          if (RewardValue != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(RewardValue);
          }
          if (AvgBet != 0UL) {
            size += 1 + pb::CodedOutputStream.ComputeUInt64Size(AvgBet);
          }
          if (Opened != false) {
            size += 1 + 1;
          }
          if (Price != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Price);
          }
          return size;
        }

        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                input.SkipLastField();
                break;
              case 8: {
                rewardType_ = (global::DragonU3DSDK.Network.API.ILProtocol.CatInBootsGameResultExtraInfo.Types.RewardType) input.ReadEnum();
                break;
              }
              case 16: {
                RewardValue = input.ReadUInt32();
                break;
              }
              case 24: {
                AvgBet = input.ReadUInt64();
                break;
              }
              case 32: {
                Opened = input.ReadBool();
                break;
              }
              case 40: {
                Price = input.ReadUInt32();
                break;
              }
            }
          }
        }

      }

      public sealed class RoleData : pb::IMessage {
        private static readonly pb::MessageParser<RoleData> _parser = new pb::MessageParser<RoleData>(() => new RoleData());
        public static pb::MessageParser<RoleData> Parser { get { return _parser; } }

        private uint roleId_;
        /// <summary>
        /// 角色id
        /// </summary>
        public uint RoleId {
          get { return roleId_; }
          set {
            roleId_ = value;
          }
        }

        private static readonly pb::FieldCodec<global::DragonU3DSDK.Network.API.ILProtocol.CatInBootsGameResultExtraInfo.Types.RoleGridData> _repeated_grids_codec
            = pb::FieldCodec.ForMessage(18, global::DragonU3DSDK.Network.API.ILProtocol.CatInBootsGameResultExtraInfo.Types.RoleGridData.Parser);
        private readonly pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.CatInBootsGameResultExtraInfo.Types.RoleGridData> grids_ = new pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.CatInBootsGameResultExtraInfo.Types.RoleGridData>();
        /// <summary>
        /// 格子信息，按下标存，0～8
        /// </summary>
        public pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.CatInBootsGameResultExtraInfo.Types.RoleGridData> Grids {
          get { return grids_; }
        }

        private bool unlocked_;
        /// <summary>
        /// 是否已解锁
        /// </summary>
        public bool Unlocked {
          get { return unlocked_; }
          set {
            unlocked_ = value;
          }
        }

        private uint superFreeSpinCount_;
        /// <summary>
        /// superFree的次数
        /// </summary>
        public uint SuperFreeSpinCount {
          get { return superFreeSpinCount_; }
          set {
            superFreeSpinCount_ = value;
          }
        }

        private static readonly pb::FieldCodec<uint> _repeated_superFreePattern_codec
            = pb::FieldCodec.ForUInt32(42);
        private readonly pbc::RepeatedField<uint> superFreePattern_ = new pbc::RepeatedField<uint>();
        public pbc::RepeatedField<uint> SuperFreePattern {
          get { return superFreePattern_; }
        }

        public void WriteTo(pb::CodedOutputStream output) {
          if (RoleId != 0) {
            output.WriteRawTag(8);
            output.WriteUInt32(RoleId);
          }
          grids_.WriteTo(output, _repeated_grids_codec);
          if (Unlocked != false) {
            output.WriteRawTag(24);
            output.WriteBool(Unlocked);
          }
          if (SuperFreeSpinCount != 0) {
            output.WriteRawTag(32);
            output.WriteUInt32(SuperFreeSpinCount);
          }
          superFreePattern_.WriteTo(output, _repeated_superFreePattern_codec);
        }

        public int CalculateSize() {
          int size = 0;
          if (RoleId != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(RoleId);
          }
          size += grids_.CalculateSize(_repeated_grids_codec);
          if (Unlocked != false) {
            size += 1 + 1;
          }
          if (SuperFreeSpinCount != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(SuperFreeSpinCount);
          }
          size += superFreePattern_.CalculateSize(_repeated_superFreePattern_codec);
          return size;
        }

        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                input.SkipLastField();
                break;
              case 8: {
                RoleId = input.ReadUInt32();
                break;
              }
              case 18: {
                grids_.AddEntriesFrom(input, _repeated_grids_codec);
                break;
              }
              case 24: {
                Unlocked = input.ReadBool();
                break;
              }
              case 32: {
                SuperFreeSpinCount = input.ReadUInt32();
                break;
              }
              case 42:
              case 40: {
                superFreePattern_.AddEntriesFrom(input, _repeated_superFreePattern_codec);
                break;
              }
            }
          }
        }

      }

      public sealed class AvgBetData : pb::IMessage {
        private static readonly pb::MessageParser<AvgBetData> _parser = new pb::MessageParser<AvgBetData>(() => new AvgBetData());
        public static pb::MessageParser<AvgBetData> Parser { get { return _parser; } }

        private uint spinCount_;
        /// <summary>
        /// spin次数
        /// </summary>
        public uint SpinCount {
          get { return spinCount_; }
          set {
            spinCount_ = value;
          }
        }

        private ulong avgBet_;
        /// <summary>
        /// 当前的平均下注
        /// </summary>
        public ulong AvgBet {
          get { return avgBet_; }
          set {
            avgBet_ = value;
          }
        }

        private ulong totalBet_;
        public ulong TotalBet {
          get { return totalBet_; }
          set {
            totalBet_ = value;
          }
        }

        public void WriteTo(pb::CodedOutputStream output) {
          if (SpinCount != 0) {
            output.WriteRawTag(8);
            output.WriteUInt32(SpinCount);
          }
          if (AvgBet != 0UL) {
            output.WriteRawTag(16);
            output.WriteUInt64(AvgBet);
          }
          if (TotalBet != 0UL) {
            output.WriteRawTag(24);
            output.WriteUInt64(TotalBet);
          }
        }

        public int CalculateSize() {
          int size = 0;
          if (SpinCount != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(SpinCount);
          }
          if (AvgBet != 0UL) {
            size += 1 + pb::CodedOutputStream.ComputeUInt64Size(AvgBet);
          }
          if (TotalBet != 0UL) {
            size += 1 + pb::CodedOutputStream.ComputeUInt64Size(TotalBet);
          }
          return size;
        }

        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                input.SkipLastField();
                break;
              case 8: {
                SpinCount = input.ReadUInt32();
                break;
              }
              case 16: {
                AvgBet = input.ReadUInt64();
                break;
              }
              case 24: {
                TotalBet = input.ReadUInt64();
                break;
              }
            }
          }
        }

      }

      public sealed class SuperFreeInfo : pb::IMessage {
        private static readonly pb::MessageParser<SuperFreeInfo> _parser = new pb::MessageParser<SuperFreeInfo>(() => new SuperFreeInfo());
        public static pb::MessageParser<SuperFreeInfo> Parser { get { return _parser; } }

        private uint freeSpinId_;
        public uint FreeSpinId {
          get { return freeSpinId_; }
          set {
            freeSpinId_ = value;
          }
        }

        private uint freeSpinCount_;
        public uint FreeSpinCount {
          get { return freeSpinCount_; }
          set {
            freeSpinCount_ = value;
          }
        }

        public void WriteTo(pb::CodedOutputStream output) {
          if (FreeSpinId != 0) {
            output.WriteRawTag(8);
            output.WriteUInt32(FreeSpinId);
          }
          if (FreeSpinCount != 0) {
            output.WriteRawTag(16);
            output.WriteUInt32(FreeSpinCount);
          }
        }

        public int CalculateSize() {
          int size = 0;
          if (FreeSpinId != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(FreeSpinId);
          }
          if (FreeSpinCount != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(FreeSpinCount);
          }
          return size;
        }

        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                input.SkipLastField();
                break;
              case 8: {
                FreeSpinId = input.ReadUInt32();
                break;
              }
              case 16: {
                FreeSpinCount = input.ReadUInt32();
                break;
              }
            }
          }
        }

      }

    }
    #endregion

  }

  public sealed class CatInBootsBonusGameRequest : pb::IMessage {
    private static readonly pb::MessageParser<CatInBootsBonusGameRequest> _parser = new pb::MessageParser<CatInBootsBonusGameRequest>(() => new CatInBootsBonusGameRequest());
    public static pb::MessageParser<CatInBootsBonusGameRequest> Parser { get { return _parser; } }

    private uint roleId_;
    /// <summary>
    /// 要升级的角色id
    /// </summary>
    public uint RoleId {
      get { return roleId_; }
      set {
        roleId_ = value;
      }
    }

    private uint choose_;
    /// <summary>
    /// 玩家选择的索引，从0开始
    /// </summary>
    public uint Choose {
      get { return choose_; }
      set {
        choose_ = value;
      }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (RoleId != 0) {
        output.WriteRawTag(8);
        output.WriteUInt32(RoleId);
      }
      if (Choose != 0) {
        output.WriteRawTag(16);
        output.WriteUInt32(Choose);
      }
    }

    public int CalculateSize() {
      int size = 0;
      if (RoleId != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(RoleId);
      }
      if (Choose != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Choose);
      }
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            RoleId = input.ReadUInt32();
            break;
          }
          case 16: {
            Choose = input.ReadUInt32();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///================= CaptainPenguin ====================================
  /// </summary>
  public sealed class CaptainPenguinGameResultExtraInfo : pb::IMessage {
    private static readonly pb::MessageParser<CaptainPenguinGameResultExtraInfo> _parser = new pb::MessageParser<CaptainPenguinGameResultExtraInfo>(() => new CaptainPenguinGameResultExtraInfo());
    public static pb::MessageParser<CaptainPenguinGameResultExtraInfo> Parser { get { return _parser; } }

    private global::DragonU3DSDK.Network.API.ILProtocol.CaptainPenguinGameResultExtraInfo.Types.FreeGameInfo freeGameInfo_;
    /// <summary>
    /// 免费游戏数据
    /// </summary>
    public global::DragonU3DSDK.Network.API.ILProtocol.CaptainPenguinGameResultExtraInfo.Types.FreeGameInfo FreeGameInfo {
      get { return freeGameInfo_; }
      set {
        freeGameInfo_ = value;
      }
    }

    private global::DragonU3DSDK.Network.API.ILProtocol.CaptainPenguinGameResultExtraInfo.Types.ReSpinInfo reSpinInfo_;
    public global::DragonU3DSDK.Network.API.ILProtocol.CaptainPenguinGameResultExtraInfo.Types.ReSpinInfo ReSpinInfo {
      get { return reSpinInfo_; }
      set {
        reSpinInfo_ = value;
      }
    }

    private static readonly pbc::MapField<uint, uint>.Codec _map_randomWild_codec
        = new pbc::MapField<uint, uint>.Codec(pb::FieldCodec.ForUInt32(8), pb::FieldCodec.ForUInt32(16), 26);
    private readonly pbc::MapField<uint, uint> randomWild_ = new pbc::MapField<uint, uint>();
    /// <summary>
    /// 随机的wild
    /// </summary>
    public pbc::MapField<uint, uint> RandomWild {
      get { return randomWild_; }
    }

    private static readonly pbc::MapField<uint, uint>.Codec _map_randomScatter_codec
        = new pbc::MapField<uint, uint>.Codec(pb::FieldCodec.ForUInt32(8), pb::FieldCodec.ForUInt32(16), 34);
    private readonly pbc::MapField<uint, uint> randomScatter_ = new pbc::MapField<uint, uint>();
    public pbc::MapField<uint, uint> RandomScatter {
      get { return randomScatter_; }
    }

    private static readonly pb::FieldCodec<uint> _repeated_randomS01_codec
        = pb::FieldCodec.ForUInt32(42);
    private readonly pbc::RepeatedField<uint> randomS01_ = new pbc::RepeatedField<uint>();
    /// <summary>
    /// 随机的s01
    /// </summary>
    public pbc::RepeatedField<uint> RandomS01 {
      get { return randomS01_; }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (freeGameInfo_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(FreeGameInfo);
      }
      if (reSpinInfo_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(ReSpinInfo);
      }
      randomWild_.WriteTo(output, _map_randomWild_codec);
      randomScatter_.WriteTo(output, _map_randomScatter_codec);
      randomS01_.WriteTo(output, _repeated_randomS01_codec);
    }

    public int CalculateSize() {
      int size = 0;
      if (freeGameInfo_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(FreeGameInfo);
      }
      if (reSpinInfo_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ReSpinInfo);
      }
      size += randomWild_.CalculateSize(_map_randomWild_codec);
      size += randomScatter_.CalculateSize(_map_randomScatter_codec);
      size += randomS01_.CalculateSize(_repeated_randomS01_codec);
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            if (freeGameInfo_ == null) {
              freeGameInfo_ = new global::DragonU3DSDK.Network.API.ILProtocol.CaptainPenguinGameResultExtraInfo.Types.FreeGameInfo();
            }
            input.ReadMessage(freeGameInfo_);
            break;
          }
          case 18: {
            if (reSpinInfo_ == null) {
              reSpinInfo_ = new global::DragonU3DSDK.Network.API.ILProtocol.CaptainPenguinGameResultExtraInfo.Types.ReSpinInfo();
            }
            input.ReadMessage(reSpinInfo_);
            break;
          }
          case 26: {
            randomWild_.AddEntriesFrom(input, _map_randomWild_codec);
            break;
          }
          case 34: {
            randomScatter_.AddEntriesFrom(input, _map_randomScatter_codec);
            break;
          }
          case 42:
          case 40: {
            randomS01_.AddEntriesFrom(input, _repeated_randomS01_codec);
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the CaptainPenguinGameResultExtraInfo message type.</summary>
    public static class Types {
      public sealed class FreeGameInfo : pb::IMessage {
        private static readonly pb::MessageParser<FreeGameInfo> _parser = new pb::MessageParser<FreeGameInfo>(() => new FreeGameInfo());
        public static pb::MessageParser<FreeGameInfo> Parser { get { return _parser; } }

        private static readonly pbc::MapField<uint, uint>.Codec _map_preLockedSymbols_codec
            = new pbc::MapField<uint, uint>.Codec(pb::FieldCodec.ForUInt32(8), pb::FieldCodec.ForUInt32(16), 10);
        private readonly pbc::MapField<uint, uint> preLockedSymbols_ = new pbc::MapField<uint, uint>();
        /// <summary>
        /// 前一把锁定的图标
        /// </summary>
        public pbc::MapField<uint, uint> PreLockedSymbols {
          get { return preLockedSymbols_; }
        }

        private static readonly pbc::MapField<uint, uint>.Codec _map_newLockedSymbols_codec
            = new pbc::MapField<uint, uint>.Codec(pb::FieldCodec.ForUInt32(8), pb::FieldCodec.ForUInt32(16), 18);
        private readonly pbc::MapField<uint, uint> newLockedSymbols_ = new pbc::MapField<uint, uint>();
        /// <summary>
        /// 新锁定的图标
        /// </summary>
        public pbc::MapField<uint, uint> NewLockedSymbols {
          get { return newLockedSymbols_; }
        }

        public void WriteTo(pb::CodedOutputStream output) {
          preLockedSymbols_.WriteTo(output, _map_preLockedSymbols_codec);
          newLockedSymbols_.WriteTo(output, _map_newLockedSymbols_codec);
        }

        public int CalculateSize() {
          int size = 0;
          size += preLockedSymbols_.CalculateSize(_map_preLockedSymbols_codec);
          size += newLockedSymbols_.CalculateSize(_map_newLockedSymbols_codec);
          return size;
        }

        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                input.SkipLastField();
                break;
              case 10: {
                preLockedSymbols_.AddEntriesFrom(input, _map_preLockedSymbols_codec);
                break;
              }
              case 18: {
                newLockedSymbols_.AddEntriesFrom(input, _map_newLockedSymbols_codec);
                break;
              }
            }
          }
        }

      }

      public sealed class ReSpinInfo : pb::IMessage {
        private static readonly pb::MessageParser<ReSpinInfo> _parser = new pb::MessageParser<ReSpinInfo>(() => new ReSpinInfo());
        public static pb::MessageParser<ReSpinInfo> Parser { get { return _parser; } }

        private uint panelHeight_;
        /// <summary>
        /// 当前面板高度
        /// </summary>
        public uint PanelHeight {
          get { return panelHeight_; }
          set {
            panelHeight_ = value;
          }
        }

        private static readonly pb::FieldCodec<uint> _repeated_validFrames_codec
            = pb::FieldCodec.ForUInt32(18);
        private readonly pbc::RepeatedField<uint> validFrames_ = new pbc::RepeatedField<uint>();
        /// <summary>
        /// 当前剩下的框
        /// </summary>
        public pbc::RepeatedField<uint> ValidFrames {
          get { return validFrames_; }
        }

        private static readonly pb::FieldCodec<uint> _repeated_usedFrames_codec
            = pb::FieldCodec.ForUInt32(26);
        private readonly pbc::RepeatedField<uint> usedFrames_ = new pbc::RepeatedField<uint>();
        /// <summary>
        ///  已经用掉的框
        /// </summary>
        public pbc::RepeatedField<uint> UsedFrames {
          get { return usedFrames_; }
        }

        private static readonly pb::FieldCodec<uint> _repeated_newFrames_codec
            = pb::FieldCodec.ForUInt32(34);
        private readonly pbc::RepeatedField<uint> newFrames_ = new pbc::RepeatedField<uint>();
        /// <summary>
        /// 新出现的框
        /// </summary>
        public pbc::RepeatedField<uint> NewFrames {
          get { return newFrames_; }
        }

        private static readonly pb::FieldCodec<global::DragonU3DSDK.Network.API.ILProtocol.CaptainPenguinGameResultExtraInfo.Types.ReSpinInfo.Types.CoinInFrame> _repeated_coinInFrame_codec
            = pb::FieldCodec.ForMessage(42, global::DragonU3DSDK.Network.API.ILProtocol.CaptainPenguinGameResultExtraInfo.Types.ReSpinInfo.Types.CoinInFrame.Parser);
        private readonly pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.CaptainPenguinGameResultExtraInfo.Types.ReSpinInfo.Types.CoinInFrame> coinInFrame_ = new pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.CaptainPenguinGameResultExtraInfo.Types.ReSpinInfo.Types.CoinInFrame>();
        /// <summary>
        /// 出现在框里面的coin，等待spin
        /// </summary>
        public pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.CaptainPenguinGameResultExtraInfo.Types.ReSpinInfo.Types.CoinInFrame> CoinInFrame {
          get { return coinInFrame_; }
        }

        private static readonly pbc::MapField<uint, global::DragonU3DSDK.Network.API.ILProtocol.CaptainPenguinGameResultExtraInfo.Types.ReSpinInfo.Types.LinkItem>.Codec _map_linkItems_codec
            = new pbc::MapField<uint, global::DragonU3DSDK.Network.API.ILProtocol.CaptainPenguinGameResultExtraInfo.Types.ReSpinInfo.Types.LinkItem>.Codec(pb::FieldCodec.ForUInt32(8), pb::FieldCodec.ForMessage(18, global::DragonU3DSDK.Network.API.ILProtocol.CaptainPenguinGameResultExtraInfo.Types.ReSpinInfo.Types.LinkItem.Parser), 50);
        private readonly pbc::MapField<uint, global::DragonU3DSDK.Network.API.ILProtocol.CaptainPenguinGameResultExtraInfo.Types.ReSpinInfo.Types.LinkItem> linkItems_ = new pbc::MapField<uint, global::DragonU3DSDK.Network.API.ILProtocol.CaptainPenguinGameResultExtraInfo.Types.ReSpinInfo.Types.LinkItem>();
        /// <summary>
        /// 当前面板上的coin，包括coin_in_frame
        /// </summary>
        public pbc::MapField<uint, global::DragonU3DSDK.Network.API.ILProtocol.CaptainPenguinGameResultExtraInfo.Types.ReSpinInfo.Types.LinkItem> LinkItems {
          get { return linkItems_; }
        }

        private ulong addedToReels_;
        /// <summary>
        /// 金黄色的coin的值
        /// </summary>
        public ulong AddedToReels {
          get { return addedToReels_; }
          set {
            addedToReels_ = value;
          }
        }

        private global::DragonU3DSDK.Network.API.ILProtocol.CaptainPenguinGameResultExtraInfo.Types.ReSpinInfo.Types.JackpotInfo jackpotInfo_;
        /// <summary>
        /// jackpotInfo，有此信息时需要弹jackpot的collect界面
        /// </summary>
        public global::DragonU3DSDK.Network.API.ILProtocol.CaptainPenguinGameResultExtraInfo.Types.ReSpinInfo.Types.JackpotInfo JackpotInfo {
          get { return jackpotInfo_; }
          set {
            jackpotInfo_ = value;
          }
        }

        private uint startCoinNum_;
        public uint StartCoinNum {
          get { return startCoinNum_; }
          set {
            startCoinNum_ = value;
          }
        }

        private static readonly pbc::MapField<uint, uint>.Codec _map_startCoins_codec
            = new pbc::MapField<uint, uint>.Codec(pb::FieldCodec.ForUInt32(8), pb::FieldCodec.ForUInt32(16), 82);
        private readonly pbc::MapField<uint, uint> startCoins_ = new pbc::MapField<uint, uint>();
        public pbc::MapField<uint, uint> StartCoins {
          get { return startCoins_; }
        }

        private uint randomPickIndex_;
        /// <summary>
        /// 配合小转轮使用的一个随机参数
        /// </summary>
        public uint RandomPickIndex {
          get { return randomPickIndex_; }
          set {
            randomPickIndex_ = value;
          }
        }

        private ulong yellowCoinTotalWinRate_;
        /// <summary>
        /// 当前面板上所有黄币的和
        /// </summary>
        public ulong YellowCoinTotalWinRate {
          get { return yellowCoinTotalWinRate_; }
          set {
            yellowCoinTotalWinRate_ = value;
          }
        }

        public void WriteTo(pb::CodedOutputStream output) {
          if (PanelHeight != 0) {
            output.WriteRawTag(8);
            output.WriteUInt32(PanelHeight);
          }
          validFrames_.WriteTo(output, _repeated_validFrames_codec);
          usedFrames_.WriteTo(output, _repeated_usedFrames_codec);
          newFrames_.WriteTo(output, _repeated_newFrames_codec);
          coinInFrame_.WriteTo(output, _repeated_coinInFrame_codec);
          linkItems_.WriteTo(output, _map_linkItems_codec);
          if (AddedToReels != 0UL) {
            output.WriteRawTag(56);
            output.WriteUInt64(AddedToReels);
          }
          if (jackpotInfo_ != null) {
            output.WriteRawTag(66);
            output.WriteMessage(JackpotInfo);
          }
          if (StartCoinNum != 0) {
            output.WriteRawTag(72);
            output.WriteUInt32(StartCoinNum);
          }
          startCoins_.WriteTo(output, _map_startCoins_codec);
          if (RandomPickIndex != 0) {
            output.WriteRawTag(88);
            output.WriteUInt32(RandomPickIndex);
          }
          if (YellowCoinTotalWinRate != 0UL) {
            output.WriteRawTag(96);
            output.WriteUInt64(YellowCoinTotalWinRate);
          }
        }

        public int CalculateSize() {
          int size = 0;
          if (PanelHeight != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(PanelHeight);
          }
          size += validFrames_.CalculateSize(_repeated_validFrames_codec);
          size += usedFrames_.CalculateSize(_repeated_usedFrames_codec);
          size += newFrames_.CalculateSize(_repeated_newFrames_codec);
          size += coinInFrame_.CalculateSize(_repeated_coinInFrame_codec);
          size += linkItems_.CalculateSize(_map_linkItems_codec);
          if (AddedToReels != 0UL) {
            size += 1 + pb::CodedOutputStream.ComputeUInt64Size(AddedToReels);
          }
          if (jackpotInfo_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(JackpotInfo);
          }
          if (StartCoinNum != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(StartCoinNum);
          }
          size += startCoins_.CalculateSize(_map_startCoins_codec);
          if (RandomPickIndex != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(RandomPickIndex);
          }
          if (YellowCoinTotalWinRate != 0UL) {
            size += 1 + pb::CodedOutputStream.ComputeUInt64Size(YellowCoinTotalWinRate);
          }
          return size;
        }

        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                input.SkipLastField();
                break;
              case 8: {
                PanelHeight = input.ReadUInt32();
                break;
              }
              case 18:
              case 16: {
                validFrames_.AddEntriesFrom(input, _repeated_validFrames_codec);
                break;
              }
              case 26:
              case 24: {
                usedFrames_.AddEntriesFrom(input, _repeated_usedFrames_codec);
                break;
              }
              case 34:
              case 32: {
                newFrames_.AddEntriesFrom(input, _repeated_newFrames_codec);
                break;
              }
              case 42: {
                coinInFrame_.AddEntriesFrom(input, _repeated_coinInFrame_codec);
                break;
              }
              case 50: {
                linkItems_.AddEntriesFrom(input, _map_linkItems_codec);
                break;
              }
              case 56: {
                AddedToReels = input.ReadUInt64();
                break;
              }
              case 66: {
                if (jackpotInfo_ == null) {
                  jackpotInfo_ = new global::DragonU3DSDK.Network.API.ILProtocol.CaptainPenguinGameResultExtraInfo.Types.ReSpinInfo.Types.JackpotInfo();
                }
                input.ReadMessage(jackpotInfo_);
                break;
              }
              case 72: {
                StartCoinNum = input.ReadUInt32();
                break;
              }
              case 82: {
                startCoins_.AddEntriesFrom(input, _map_startCoins_codec);
                break;
              }
              case 88: {
                RandomPickIndex = input.ReadUInt32();
                break;
              }
              case 96: {
                YellowCoinTotalWinRate = input.ReadUInt64();
                break;
              }
            }
          }
        }

        #region Nested types
        /// <summary>Container for nested types declared in the ReSpinInfo message type.</summary>
        public static class Types {
          public sealed class CoinInFrame : pb::IMessage {
            private static readonly pb::MessageParser<CoinInFrame> _parser = new pb::MessageParser<CoinInFrame>(() => new CoinInFrame());
            public static pb::MessageParser<CoinInFrame> Parser { get { return _parser; } }

            private uint id_;
            public uint Id {
              get { return id_; }
              set {
                id_ = value;
              }
            }

            private uint symbolId_;
            public uint SymbolId {
              get { return symbolId_; }
              set {
                symbolId_ = value;
              }
            }

            public void WriteTo(pb::CodedOutputStream output) {
              if (Id != 0) {
                output.WriteRawTag(8);
                output.WriteUInt32(Id);
              }
              if (SymbolId != 0) {
                output.WriteRawTag(16);
                output.WriteUInt32(SymbolId);
              }
            }

            public int CalculateSize() {
              int size = 0;
              if (Id != 0) {
                size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Id);
              }
              if (SymbolId != 0) {
                size += 1 + pb::CodedOutputStream.ComputeUInt32Size(SymbolId);
              }
              return size;
            }

            public void MergeFrom(pb::CodedInputStream input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    input.SkipLastField();
                    break;
                  case 8: {
                    Id = input.ReadUInt32();
                    break;
                  }
                  case 16: {
                    SymbolId = input.ReadUInt32();
                    break;
                  }
                }
              }
            }

          }

          public sealed class LinkItem : pb::IMessage {
            private static readonly pb::MessageParser<LinkItem> _parser = new pb::MessageParser<LinkItem>(() => new LinkItem());
            public static pb::MessageParser<LinkItem> Parser { get { return _parser; } }

            private uint positionId_;
            /// <summary>
            /// 位置
            /// </summary>
            public uint PositionId {
              get { return positionId_; }
              set {
                positionId_ = value;
              }
            }

            private uint symbolId_;
            /// <summary>
            /// 图标
            /// </summary>
            public uint SymbolId {
              get { return symbolId_; }
              set {
                symbolId_ = value;
              }
            }

            private ulong winRate_;
            /// <summary>
            /// 赢钱倍率
            /// </summary>
            public ulong WinRate {
              get { return winRate_; }
              set {
                winRate_ = value;
              }
            }

            private uint jackpotId_;
            /// <summary>
            /// jackpotId
            /// </summary>
            public uint JackpotId {
              get { return jackpotId_; }
              set {
                jackpotId_ = value;
              }
            }

            private ulong jackpotPay_;
            /// <summary>
            /// jackpot倍率
            /// </summary>
            public ulong JackpotPay {
              get { return jackpotPay_; }
              set {
                jackpotPay_ = value;
              }
            }

            private uint jackpotCount_;
            public uint JackpotCount {
              get { return jackpotCount_; }
              set {
                jackpotCount_ = value;
              }
            }

            public void WriteTo(pb::CodedOutputStream output) {
              if (PositionId != 0) {
                output.WriteRawTag(8);
                output.WriteUInt32(PositionId);
              }
              if (SymbolId != 0) {
                output.WriteRawTag(16);
                output.WriteUInt32(SymbolId);
              }
              if (WinRate != 0UL) {
                output.WriteRawTag(24);
                output.WriteUInt64(WinRate);
              }
              if (JackpotId != 0) {
                output.WriteRawTag(32);
                output.WriteUInt32(JackpotId);
              }
              if (JackpotPay != 0UL) {
                output.WriteRawTag(40);
                output.WriteUInt64(JackpotPay);
              }
              if (JackpotCount != 0) {
                output.WriteRawTag(48);
                output.WriteUInt32(JackpotCount);
              }
            }

            public int CalculateSize() {
              int size = 0;
              if (PositionId != 0) {
                size += 1 + pb::CodedOutputStream.ComputeUInt32Size(PositionId);
              }
              if (SymbolId != 0) {
                size += 1 + pb::CodedOutputStream.ComputeUInt32Size(SymbolId);
              }
              if (WinRate != 0UL) {
                size += 1 + pb::CodedOutputStream.ComputeUInt64Size(WinRate);
              }
              if (JackpotId != 0) {
                size += 1 + pb::CodedOutputStream.ComputeUInt32Size(JackpotId);
              }
              if (JackpotPay != 0UL) {
                size += 1 + pb::CodedOutputStream.ComputeUInt64Size(JackpotPay);
              }
              if (JackpotCount != 0) {
                size += 1 + pb::CodedOutputStream.ComputeUInt32Size(JackpotCount);
              }
              return size;
            }

            public void MergeFrom(pb::CodedInputStream input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    input.SkipLastField();
                    break;
                  case 8: {
                    PositionId = input.ReadUInt32();
                    break;
                  }
                  case 16: {
                    SymbolId = input.ReadUInt32();
                    break;
                  }
                  case 24: {
                    WinRate = input.ReadUInt64();
                    break;
                  }
                  case 32: {
                    JackpotId = input.ReadUInt32();
                    break;
                  }
                  case 40: {
                    JackpotPay = input.ReadUInt64();
                    break;
                  }
                  case 48: {
                    JackpotCount = input.ReadUInt32();
                    break;
                  }
                }
              }
            }

          }

          public sealed class JackpotInfo : pb::IMessage {
            private static readonly pb::MessageParser<JackpotInfo> _parser = new pb::MessageParser<JackpotInfo>(() => new JackpotInfo());
            public static pb::MessageParser<JackpotInfo> Parser { get { return _parser; } }

            private uint jackpotId_;
            public uint JackpotId {
              get { return jackpotId_; }
              set {
                jackpotId_ = value;
              }
            }

            private uint jackpotPay_;
            public uint JackpotPay {
              get { return jackpotPay_; }
              set {
                jackpotPay_ = value;
              }
            }

            private ulong totalWin_;
            public ulong TotalWin {
              get { return totalWin_; }
              set {
                totalWin_ = value;
              }
            }

            public void WriteTo(pb::CodedOutputStream output) {
              if (JackpotId != 0) {
                output.WriteRawTag(8);
                output.WriteUInt32(JackpotId);
              }
              if (JackpotPay != 0) {
                output.WriteRawTag(16);
                output.WriteUInt32(JackpotPay);
              }
              if (TotalWin != 0UL) {
                output.WriteRawTag(24);
                output.WriteUInt64(TotalWin);
              }
            }

            public int CalculateSize() {
              int size = 0;
              if (JackpotId != 0) {
                size += 1 + pb::CodedOutputStream.ComputeUInt32Size(JackpotId);
              }
              if (JackpotPay != 0) {
                size += 1 + pb::CodedOutputStream.ComputeUInt32Size(JackpotPay);
              }
              if (TotalWin != 0UL) {
                size += 1 + pb::CodedOutputStream.ComputeUInt64Size(TotalWin);
              }
              return size;
            }

            public void MergeFrom(pb::CodedInputStream input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    input.SkipLastField();
                    break;
                  case 8: {
                    JackpotId = input.ReadUInt32();
                    break;
                  }
                  case 16: {
                    JackpotPay = input.ReadUInt32();
                    break;
                  }
                  case 24: {
                    TotalWin = input.ReadUInt64();
                    break;
                  }
                }
              }
            }

          }

        }
        #endregion

      }

    }
    #endregion

  }

  /// <summary>
  ///================= LuxuryRiches ====================================
  /// </summary>
  public sealed class LuxuryRichesGameResultExtraInfo : pb::IMessage {
    private static readonly pb::MessageParser<LuxuryRichesGameResultExtraInfo> _parser = new pb::MessageParser<LuxuryRichesGameResultExtraInfo>(() => new LuxuryRichesGameResultExtraInfo());
    public static pb::MessageParser<LuxuryRichesGameResultExtraInfo> Parser { get { return _parser; } }

    private global::DragonU3DSDK.Network.API.ILProtocol.NormalReSpinExtraInfo reSpinInfo_;
    public global::DragonU3DSDK.Network.API.ILProtocol.NormalReSpinExtraInfo ReSpinInfo {
      get { return reSpinInfo_; }
      set {
        reSpinInfo_ = value;
      }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (reSpinInfo_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(ReSpinInfo);
      }
    }

    public int CalculateSize() {
      int size = 0;
      if (reSpinInfo_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ReSpinInfo);
      }
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            if (reSpinInfo_ == null) {
              reSpinInfo_ = new global::DragonU3DSDK.Network.API.ILProtocol.NormalReSpinExtraInfo();
            }
            input.ReadMessage(reSpinInfo_);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///================= PharaohTreasure2 ================
  /// </summary>
  public sealed class PharaohTreasure2GameResultExtraInfo : pb::IMessage {
    private static readonly pb::MessageParser<PharaohTreasure2GameResultExtraInfo> _parser = new pb::MessageParser<PharaohTreasure2GameResultExtraInfo>(() => new PharaohTreasure2GameResultExtraInfo());
    public static pb::MessageParser<PharaohTreasure2GameResultExtraInfo> Parser { get { return _parser; } }

    private static readonly pb::FieldCodec<global::DragonU3DSDK.Network.API.ILProtocol.PharaohTreasure2GameResultExtraInfo.Types.JackpotWord> _repeated_jackpotWords_codec
        = pb::FieldCodec.ForMessage(10, global::DragonU3DSDK.Network.API.ILProtocol.PharaohTreasure2GameResultExtraInfo.Types.JackpotWord.Parser);
    private readonly pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.PharaohTreasure2GameResultExtraInfo.Types.JackpotWord> jackpotWords_ = new pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.PharaohTreasure2GameResultExtraInfo.Types.JackpotWord>();
    /// <summary>
    /// jackpot word情况: GRAND, MAJOR, MINOR, MINI
    /// </summary>
    public pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.PharaohTreasure2GameResultExtraInfo.Types.JackpotWord> JackpotWords {
      get { return jackpotWords_; }
    }

    private static readonly pb::FieldCodec<bool> _repeated_freeGameType_codec
        = pb::FieldCodec.ForBool(18);
    private readonly pbc::RepeatedField<bool> freeGameType_ = new pbc::RepeatedField<bool>();
    /// <summary>
    /// 当前freeSpin游戏的类型， 按照绿红紫顺序。 如果当前是绿紫feature，free_game_type为[true, false, true]
    /// </summary>
    public pbc::RepeatedField<bool> FreeGameType {
      get { return freeGameType_; }
    }

    private static readonly pb::FieldCodec<global::DragonU3DSDK.Network.API.ILProtocol.PharaohTreasure2GameResultExtraInfo.Types.FeatureState> _repeated_featureStates_codec
        = pb::FieldCodec.ForMessage(26, global::DragonU3DSDK.Network.API.ILProtocol.PharaohTreasure2GameResultExtraInfo.Types.FeatureState.Parser);
    private readonly pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.PharaohTreasure2GameResultExtraInfo.Types.FeatureState> featureStates_ = new pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.PharaohTreasure2GameResultExtraInfo.Types.FeatureState>();
    /// <summary>
    /// 当前三个魔法罐子的激活状态， 按照绿红紫顺序。
    /// </summary>
    public pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.PharaohTreasure2GameResultExtraInfo.Types.FeatureState> FeatureStates {
      get { return featureStates_; }
    }

    private static readonly pbc::MapField<uint, int>.Codec _map_greenReelPositionMap_codec
        = new pbc::MapField<uint, int>.Codec(pb::FieldCodec.ForUInt32(8), pb::FieldCodec.ForInt32(16), 34);
    private readonly pbc::MapField<uint, int> greenReelPositionMap_ = new pbc::MapField<uint, int>();
    /// <summary>
    /// 当前绿色feature拉wild信息 key: col 0-4, value: 上下偏移; drag wild
    /// </summary>
    public pbc::MapField<uint, int> GreenReelPositionMap {
      get { return greenReelPositionMap_; }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      jackpotWords_.WriteTo(output, _repeated_jackpotWords_codec);
      freeGameType_.WriteTo(output, _repeated_freeGameType_codec);
      featureStates_.WriteTo(output, _repeated_featureStates_codec);
      greenReelPositionMap_.WriteTo(output, _map_greenReelPositionMap_codec);
    }

    public int CalculateSize() {
      int size = 0;
      size += jackpotWords_.CalculateSize(_repeated_jackpotWords_codec);
      size += freeGameType_.CalculateSize(_repeated_freeGameType_codec);
      size += featureStates_.CalculateSize(_repeated_featureStates_codec);
      size += greenReelPositionMap_.CalculateSize(_map_greenReelPositionMap_codec);
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            jackpotWords_.AddEntriesFrom(input, _repeated_jackpotWords_codec);
            break;
          }
          case 18:
          case 16: {
            freeGameType_.AddEntriesFrom(input, _repeated_freeGameType_codec);
            break;
          }
          case 26: {
            featureStates_.AddEntriesFrom(input, _repeated_featureStates_codec);
            break;
          }
          case 34: {
            greenReelPositionMap_.AddEntriesFrom(input, _map_greenReelPositionMap_codec);
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the PharaohTreasure2GameResultExtraInfo message type.</summary>
    public static class Types {
      public sealed class JackpotWord : pb::IMessage {
        private static readonly pb::MessageParser<JackpotWord> _parser = new pb::MessageParser<JackpotWord>(() => new JackpotWord());
        public static pb::MessageParser<JackpotWord> Parser { get { return _parser; } }

        private uint jackpotId_;
        /// <summary>
        /// jackpotId
        /// </summary>
        public uint JackpotId {
          get { return jackpotId_; }
          set {
            jackpotId_ = value;
          }
        }

        private static readonly pb::FieldCodec<bool> _repeated_state_codec
            = pb::FieldCodec.ForBool(18);
        private readonly pbc::RepeatedField<bool> state_ = new pbc::RepeatedField<bool>();
        /// <summary>
        /// 最新字母收集情况, 例: 如果GRAND收集了G,A,D, state为[true, false, true, false, true]
        /// </summary>
        public pbc::RepeatedField<bool> State {
          get { return state_; }
        }

        private uint count_;
        /// <summary>
        /// 这一次spin中奖本单词的次数，多数情况是0或1，少数情况大于1（这一次spin让mini收集了2次!）。
        /// </summary>
        public uint Count {
          get { return count_; }
          set {
            count_ = value;
          }
        }

        public void WriteTo(pb::CodedOutputStream output) {
          if (JackpotId != 0) {
            output.WriteRawTag(8);
            output.WriteUInt32(JackpotId);
          }
          state_.WriteTo(output, _repeated_state_codec);
          if (Count != 0) {
            output.WriteRawTag(24);
            output.WriteUInt32(Count);
          }
        }

        public int CalculateSize() {
          int size = 0;
          if (JackpotId != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(JackpotId);
          }
          size += state_.CalculateSize(_repeated_state_codec);
          if (Count != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Count);
          }
          return size;
        }

        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                input.SkipLastField();
                break;
              case 8: {
                JackpotId = input.ReadUInt32();
                break;
              }
              case 18:
              case 16: {
                state_.AddEntriesFrom(input, _repeated_state_codec);
                break;
              }
              case 24: {
                Count = input.ReadUInt32();
                break;
              }
            }
          }
        }

      }

      public sealed class FeatureState : pb::IMessage {
        private static readonly pb::MessageParser<FeatureState> _parser = new pb::MessageParser<FeatureState>(() => new FeatureState());
        public static pb::MessageParser<FeatureState> Parser { get { return _parser; } }

        private bool activated_;
        /// <summary>
        /// 激活
        /// </summary>
        public bool Activated {
          get { return activated_; }
          set {
            activated_ = value;
          }
        }

        private bool exaggerated_;
        /// <summary>
        /// 变大
        /// </summary>
        public bool Exaggerated {
          get { return exaggerated_; }
          set {
            exaggerated_ = value;
          }
        }

        public void WriteTo(pb::CodedOutputStream output) {
          if (Activated != false) {
            output.WriteRawTag(8);
            output.WriteBool(Activated);
          }
          if (Exaggerated != false) {
            output.WriteRawTag(16);
            output.WriteBool(Exaggerated);
          }
        }

        public int CalculateSize() {
          int size = 0;
          if (Activated != false) {
            size += 1 + 1;
          }
          if (Exaggerated != false) {
            size += 1 + 1;
          }
          return size;
        }

        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                input.SkipLastField();
                break;
              case 8: {
                Activated = input.ReadBool();
                break;
              }
              case 16: {
                Exaggerated = input.ReadBool();
                break;
              }
            }
          }
        }

      }

    }
    #endregion

  }

  /// <summary>
  ///*======================== LionGold2 ============================*/
  /// </summary>
  public sealed class LionGold2GameResultExtraInfo : pb::IMessage {
    private static readonly pb::MessageParser<LionGold2GameResultExtraInfo> _parser = new pb::MessageParser<LionGold2GameResultExtraInfo>(() => new LionGold2GameResultExtraInfo());
    public static pb::MessageParser<LionGold2GameResultExtraInfo> Parser { get { return _parser; } }

    private static readonly pbc::MapField<ulong, global::DragonU3DSDK.Network.API.ILProtocol.LionGold2GameResultExtraInfo.Types.LockData>.Codec _map_lockStateMap_codec
        = new pbc::MapField<ulong, global::DragonU3DSDK.Network.API.ILProtocol.LionGold2GameResultExtraInfo.Types.LockData>.Codec(pb::FieldCodec.ForUInt64(8), pb::FieldCodec.ForMessage(18, global::DragonU3DSDK.Network.API.ILProtocol.LionGold2GameResultExtraInfo.Types.LockData.Parser), 10);
    private readonly pbc::MapField<ulong, global::DragonU3DSDK.Network.API.ILProtocol.LionGold2GameResultExtraInfo.Types.LockData> lockStateMap_ = new pbc::MapField<ulong, global::DragonU3DSDK.Network.API.ILProtocol.LionGold2GameResultExtraInfo.Types.LockData>();
    /// <summary>
    /// stick wild的位置表， key是bet
    /// </summary>
    public pbc::MapField<ulong, global::DragonU3DSDK.Network.API.ILProtocol.LionGold2GameResultExtraInfo.Types.LockData> LockStateMap {
      get { return lockStateMap_; }
    }

    private global::DragonU3DSDK.Network.API.ILProtocol.LionGold2GameResultExtraInfo.Types.LinkData linkData_;
    public global::DragonU3DSDK.Network.API.ILProtocol.LionGold2GameResultExtraInfo.Types.LinkData LinkData {
      get { return linkData_; }
      set {
        linkData_ = value;
      }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      lockStateMap_.WriteTo(output, _map_lockStateMap_codec);
      if (linkData_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(LinkData);
      }
    }

    public int CalculateSize() {
      int size = 0;
      size += lockStateMap_.CalculateSize(_map_lockStateMap_codec);
      if (linkData_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(LinkData);
      }
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            lockStateMap_.AddEntriesFrom(input, _map_lockStateMap_codec);
            break;
          }
          case 18: {
            if (linkData_ == null) {
              linkData_ = new global::DragonU3DSDK.Network.API.ILProtocol.LionGold2GameResultExtraInfo.Types.LinkData();
            }
            input.ReadMessage(linkData_);
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the LionGold2GameResultExtraInfo message type.</summary>
    public static class Types {
      public sealed class LockData : pb::IMessage {
        private static readonly pb::MessageParser<LockData> _parser = new pb::MessageParser<LockData>(() => new LockData());
        public static pb::MessageParser<LockData> Parser { get { return _parser; } }

        private static readonly pb::FieldCodec<global::DragonU3DSDK.Network.API.ILProtocol.LionGold2GameResultExtraInfo.Types.LockData.Types.Item> _repeated_items_codec
            = pb::FieldCodec.ForMessage(10, global::DragonU3DSDK.Network.API.ILProtocol.LionGold2GameResultExtraInfo.Types.LockData.Types.Item.Parser);
        private readonly pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.LionGold2GameResultExtraInfo.Types.LockData.Types.Item> items_ = new pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.LionGold2GameResultExtraInfo.Types.LockData.Types.Item>();
        /// <summary>
        /// 框的位置
        /// </summary>
        public pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.LionGold2GameResultExtraInfo.Types.LockData.Types.Item> Items {
          get { return items_; }
        }

        private global::DragonU3DSDK.Network.API.ILProtocol.LionGold2GameResultExtraInfo.Types.LockData.Types.ItemDiff startDiff_;
        /// <summary>
        /// 开始触发的框
        /// </summary>
        public global::DragonU3DSDK.Network.API.ILProtocol.LionGold2GameResultExtraInfo.Types.LockData.Types.ItemDiff StartDiff {
          get { return startDiff_; }
          set {
            startDiff_ = value;
          }
        }

        private global::DragonU3DSDK.Network.API.ILProtocol.LionGold2GameResultExtraInfo.Types.LockData.Types.ItemDiff panelDiff_;
        /// <summary>
        /// panel龙头触发的框
        /// </summary>
        public global::DragonU3DSDK.Network.API.ILProtocol.LionGold2GameResultExtraInfo.Types.LockData.Types.ItemDiff PanelDiff {
          get { return panelDiff_; }
          set {
            panelDiff_ = value;
          }
        }

        private static readonly pb::FieldCodec<global::DragonU3DSDK.Network.API.ILProtocol.LionGold2GameResultExtraInfo.Types.LockData.Types.ItemDiff> _repeated_featureDiffs_codec
            = pb::FieldCodec.ForMessage(34, global::DragonU3DSDK.Network.API.ILProtocol.LionGold2GameResultExtraInfo.Types.LockData.Types.ItemDiff.Parser);
        private readonly pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.LionGold2GameResultExtraInfo.Types.LockData.Types.ItemDiff> featureDiffs_ = new pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.LionGold2GameResultExtraInfo.Types.LockData.Types.ItemDiff>();
        /// <summary>
        /// feature促发的龙头
        /// </summary>
        public pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.LionGold2GameResultExtraInfo.Types.LockData.Types.ItemDiff> FeatureDiffs {
          get { return featureDiffs_; }
        }

        private bool isOver_;
        /// <summary>
        /// 此次返回之后，item数据作废，在下一把重新开始
        /// </summary>
        public bool IsOver {
          get { return isOver_; }
          set {
            isOver_ = value;
          }
        }

        private bool isTrigger_;
        /// <summary>
        /// 此次是龙头结算
        /// </summary>
        public bool IsTrigger {
          get { return isTrigger_; }
          set {
            isTrigger_ = value;
          }
        }

        private static readonly pb::FieldCodec<global::DragonU3DSDK.Network.API.ILProtocol.LionGold2GameResultExtraInfo.Types.LockData.Types.Item> _repeated_triggeringItems_codec
            = pb::FieldCodec.ForMessage(58, global::DragonU3DSDK.Network.API.ILProtocol.LionGold2GameResultExtraInfo.Types.LockData.Types.Item.Parser);
        private readonly pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.LionGold2GameResultExtraInfo.Types.LockData.Types.Item> triggeringItems_ = new pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.LionGold2GameResultExtraInfo.Types.LockData.Types.Item>();
        /// <summary>
        /// 龙头结算事先变成的wild的items
        /// </summary>
        public pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.LionGold2GameResultExtraInfo.Types.LockData.Types.Item> TriggeringItems {
          get { return triggeringItems_; }
        }

        public void WriteTo(pb::CodedOutputStream output) {
          items_.WriteTo(output, _repeated_items_codec);
          if (startDiff_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(StartDiff);
          }
          if (panelDiff_ != null) {
            output.WriteRawTag(26);
            output.WriteMessage(PanelDiff);
          }
          featureDiffs_.WriteTo(output, _repeated_featureDiffs_codec);
          if (IsOver != false) {
            output.WriteRawTag(40);
            output.WriteBool(IsOver);
          }
          if (IsTrigger != false) {
            output.WriteRawTag(48);
            output.WriteBool(IsTrigger);
          }
          triggeringItems_.WriteTo(output, _repeated_triggeringItems_codec);
        }

        public int CalculateSize() {
          int size = 0;
          size += items_.CalculateSize(_repeated_items_codec);
          if (startDiff_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(StartDiff);
          }
          if (panelDiff_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(PanelDiff);
          }
          size += featureDiffs_.CalculateSize(_repeated_featureDiffs_codec);
          if (IsOver != false) {
            size += 1 + 1;
          }
          if (IsTrigger != false) {
            size += 1 + 1;
          }
          size += triggeringItems_.CalculateSize(_repeated_triggeringItems_codec);
          return size;
        }

        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                input.SkipLastField();
                break;
              case 10: {
                items_.AddEntriesFrom(input, _repeated_items_codec);
                break;
              }
              case 18: {
                if (startDiff_ == null) {
                  startDiff_ = new global::DragonU3DSDK.Network.API.ILProtocol.LionGold2GameResultExtraInfo.Types.LockData.Types.ItemDiff();
                }
                input.ReadMessage(startDiff_);
                break;
              }
              case 26: {
                if (panelDiff_ == null) {
                  panelDiff_ = new global::DragonU3DSDK.Network.API.ILProtocol.LionGold2GameResultExtraInfo.Types.LockData.Types.ItemDiff();
                }
                input.ReadMessage(panelDiff_);
                break;
              }
              case 34: {
                featureDiffs_.AddEntriesFrom(input, _repeated_featureDiffs_codec);
                break;
              }
              case 40: {
                IsOver = input.ReadBool();
                break;
              }
              case 48: {
                IsTrigger = input.ReadBool();
                break;
              }
              case 58: {
                triggeringItems_.AddEntriesFrom(input, _repeated_triggeringItems_codec);
                break;
              }
            }
          }
        }

        #region Nested types
        /// <summary>Container for nested types declared in the LockData message type.</summary>
        public static class Types {
          public sealed class Item : pb::IMessage {
            private static readonly pb::MessageParser<Item> _parser = new pb::MessageParser<Item>(() => new Item());
            public static pb::MessageParser<Item> Parser { get { return _parser; } }

            private uint x_;
            /// <summary>
            /// 位置x
            /// </summary>
            public uint X {
              get { return x_; }
              set {
                x_ = value;
              }
            }

            private uint y_;
            /// <summary>
            /// 位置y
            /// </summary>
            public uint Y {
              get { return y_; }
              set {
                y_ = value;
              }
            }

            private uint colour_;
            /// <summary>
            /// 颜色， 0无，1红色，2绿色
            /// </summary>
            public uint Colour {
              get { return colour_; }
              set {
                colour_ = value;
              }
            }

            public void WriteTo(pb::CodedOutputStream output) {
              if (X != 0) {
                output.WriteRawTag(8);
                output.WriteUInt32(X);
              }
              if (Y != 0) {
                output.WriteRawTag(16);
                output.WriteUInt32(Y);
              }
              if (Colour != 0) {
                output.WriteRawTag(24);
                output.WriteUInt32(Colour);
              }
            }

            public int CalculateSize() {
              int size = 0;
              if (X != 0) {
                size += 1 + pb::CodedOutputStream.ComputeUInt32Size(X);
              }
              if (Y != 0) {
                size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Y);
              }
              if (Colour != 0) {
                size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Colour);
              }
              return size;
            }

            public void MergeFrom(pb::CodedInputStream input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    input.SkipLastField();
                    break;
                  case 8: {
                    X = input.ReadUInt32();
                    break;
                  }
                  case 16: {
                    Y = input.ReadUInt32();
                    break;
                  }
                  case 24: {
                    Colour = input.ReadUInt32();
                    break;
                  }
                }
              }
            }

          }

          public sealed class ItemDiff : pb::IMessage {
            private static readonly pb::MessageParser<ItemDiff> _parser = new pb::MessageParser<ItemDiff>(() => new ItemDiff());
            public static pb::MessageParser<ItemDiff> Parser { get { return _parser; } }

            private static readonly pb::FieldCodec<global::DragonU3DSDK.Network.API.ILProtocol.LionGold2GameResultExtraInfo.Types.LockData.Types.Item> _repeated_items_codec
                = pb::FieldCodec.ForMessage(10, global::DragonU3DSDK.Network.API.ILProtocol.LionGold2GameResultExtraInfo.Types.LockData.Types.Item.Parser);
            private readonly pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.LionGold2GameResultExtraInfo.Types.LockData.Types.Item> items_ = new pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.LionGold2GameResultExtraInfo.Types.LockData.Types.Item>();
            public pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.LionGold2GameResultExtraInfo.Types.LockData.Types.Item> Items {
              get { return items_; }
            }

            public void WriteTo(pb::CodedOutputStream output) {
              items_.WriteTo(output, _repeated_items_codec);
            }

            public int CalculateSize() {
              int size = 0;
              size += items_.CalculateSize(_repeated_items_codec);
              return size;
            }

            public void MergeFrom(pb::CodedInputStream input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    input.SkipLastField();
                    break;
                  case 10: {
                    items_.AddEntriesFrom(input, _repeated_items_codec);
                    break;
                  }
                }
              }
            }

          }

        }
        #endregion

      }

      public sealed class LinkData : pb::IMessage {
        private static readonly pb::MessageParser<LinkData> _parser = new pb::MessageParser<LinkData>(() => new LinkData());
        public static pb::MessageParser<LinkData> Parser { get { return _parser; } }

        private static readonly pb::FieldCodec<global::DragonU3DSDK.Network.API.ILProtocol.LionGold2GameResultExtraInfo.Types.LinkData.Types.Item> _repeated_items_codec
            = pb::FieldCodec.ForMessage(10, global::DragonU3DSDK.Network.API.ILProtocol.LionGold2GameResultExtraInfo.Types.LinkData.Types.Item.Parser);
        private readonly pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.LionGold2GameResultExtraInfo.Types.LinkData.Types.Item> items_ = new pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.LionGold2GameResultExtraInfo.Types.LinkData.Types.Item>();
        /// <summary>
        /// link数据
        /// </summary>
        public pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.LionGold2GameResultExtraInfo.Types.LinkData.Types.Item> Items {
          get { return items_; }
        }

        private ulong grandJackpot_;
        /// <summary>
        /// grandJackpot的win rate，没中是0
        /// </summary>
        public ulong GrandJackpot {
          get { return grandJackpot_; }
          set {
            grandJackpot_ = value;
          }
        }

        private static readonly pb::FieldCodec<global::DragonU3DSDK.Network.API.ILProtocol.LionGold2GameResultExtraInfo.Types.LinkData.Types.Item> _repeated_dragonTriggeringItems_codec
            = pb::FieldCodec.ForMessage(26, global::DragonU3DSDK.Network.API.ILProtocol.LionGold2GameResultExtraInfo.Types.LinkData.Types.Item.Parser);
        private readonly pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.LionGold2GameResultExtraInfo.Types.LinkData.Types.Item> dragonTriggeringItems_ = new pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.LionGold2GameResultExtraInfo.Types.LinkData.Types.Item>();
        /// <summary>
        /// 来自龙头结算中变绿的items
        /// </summary>
        public pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.LionGold2GameResultExtraInfo.Types.LinkData.Types.Item> DragonTriggeringItems {
          get { return dragonTriggeringItems_; }
        }

        public void WriteTo(pb::CodedOutputStream output) {
          items_.WriteTo(output, _repeated_items_codec);
          if (GrandJackpot != 0UL) {
            output.WriteRawTag(16);
            output.WriteUInt64(GrandJackpot);
          }
          dragonTriggeringItems_.WriteTo(output, _repeated_dragonTriggeringItems_codec);
        }

        public int CalculateSize() {
          int size = 0;
          size += items_.CalculateSize(_repeated_items_codec);
          if (GrandJackpot != 0UL) {
            size += 1 + pb::CodedOutputStream.ComputeUInt64Size(GrandJackpot);
          }
          size += dragonTriggeringItems_.CalculateSize(_repeated_dragonTriggeringItems_codec);
          return size;
        }

        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                input.SkipLastField();
                break;
              case 10: {
                items_.AddEntriesFrom(input, _repeated_items_codec);
                break;
              }
              case 16: {
                GrandJackpot = input.ReadUInt64();
                break;
              }
              case 26: {
                dragonTriggeringItems_.AddEntriesFrom(input, _repeated_dragonTriggeringItems_codec);
                break;
              }
            }
          }
        }

        #region Nested types
        /// <summary>Container for nested types declared in the LinkData message type.</summary>
        public static class Types {
          public sealed class Item : pb::IMessage {
            private static readonly pb::MessageParser<Item> _parser = new pb::MessageParser<Item>(() => new Item());
            public static pb::MessageParser<Item> Parser { get { return _parser; } }

            private uint positionId_;
            /// <summary>
            /// 位置
            /// </summary>
            public uint PositionId {
              get { return positionId_; }
              set {
                positionId_ = value;
              }
            }

            private uint symbolId_;
            /// <summary>
            /// 现实图标
            /// </summary>
            public uint SymbolId {
              get { return symbolId_; }
              set {
                symbolId_ = value;
              }
            }

            private ulong winRate_;
            /// <summary>
            /// 赢钱倍率
            /// </summary>
            public ulong WinRate {
              get { return winRate_; }
              set {
                winRate_ = value;
              }
            }

            private uint jackpotId_;
            /// <summary>
            /// jackpotId
            /// </summary>
            public uint JackpotId {
              get { return jackpotId_; }
              set {
                jackpotId_ = value;
              }
            }

            private ulong jackpotPay_;
            /// <summary>
            /// jackpot倍率
            /// </summary>
            public ulong JackpotPay {
              get { return jackpotPay_; }
              set {
                jackpotPay_ = value;
              }
            }

            public void WriteTo(pb::CodedOutputStream output) {
              if (PositionId != 0) {
                output.WriteRawTag(8);
                output.WriteUInt32(PositionId);
              }
              if (SymbolId != 0) {
                output.WriteRawTag(16);
                output.WriteUInt32(SymbolId);
              }
              if (WinRate != 0UL) {
                output.WriteRawTag(24);
                output.WriteUInt64(WinRate);
              }
              if (JackpotId != 0) {
                output.WriteRawTag(32);
                output.WriteUInt32(JackpotId);
              }
              if (JackpotPay != 0UL) {
                output.WriteRawTag(40);
                output.WriteUInt64(JackpotPay);
              }
            }

            public int CalculateSize() {
              int size = 0;
              if (PositionId != 0) {
                size += 1 + pb::CodedOutputStream.ComputeUInt32Size(PositionId);
              }
              if (SymbolId != 0) {
                size += 1 + pb::CodedOutputStream.ComputeUInt32Size(SymbolId);
              }
              if (WinRate != 0UL) {
                size += 1 + pb::CodedOutputStream.ComputeUInt64Size(WinRate);
              }
              if (JackpotId != 0) {
                size += 1 + pb::CodedOutputStream.ComputeUInt32Size(JackpotId);
              }
              if (JackpotPay != 0UL) {
                size += 1 + pb::CodedOutputStream.ComputeUInt64Size(JackpotPay);
              }
              return size;
            }

            public void MergeFrom(pb::CodedInputStream input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    input.SkipLastField();
                    break;
                  case 8: {
                    PositionId = input.ReadUInt32();
                    break;
                  }
                  case 16: {
                    SymbolId = input.ReadUInt32();
                    break;
                  }
                  case 24: {
                    WinRate = input.ReadUInt64();
                    break;
                  }
                  case 32: {
                    JackpotId = input.ReadUInt32();
                    break;
                  }
                  case 40: {
                    JackpotPay = input.ReadUInt64();
                    break;
                  }
                }
              }
            }

          }

        }
        #endregion

      }

    }
    #endregion

  }

  /// <summary>
  ///*======================== FireLinkByTheBay2 ============================*/
  /// </summary>
  public sealed class FireLinkByTheBay2GameResultExtraInfo : pb::IMessage {
    private static readonly pb::MessageParser<FireLinkByTheBay2GameResultExtraInfo> _parser = new pb::MessageParser<FireLinkByTheBay2GameResultExtraInfo>(() => new FireLinkByTheBay2GameResultExtraInfo());
    public static pb::MessageParser<FireLinkByTheBay2GameResultExtraInfo> Parser { get { return _parser; } }

    private uint pepperCount_;
    /// <summary>
    /// 辣椒数量； 看情况需不需要添加old_pepper_count
    /// </summary>
    public uint PepperCount {
      get { return pepperCount_; }
      set {
        pepperCount_ = value;
      }
    }

    private uint linkHeight_;
    /// <summary>
    ///link玩法解锁那高度 普通一开始是4，最高8。每一级提升需要的辣椒数分别是 8, 12, 16, 20; 看情况需不需要添加old_link_height；
    /// </summary>
    public uint LinkHeight {
      get { return linkHeight_; }
      set {
        linkHeight_ = value;
      }
    }

    private global::DragonU3DSDK.Network.API.ILProtocol.FireLinkByTheBay2GameResultExtraInfo.Types.LinkData linkData_;
    /// <summary>
    /// link数据，positionId从0到39
    /// </summary>
    public global::DragonU3DSDK.Network.API.ILProtocol.FireLinkByTheBay2GameResultExtraInfo.Types.LinkData LinkData {
      get { return linkData_; }
      set {
        linkData_ = value;
      }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (PepperCount != 0) {
        output.WriteRawTag(8);
        output.WriteUInt32(PepperCount);
      }
      if (LinkHeight != 0) {
        output.WriteRawTag(16);
        output.WriteUInt32(LinkHeight);
      }
      if (linkData_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(LinkData);
      }
    }

    public int CalculateSize() {
      int size = 0;
      if (PepperCount != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(PepperCount);
      }
      if (LinkHeight != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(LinkHeight);
      }
      if (linkData_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(LinkData);
      }
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            PepperCount = input.ReadUInt32();
            break;
          }
          case 16: {
            LinkHeight = input.ReadUInt32();
            break;
          }
          case 26: {
            if (linkData_ == null) {
              linkData_ = new global::DragonU3DSDK.Network.API.ILProtocol.FireLinkByTheBay2GameResultExtraInfo.Types.LinkData();
            }
            input.ReadMessage(linkData_);
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the FireLinkByTheBay2GameResultExtraInfo message type.</summary>
    public static class Types {
      public sealed class LinkData : pb::IMessage {
        private static readonly pb::MessageParser<LinkData> _parser = new pb::MessageParser<LinkData>(() => new LinkData());
        public static pb::MessageParser<LinkData> Parser { get { return _parser; } }

        private static readonly pb::FieldCodec<global::DragonU3DSDK.Network.API.ILProtocol.FireLinkByTheBay2GameResultExtraInfo.Types.LinkData.Types.Item> _repeated_items_codec
            = pb::FieldCodec.ForMessage(10, global::DragonU3DSDK.Network.API.ILProtocol.FireLinkByTheBay2GameResultExtraInfo.Types.LinkData.Types.Item.Parser);
        private readonly pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.FireLinkByTheBay2GameResultExtraInfo.Types.LinkData.Types.Item> items_ = new pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.FireLinkByTheBay2GameResultExtraInfo.Types.LinkData.Types.Item>();
        public pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.FireLinkByTheBay2GameResultExtraInfo.Types.LinkData.Types.Item> Items {
          get { return items_; }
        }

        private static readonly pbc::MapField<uint, uint>.Codec _map_reelMapping_codec
            = new pbc::MapField<uint, uint>.Codec(pb::FieldCodec.ForUInt32(8), pb::FieldCodec.ForUInt32(16), 18);
        private readonly pbc::MapField<uint, uint> reelMapping_ = new pbc::MapField<uint, uint>();
        /// <summary>
        /// linkReels轴映射
        /// </summary>
        public pbc::MapField<uint, uint> ReelMapping {
          get { return reelMapping_; }
        }

        public void WriteTo(pb::CodedOutputStream output) {
          items_.WriteTo(output, _repeated_items_codec);
          reelMapping_.WriteTo(output, _map_reelMapping_codec);
        }

        public int CalculateSize() {
          int size = 0;
          size += items_.CalculateSize(_repeated_items_codec);
          size += reelMapping_.CalculateSize(_map_reelMapping_codec);
          return size;
        }

        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                input.SkipLastField();
                break;
              case 10: {
                items_.AddEntriesFrom(input, _repeated_items_codec);
                break;
              }
              case 18: {
                reelMapping_.AddEntriesFrom(input, _map_reelMapping_codec);
                break;
              }
            }
          }
        }

        #region Nested types
        /// <summary>Container for nested types declared in the LinkData message type.</summary>
        public static class Types {
          public sealed class Item : pb::IMessage {
            private static readonly pb::MessageParser<Item> _parser = new pb::MessageParser<Item>(() => new Item());
            public static pb::MessageParser<Item> Parser { get { return _parser; } }

            private uint positionId_;
            /// <summary>
            /// 位置
            /// </summary>
            public uint PositionId {
              get { return positionId_; }
              set {
                positionId_ = value;
              }
            }

            private uint symbolId_;
            /// <summary>
            /// 现实图标
            /// </summary>
            public uint SymbolId {
              get { return symbolId_; }
              set {
                symbolId_ = value;
              }
            }

            private ulong winRate_;
            /// <summary>
            /// 赢钱倍率
            /// </summary>
            public ulong WinRate {
              get { return winRate_; }
              set {
                winRate_ = value;
              }
            }

            private uint jackpotId_;
            /// <summary>
            /// jackpot id
            /// </summary>
            public uint JackpotId {
              get { return jackpotId_; }
              set {
                jackpotId_ = value;
              }
            }

            private ulong jackpotPay_;
            /// <summary>
            /// jackpot pay
            /// </summary>
            public ulong JackpotPay {
              get { return jackpotPay_; }
              set {
                jackpotPay_ = value;
              }
            }

            public void WriteTo(pb::CodedOutputStream output) {
              if (PositionId != 0) {
                output.WriteRawTag(8);
                output.WriteUInt32(PositionId);
              }
              if (SymbolId != 0) {
                output.WriteRawTag(16);
                output.WriteUInt32(SymbolId);
              }
              if (WinRate != 0UL) {
                output.WriteRawTag(24);
                output.WriteUInt64(WinRate);
              }
              if (JackpotId != 0) {
                output.WriteRawTag(32);
                output.WriteUInt32(JackpotId);
              }
              if (JackpotPay != 0UL) {
                output.WriteRawTag(40);
                output.WriteUInt64(JackpotPay);
              }
            }

            public int CalculateSize() {
              int size = 0;
              if (PositionId != 0) {
                size += 1 + pb::CodedOutputStream.ComputeUInt32Size(PositionId);
              }
              if (SymbolId != 0) {
                size += 1 + pb::CodedOutputStream.ComputeUInt32Size(SymbolId);
              }
              if (WinRate != 0UL) {
                size += 1 + pb::CodedOutputStream.ComputeUInt64Size(WinRate);
              }
              if (JackpotId != 0) {
                size += 1 + pb::CodedOutputStream.ComputeUInt32Size(JackpotId);
              }
              if (JackpotPay != 0UL) {
                size += 1 + pb::CodedOutputStream.ComputeUInt64Size(JackpotPay);
              }
              return size;
            }

            public void MergeFrom(pb::CodedInputStream input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    input.SkipLastField();
                    break;
                  case 8: {
                    PositionId = input.ReadUInt32();
                    break;
                  }
                  case 16: {
                    SymbolId = input.ReadUInt32();
                    break;
                  }
                  case 24: {
                    WinRate = input.ReadUInt64();
                    break;
                  }
                  case 32: {
                    JackpotId = input.ReadUInt32();
                    break;
                  }
                  case 40: {
                    JackpotPay = input.ReadUInt64();
                    break;
                  }
                }
              }
            }

          }

        }
        #endregion

      }

    }
    #endregion

  }

  /// <summary>
  /// *====================================== GoldRushTrain2 ========================================= *//
  ///
  /// train feature主要火车数据在trains中，每次bonus_process让一个火车跑出结果； 如果有金火车，它会在trains中的最后一个
  /// 当train feature所有train.over=true后要结算，发settle_api
  /// 注意如果一个火车都没有（只有数字奖和星星），也会进入train feature bonus, 并直接发settle_api结算
  ///
  /// 如果同时触发train feature和2选1， train feature的settle api返回之后会进入2选1；
  /// 2选1的参数和11011一样，靠json字段有无，有json进入train feature
  /// 2选一的train feature进入之后会用bonus_process api来得到触发panel,再进行正常train feature；（之前王剑商量确定这么处理）
  ///
  /// 注意isTrain=true &amp;&amp; is_panel_ready=false时断线重连，返回的gameResult.panels是chooseTriggeringPanels(可以商量怎么处理)
  /// isTrain=true &amp;&amp; is_panel_ready=true时断线重连，返回的gameResult.panels是trainTriggeringPanels
  ///
  /// free中会触发进入reSpin状态（之前王剑商量确定这么处理），会reSpin一次或两次；
  ///
  /// 几种特殊赢钱线：（具体id是否超过1000可以商量）
  /// scatter触发2选一的winLine.bonusGameId = 101
  /// 触发train的winLine.bonusGameId = 201;（base中会有，2选一train feature第一下会有）
  /// </summary>
  public sealed class GoldRushTrain2GameResultExtraInfo : pb::IMessage {
    private static readonly pb::MessageParser<GoldRushTrain2GameResultExtraInfo> _parser = new pb::MessageParser<GoldRushTrain2GameResultExtraInfo>(() => new GoldRushTrain2GameResultExtraInfo());
    public static pb::MessageParser<GoldRushTrain2GameResultExtraInfo> Parser { get { return _parser; } }

    private bool chosen_;
    /// <summary>
    /// choose related
    /// </summary>
    public bool Chosen {
      get { return chosen_; }
      set {
        chosen_ = value;
      }
    }

    private uint freeSpinCount_;
    /// <summary>
    /// 2选一的时候 free显示几次
    /// </summary>
    public uint FreeSpinCount {
      get { return freeSpinCount_; }
      set {
        freeSpinCount_ = value;
      }
    }

    private static readonly pb::FieldCodec<global::DragonU3DSDK.Network.API.ILProtocol.GoldRushTrain2GameResultExtraInfo.Types.StickyColumn> _repeated_stickyColumns_codec
        = pb::FieldCodec.ForMessage(26, global::DragonU3DSDK.Network.API.ILProtocol.GoldRushTrain2GameResultExtraInfo.Types.StickyColumn.Parser);
    private readonly pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.GoldRushTrain2GameResultExtraInfo.Types.StickyColumn> stickyColumns_ = new pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.GoldRushTrain2GameResultExtraInfo.Types.StickyColumn>();
    /// <summary>
    /// free中触发reSpin的sticky columns
    /// </summary>
    public pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.GoldRushTrain2GameResultExtraInfo.Types.StickyColumn> StickyColumns {
      get { return stickyColumns_; }
    }

    private bool isTrain_;
    /// <summary>
    /// train feature related
    /// </summary>
    public bool IsTrain {
      get { return isTrain_; }
      set {
        isTrain_ = value;
      }
    }

    private bool isChosenTrain_;
    /// <summary>
    /// train feature是否是2选一触发的
    /// </summary>
    public bool IsChosenTrain {
      get { return isChosenTrain_; }
      set {
        isChosenTrain_ = value;
      }
    }

    private bool isPanelReady_;
    /// <summary>
    /// 如果是is_chosen_train==true, 它表示第一下触发panel是否已经转出来了
    /// </summary>
    public bool IsPanelReady {
      get { return isPanelReady_; }
      set {
        isPanelReady_ = value;
      }
    }

    private ulong winLinePay_;
    /// <summary>
    /// 火车赢钱线的奖励累积，是winRate； 如果有金火车加倍它会是加倍之前的值；它包换数字奖和非金火车奖
    /// </summary>
    public ulong WinLinePay {
      get { return winLinePay_; }
      set {
        winLinePay_ = value;
      }
    }

    private static readonly pb::FieldCodec<global::DragonU3DSDK.Network.API.ILProtocol.GoldRushTrain2GameResultExtraInfo.Types.Train> _repeated_trains_codec
        = pb::FieldCodec.ForMessage(66, global::DragonU3DSDK.Network.API.ILProtocol.GoldRushTrain2GameResultExtraInfo.Types.Train.Parser);
    private readonly pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.GoldRushTrain2GameResultExtraInfo.Types.Train> trains_ = new pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.GoldRushTrain2GameResultExtraInfo.Types.Train>();
    /// <summary>
    /// 火车数据
    /// </summary>
    public pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.GoldRushTrain2GameResultExtraInfo.Types.Train> Trains {
      get { return trains_; }
    }

    private static readonly pb::FieldCodec<global::DragonU3DSDK.Network.API.ILProtocol.Panel> _repeated_chooseTriggeringPanels_codec
        = pb::FieldCodec.ForMessage(74, global::DragonU3DSDK.Network.API.ILProtocol.Panel.Parser);
    private readonly pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.Panel> chooseTriggeringPanels_ = new pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.Panel>();
    /// <summary>
    /// 2选1的触发panels
    /// </summary>
    public pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.Panel> ChooseTriggeringPanels {
      get { return chooseTriggeringPanels_; }
    }

    private static readonly pb::FieldCodec<global::DragonU3DSDK.Network.API.ILProtocol.Panel> _repeated_trainTriggeringPanels_codec
        = pb::FieldCodec.ForMessage(82, global::DragonU3DSDK.Network.API.ILProtocol.Panel.Parser);
    private readonly pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.Panel> trainTriggeringPanels_ = new pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.Panel>();
    /// <summary>
    /// train feature bonus的触发panels
    /// </summary>
    public pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.Panel> TrainTriggeringPanels {
      get { return trainTriggeringPanels_; }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (Chosen != false) {
        output.WriteRawTag(8);
        output.WriteBool(Chosen);
      }
      if (FreeSpinCount != 0) {
        output.WriteRawTag(16);
        output.WriteUInt32(FreeSpinCount);
      }
      stickyColumns_.WriteTo(output, _repeated_stickyColumns_codec);
      if (IsTrain != false) {
        output.WriteRawTag(32);
        output.WriteBool(IsTrain);
      }
      if (IsChosenTrain != false) {
        output.WriteRawTag(40);
        output.WriteBool(IsChosenTrain);
      }
      if (IsPanelReady != false) {
        output.WriteRawTag(48);
        output.WriteBool(IsPanelReady);
      }
      if (WinLinePay != 0UL) {
        output.WriteRawTag(56);
        output.WriteUInt64(WinLinePay);
      }
      trains_.WriteTo(output, _repeated_trains_codec);
      chooseTriggeringPanels_.WriteTo(output, _repeated_chooseTriggeringPanels_codec);
      trainTriggeringPanels_.WriteTo(output, _repeated_trainTriggeringPanels_codec);
    }

    public int CalculateSize() {
      int size = 0;
      if (Chosen != false) {
        size += 1 + 1;
      }
      if (FreeSpinCount != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(FreeSpinCount);
      }
      size += stickyColumns_.CalculateSize(_repeated_stickyColumns_codec);
      if (IsTrain != false) {
        size += 1 + 1;
      }
      if (IsChosenTrain != false) {
        size += 1 + 1;
      }
      if (IsPanelReady != false) {
        size += 1 + 1;
      }
      if (WinLinePay != 0UL) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(WinLinePay);
      }
      size += trains_.CalculateSize(_repeated_trains_codec);
      size += chooseTriggeringPanels_.CalculateSize(_repeated_chooseTriggeringPanels_codec);
      size += trainTriggeringPanels_.CalculateSize(_repeated_trainTriggeringPanels_codec);
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            Chosen = input.ReadBool();
            break;
          }
          case 16: {
            FreeSpinCount = input.ReadUInt32();
            break;
          }
          case 26: {
            stickyColumns_.AddEntriesFrom(input, _repeated_stickyColumns_codec);
            break;
          }
          case 32: {
            IsTrain = input.ReadBool();
            break;
          }
          case 40: {
            IsChosenTrain = input.ReadBool();
            break;
          }
          case 48: {
            IsPanelReady = input.ReadBool();
            break;
          }
          case 56: {
            WinLinePay = input.ReadUInt64();
            break;
          }
          case 66: {
            trains_.AddEntriesFrom(input, _repeated_trains_codec);
            break;
          }
          case 74: {
            chooseTriggeringPanels_.AddEntriesFrom(input, _repeated_chooseTriggeringPanels_codec);
            break;
          }
          case 82: {
            trainTriggeringPanels_.AddEntriesFrom(input, _repeated_trainTriggeringPanels_codec);
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the GoldRushTrain2GameResultExtraInfo message type.</summary>
    public static class Types {
      /// <summary>
      /// free related
      /// </summary>
      public sealed class StickyColumn : pb::IMessage {
        private static readonly pb::MessageParser<StickyColumn> _parser = new pb::MessageParser<StickyColumn>(() => new StickyColumn());
        public static pb::MessageParser<StickyColumn> Parser { get { return _parser; } }

        private uint x_;
        /// <summary>
        /// x轴
        /// </summary>
        public uint X {
          get { return x_; }
          set {
            x_ = value;
          }
        }

        private static readonly pb::FieldCodec<uint> _repeated_symbols_codec
            = pb::FieldCodec.ForUInt32(18);
        private readonly pbc::RepeatedField<uint> symbols_ = new pbc::RepeatedField<uint>();
        /// <summary>
        /// symbol ids
        /// </summary>
        public pbc::RepeatedField<uint> Symbols {
          get { return symbols_; }
        }

        public void WriteTo(pb::CodedOutputStream output) {
          if (X != 0) {
            output.WriteRawTag(8);
            output.WriteUInt32(X);
          }
          symbols_.WriteTo(output, _repeated_symbols_codec);
        }

        public int CalculateSize() {
          int size = 0;
          if (X != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(X);
          }
          size += symbols_.CalculateSize(_repeated_symbols_codec);
          return size;
        }

        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                input.SkipLastField();
                break;
              case 8: {
                X = input.ReadUInt32();
                break;
              }
              case 18:
              case 16: {
                symbols_.AddEntriesFrom(input, _repeated_symbols_codec);
                break;
              }
            }
          }
        }

      }

      public sealed class Train : pb::IMessage {
        private static readonly pb::MessageParser<Train> _parser = new pb::MessageParser<Train>(() => new Train());
        public static pb::MessageParser<Train> Parser { get { return _parser; } }

        private bool over_;
        /// <summary>
        /// train结果是否跑完
        /// </summary>
        public bool Over {
          get { return over_; }
          set {
            over_ = value;
          }
        }

        private uint id_;
        /// <summary>
        /// train的SymbolId, 靠它分辨是颜色的火车
        /// </summary>
        public uint Id {
          get { return id_; }
          set {
            id_ = value;
          }
        }

        private uint x_;
        /// <summary>
        /// panel上的位置x
        /// </summary>
        public uint X {
          get { return x_; }
          set {
            x_ = value;
          }
        }

        private uint y_;
        /// <summary>
        /// panel上的位置y
        /// </summary>
        public uint Y {
          get { return y_; }
          set {
            y_ = value;
          }
        }

        private static readonly pb::FieldCodec<global::DragonU3DSDK.Network.API.ILProtocol.GoldRushTrain2GameResultExtraInfo.Types.Train.Types.Result> _repeated_results_codec
            = pb::FieldCodec.ForMessage(42, global::DragonU3DSDK.Network.API.ILProtocol.GoldRushTrain2GameResultExtraInfo.Types.Train.Types.Result.Parser);
        private readonly pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.GoldRushTrain2GameResultExtraInfo.Types.Train.Types.Result> results_ = new pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.GoldRushTrain2GameResultExtraInfo.Types.Train.Types.Result>();
        /// <summary>
        /// 火车箱结果
        /// </summary>
        public pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.GoldRushTrain2GameResultExtraInfo.Types.Train.Types.Result> Results {
          get { return results_; }
        }

        private ulong totalWinRate_;
        /// <summary>
        /// 火车总winRate
        /// </summary>
        public ulong TotalWinRate {
          get { return totalWinRate_; }
          set {
            totalWinRate_ = value;
          }
        }

        public void WriteTo(pb::CodedOutputStream output) {
          if (Over != false) {
            output.WriteRawTag(8);
            output.WriteBool(Over);
          }
          if (Id != 0) {
            output.WriteRawTag(16);
            output.WriteUInt32(Id);
          }
          if (X != 0) {
            output.WriteRawTag(24);
            output.WriteUInt32(X);
          }
          if (Y != 0) {
            output.WriteRawTag(32);
            output.WriteUInt32(Y);
          }
          results_.WriteTo(output, _repeated_results_codec);
          if (TotalWinRate != 0UL) {
            output.WriteRawTag(48);
            output.WriteUInt64(TotalWinRate);
          }
        }

        public int CalculateSize() {
          int size = 0;
          if (Over != false) {
            size += 1 + 1;
          }
          if (Id != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Id);
          }
          if (X != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(X);
          }
          if (Y != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Y);
          }
          size += results_.CalculateSize(_repeated_results_codec);
          if (TotalWinRate != 0UL) {
            size += 1 + pb::CodedOutputStream.ComputeUInt64Size(TotalWinRate);
          }
          return size;
        }

        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                input.SkipLastField();
                break;
              case 8: {
                Over = input.ReadBool();
                break;
              }
              case 16: {
                Id = input.ReadUInt32();
                break;
              }
              case 24: {
                X = input.ReadUInt32();
                break;
              }
              case 32: {
                Y = input.ReadUInt32();
                break;
              }
              case 42: {
                results_.AddEntriesFrom(input, _repeated_results_codec);
                break;
              }
              case 48: {
                TotalWinRate = input.ReadUInt64();
                break;
              }
            }
          }
        }

        #region Nested types
        /// <summary>Container for nested types declared in the Train message type.</summary>
        public static class Types {
          public sealed class Result : pb::IMessage {
            private static readonly pb::MessageParser<Result> _parser = new pb::MessageParser<Result>(() => new Result());
            public static pb::MessageParser<Result> Parser { get { return _parser; } }

            private ulong winRate_;
            public ulong WinRate {
              get { return winRate_; }
              set {
                winRate_ = value;
              }
            }

            private uint jackpotId_;
            public uint JackpotId {
              get { return jackpotId_; }
              set {
                jackpotId_ = value;
              }
            }

            private ulong jackpotPay_;
            public ulong JackpotPay {
              get { return jackpotPay_; }
              set {
                jackpotPay_ = value;
              }
            }

            public void WriteTo(pb::CodedOutputStream output) {
              if (WinRate != 0UL) {
                output.WriteRawTag(8);
                output.WriteUInt64(WinRate);
              }
              if (JackpotId != 0) {
                output.WriteRawTag(16);
                output.WriteUInt32(JackpotId);
              }
              if (JackpotPay != 0UL) {
                output.WriteRawTag(24);
                output.WriteUInt64(JackpotPay);
              }
            }

            public int CalculateSize() {
              int size = 0;
              if (WinRate != 0UL) {
                size += 1 + pb::CodedOutputStream.ComputeUInt64Size(WinRate);
              }
              if (JackpotId != 0) {
                size += 1 + pb::CodedOutputStream.ComputeUInt32Size(JackpotId);
              }
              if (JackpotPay != 0UL) {
                size += 1 + pb::CodedOutputStream.ComputeUInt64Size(JackpotPay);
              }
              return size;
            }

            public void MergeFrom(pb::CodedInputStream input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    input.SkipLastField();
                    break;
                  case 8: {
                    WinRate = input.ReadUInt64();
                    break;
                  }
                  case 16: {
                    JackpotId = input.ReadUInt32();
                    break;
                  }
                  case 24: {
                    JackpotPay = input.ReadUInt64();
                    break;
                  }
                }
              }
            }

          }

        }
        #endregion

      }

    }
    #endregion

  }

  public sealed class DevilRushGameResultExtraInfo : pb::IMessage {
    private static readonly pb::MessageParser<DevilRushGameResultExtraInfo> _parser = new pb::MessageParser<DevilRushGameResultExtraInfo>(() => new DevilRushGameResultExtraInfo());
    public static pb::MessageParser<DevilRushGameResultExtraInfo> Parser { get { return _parser; } }

    private static readonly pbc::MapField<ulong, global::DragonU3DSDK.Network.API.ILProtocol.DevilRushGameResultExtraInfo.Types.BetInfo>.Codec _map_betInfos_codec
        = new pbc::MapField<ulong, global::DragonU3DSDK.Network.API.ILProtocol.DevilRushGameResultExtraInfo.Types.BetInfo>.Codec(pb::FieldCodec.ForUInt64(8), pb::FieldCodec.ForMessage(18, global::DragonU3DSDK.Network.API.ILProtocol.DevilRushGameResultExtraInfo.Types.BetInfo.Parser), 10);
    private readonly pbc::MapField<ulong, global::DragonU3DSDK.Network.API.ILProtocol.DevilRushGameResultExtraInfo.Types.BetInfo> betInfos_ = new pbc::MapField<ulong, global::DragonU3DSDK.Network.API.ILProtocol.DevilRushGameResultExtraInfo.Types.BetInfo>();
    public pbc::MapField<ulong, global::DragonU3DSDK.Network.API.ILProtocol.DevilRushGameResultExtraInfo.Types.BetInfo> BetInfos {
      get { return betInfos_; }
    }

    private global::DragonU3DSDK.Network.API.ILProtocol.NormalReSpinExtraInfo reSpinInfo_;
    /// <summary>
    /// reSpin的基础数据
    /// </summary>
    public global::DragonU3DSDK.Network.API.ILProtocol.NormalReSpinExtraInfo ReSpinInfo {
      get { return reSpinInfo_; }
      set {
        reSpinInfo_ = value;
      }
    }

    private uint nextCollectWins_;
    /// <summary>
    /// reSpin收集值，只是winRate
    /// </summary>
    public uint NextCollectWins {
      get { return nextCollectWins_; }
      set {
        nextCollectWins_ = value;
      }
    }

    private static readonly pb::FieldCodec<ulong> _repeated_collectWins_codec
        = pb::FieldCodec.ForUInt64(34);
    private readonly pbc::RepeatedField<ulong> collectWins_ = new pbc::RepeatedField<ulong>();
    /// <summary>
    /// 本次spin收集的win
    /// </summary>
    public pbc::RepeatedField<ulong> CollectWins {
      get { return collectWins_; }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      betInfos_.WriteTo(output, _map_betInfos_codec);
      if (reSpinInfo_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(ReSpinInfo);
      }
      if (NextCollectWins != 0) {
        output.WriteRawTag(24);
        output.WriteUInt32(NextCollectWins);
      }
      collectWins_.WriteTo(output, _repeated_collectWins_codec);
    }

    public int CalculateSize() {
      int size = 0;
      size += betInfos_.CalculateSize(_map_betInfos_codec);
      if (reSpinInfo_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ReSpinInfo);
      }
      if (NextCollectWins != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(NextCollectWins);
      }
      size += collectWins_.CalculateSize(_repeated_collectWins_codec);
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            betInfos_.AddEntriesFrom(input, _map_betInfos_codec);
            break;
          }
          case 18: {
            if (reSpinInfo_ == null) {
              reSpinInfo_ = new global::DragonU3DSDK.Network.API.ILProtocol.NormalReSpinExtraInfo();
            }
            input.ReadMessage(reSpinInfo_);
            break;
          }
          case 24: {
            NextCollectWins = input.ReadUInt32();
            break;
          }
          case 34:
          case 32: {
            collectWins_.AddEntriesFrom(input, _repeated_collectWins_codec);
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the DevilRushGameResultExtraInfo message type.</summary>
    public static class Types {
      public sealed class Progress : pb::IMessage {
        private static readonly pb::MessageParser<Progress> _parser = new pb::MessageParser<Progress>(() => new Progress());
        public static pb::MessageParser<Progress> Parser { get { return _parser; } }

        private ulong collectWins_;
        /// <summary>
        /// 收集的奖励
        /// </summary>
        public ulong CollectWins {
          get { return collectWins_; }
          set {
            collectWins_ = value;
          }
        }

        private uint point_;
        /// <summary>
        /// 剩余的点数
        /// </summary>
        public uint Point {
          get { return point_; }
          set {
            point_ = value;
          }
        }

        public void WriteTo(pb::CodedOutputStream output) {
          if (CollectWins != 0UL) {
            output.WriteRawTag(8);
            output.WriteUInt64(CollectWins);
          }
          if (Point != 0) {
            output.WriteRawTag(16);
            output.WriteUInt32(Point);
          }
        }

        public int CalculateSize() {
          int size = 0;
          if (CollectWins != 0UL) {
            size += 1 + pb::CodedOutputStream.ComputeUInt64Size(CollectWins);
          }
          if (Point != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Point);
          }
          return size;
        }

        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                input.SkipLastField();
                break;
              case 8: {
                CollectWins = input.ReadUInt64();
                break;
              }
              case 16: {
                Point = input.ReadUInt32();
                break;
              }
            }
          }
        }

      }

      public sealed class BetInfo : pb::IMessage {
        private static readonly pb::MessageParser<BetInfo> _parser = new pb::MessageParser<BetInfo>(() => new BetInfo());
        public static pb::MessageParser<BetInfo> Parser { get { return _parser; } }

        private static readonly pb::FieldCodec<global::DragonU3DSDK.Network.API.ILProtocol.DevilRushGameResultExtraInfo.Types.Progress> _repeated_collectProgress_codec
            = pb::FieldCodec.ForMessage(10, global::DragonU3DSDK.Network.API.ILProtocol.DevilRushGameResultExtraInfo.Types.Progress.Parser);
        private readonly pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.DevilRushGameResultExtraInfo.Types.Progress> collectProgress_ = new pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.DevilRushGameResultExtraInfo.Types.Progress>();
        public pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.DevilRushGameResultExtraInfo.Types.Progress> CollectProgress {
          get { return collectProgress_; }
        }

        private uint maxPoint_;
        /// <summary>
        /// 最大的点数
        /// </summary>
        public uint MaxPoint {
          get { return maxPoint_; }
          set {
            maxPoint_ = value;
          }
        }

        public void WriteTo(pb::CodedOutputStream output) {
          collectProgress_.WriteTo(output, _repeated_collectProgress_codec);
          if (MaxPoint != 0) {
            output.WriteRawTag(16);
            output.WriteUInt32(MaxPoint);
          }
        }

        public int CalculateSize() {
          int size = 0;
          size += collectProgress_.CalculateSize(_repeated_collectProgress_codec);
          if (MaxPoint != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(MaxPoint);
          }
          return size;
        }

        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                input.SkipLastField();
                break;
              case 10: {
                collectProgress_.AddEntriesFrom(input, _repeated_collectProgress_codec);
                break;
              }
              case 16: {
                MaxPoint = input.ReadUInt32();
                break;
              }
            }
          }
        }

      }

    }
    #endregion

  }

  /// <summary>
  ///*============================== EyeOfMedusa2 ================================*/
  /// 这关有两个复杂点：
  /// 1： feature很多，主要看后面的字段描述 belle feature, bag feature, wheel, map free
  /// 2： free的总类很多，主要依靠freeSpinInfo.freeSpinId进行区分
  ///    freeSpinId == 0, 表示普通free，靠wheel转出来
  ///    freeSpinId == 1, 表示belle free，靠wheel转出来
  ///    freeSpinId == 2, 表示map中的，classic free, avgBet
  ///    freeSpinId == 3, 表示map中的，random wild类型free, avgBet
  ///    freeSpinId == 4, 表示map中的，moving wild类型free, avgBet
  ///    freeSpinId == 5, 表示map中的，sticky wild类型free, avgBet
  ///    freeSpinId == 6, 表示map中的，2-10 multiplier wild类型free, avgBet
  ///    freeSpinId == 7, 表示map中的，5-50 multiplier wild类型free, avgBet
  ///    freeSpinId == 8, 表示map中的，10-100 multiplier wild类型free, avgBet
  /// 特殊赢钱线：
  /// 1 scatter触发wheel bonusGameId = 1001
  /// 2 s1触发map，bonusGameId = 2002
  /// 3 belle feature中 gems的特殊赢钱线 bonsGameId = 3001
  /// 4 bag特殊赢钱线，bonusGameId = 4001
  /// 多状态转化同时触发情况：
  /// base可以同时触发map和wheel，此时先完成map，再进行wheel。
  /// 会在map的settle api返回: gameResult.bonusGame > 0 和 extra.wheel.started = true;
  /// </summary>
  public sealed class EyeOfMedusa2GameResultExtraInfo : pb::IMessage {
    private static readonly pb::MessageParser<EyeOfMedusa2GameResultExtraInfo> _parser = new pb::MessageParser<EyeOfMedusa2GameResultExtraInfo>(() => new EyeOfMedusa2GameResultExtraInfo());
    public static pb::MessageParser<EyeOfMedusa2GameResultExtraInfo> Parser { get { return _parser; } }

    private uint level_;
    /// <summary>
    /// map related
    /// </summary>
    public uint Level {
      get { return level_; }
      set {
        level_ = value;
      }
    }

    private uint point_;
    /// <summary>
    /// map 的累计槽进度,
    /// </summary>
    public uint Point {
      get { return point_; }
      set {
        point_ = value;
      }
    }

    private uint maxPoint_;
    /// <summary>
    /// map 的累计槽最大值， 注意point累积触发map free时，point可能超过max_point
    /// </summary>
    public uint MaxPoint {
      get { return maxPoint_; }
      set {
        maxPoint_ = value;
      }
    }

    private static readonly pb::FieldCodec<global::DragonU3DSDK.Network.API.ILProtocol.EyeOfMedusa2GameResultExtraInfo.Types.RepeatedPositions> _repeated_mapRandomWilds_codec
        = pb::FieldCodec.ForMessage(34, global::DragonU3DSDK.Network.API.ILProtocol.EyeOfMedusa2GameResultExtraInfo.Types.RepeatedPositions.Parser);
    private readonly pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.EyeOfMedusa2GameResultExtraInfo.Types.RepeatedPositions> mapRandomWilds_ = new pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.EyeOfMedusa2GameResultExtraInfo.Types.RepeatedPositions>();
    /// <summary>
    /// map 玩法的随机wild位置, index是0，1，2对应第几个panel
    /// </summary>
    public pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.EyeOfMedusa2GameResultExtraInfo.Types.RepeatedPositions> MapRandomWilds {
      get { return mapRandomWilds_; }
    }

    private static readonly pb::FieldCodec<uint> _repeated_mapMultipliers_codec
        = pb::FieldCodec.ForUInt32(42);
    private readonly pbc::RepeatedField<uint> mapMultipliers_ = new pbc::RepeatedField<uint>();
    /// <summary>
    /// map 玩法倍数
    /// </summary>
    public pbc::RepeatedField<uint> MapMultipliers {
      get { return mapMultipliers_; }
    }

    private static readonly pb::FieldCodec<global::DragonU3DSDK.Network.API.ILProtocol.EyeOfMedusa2GameResultExtraInfo.Types.RepeatedPositionIds> _repeated_mapStickyWilds_codec
        = pb::FieldCodec.ForMessage(50, global::DragonU3DSDK.Network.API.ILProtocol.EyeOfMedusa2GameResultExtraInfo.Types.RepeatedPositionIds.Parser);
    private readonly pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.EyeOfMedusa2GameResultExtraInfo.Types.RepeatedPositionIds> mapStickyWilds_ = new pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.EyeOfMedusa2GameResultExtraInfo.Types.RepeatedPositionIds>();
    /// <summary>
    /// map 玩法的sticky wild位置, index是 0，1，2对应第几个panel
    /// </summary>
    public pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.EyeOfMedusa2GameResultExtraInfo.Types.RepeatedPositionIds> MapStickyWilds {
      get { return mapStickyWilds_; }
    }

    private static readonly pb::FieldCodec<global::DragonU3DSDK.Network.API.ILProtocol.EyeOfMedusa2GameResultExtraInfo.Types.RepeatedMovingPositionIds> _repeated_mapMovingWilds_codec
        = pb::FieldCodec.ForMessage(58, global::DragonU3DSDK.Network.API.ILProtocol.EyeOfMedusa2GameResultExtraInfo.Types.RepeatedMovingPositionIds.Parser);
    private readonly pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.EyeOfMedusa2GameResultExtraInfo.Types.RepeatedMovingPositionIds> mapMovingWilds_ = new pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.EyeOfMedusa2GameResultExtraInfo.Types.RepeatedMovingPositionIds>();
    /// <summary>
    /// map 玩法的moving wild位置, index是0，1，2对应第几个panel
    /// </summary>
    public pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.EyeOfMedusa2GameResultExtraInfo.Types.RepeatedMovingPositionIds> MapMovingWilds {
      get { return mapMovingWilds_; }
    }

    private bool isFeature_;
    /// <summary>
    /// belle feature related
    /// </summary>
    public bool IsFeature {
      get { return isFeature_; }
      set {
        isFeature_ = value;
      }
    }

    private static readonly pbc::MapField<uint, int>.Codec _map_dragReelPositionMap_codec
        = new pbc::MapField<uint, int>.Codec(pb::FieldCodec.ForUInt32(8), pb::FieldCodec.ForInt32(16), 74);
    private readonly pbc::MapField<uint, int> dragReelPositionMap_ = new pbc::MapField<uint, int>();
    /// <summary>
    /// 触发feature的时候第一列可能发生drag；这里用一个map是为了和其他任何列都能drag的游戏统一
    /// </summary>
    public pbc::MapField<uint, int> DragReelPositionMap {
      get { return dragReelPositionMap_; }
    }

    private static readonly pb::FieldCodec<global::DragonU3DSDK.Network.API.ILProtocol.EyeOfMedusa2GameResultExtraInfo.Types.PositionId> _repeated_randomPositionedGems_codec
        = pb::FieldCodec.ForMessage(82, global::DragonU3DSDK.Network.API.ILProtocol.EyeOfMedusa2GameResultExtraInfo.Types.PositionId.Parser);
    private readonly pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.EyeOfMedusa2GameResultExtraInfo.Types.PositionId> randomPositionedGems_ = new pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.EyeOfMedusa2GameResultExtraInfo.Types.PositionId>();
    /// <summary>
    /// 粗发feature的时候 生成的随机gems
    /// </summary>
    public pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.EyeOfMedusa2GameResultExtraInfo.Types.PositionId> RandomPositionedGems {
      get { return randomPositionedGems_; }
    }

    private uint bagLevel_;
    /// <summary>
    /// bag feature related
    /// </summary>
    public uint BagLevel {
      get { return bagLevel_; }
      set {
        bagLevel_ = value;
      }
    }

    private static readonly pb::FieldCodec<uint> _repeated_bagLevelHistory_codec
        = pb::FieldCodec.ForUInt32(98);
    private readonly pbc::RepeatedField<uint> bagLevelHistory_ = new pbc::RepeatedField<uint>();
    /// <summary>
    /// bag_level_history类似一些游戏的old_level,old_points, 但这里数个数组，因为可能一次转出多个bag;
    /// 正常没有bag转出时它是空
    /// 例1： 如果转出1个bag，而且他中了， 转出前bag_level是1
    /// 那么返回: bag_level = 0; bag_level_history = [1]
    /// 例2： 如果转出1个bag，但他没中， 转出前bag_level是2
    /// 那么返回: bag_level = 2; bag_level_history = [2]
    /// 例3： 如果转出2个bag，转出前bag_level是1，第一个bag没中让bag_level加1，第二个bag中了
    /// 那么返回: bag_level = 0; bqg_level_history = [1, 2]
    /// 例4：如果转出4个bag，转出前bag_level是1，第一个bag没中， 第二个bag没中， 第三个bag中了， 第四个bag没中
    /// 那么返回: bag_level = 1; bag_level_history = [1, 2，2，0]
    /// </summary>
    public pbc::RepeatedField<uint> BagLevelHistory {
      get { return bagLevelHistory_; }
    }

    private static readonly pb::FieldCodec<global::DragonU3DSDK.Network.API.ILProtocol.EyeOfMedusa2GameResultExtraInfo.Types.Position> _repeated_normalFreeRandomWilds_codec
        = pb::FieldCodec.ForMessage(106, global::DragonU3DSDK.Network.API.ILProtocol.EyeOfMedusa2GameResultExtraInfo.Types.Position.Parser);
    private readonly pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.EyeOfMedusa2GameResultExtraInfo.Types.Position> normalFreeRandomWilds_ = new pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.EyeOfMedusa2GameResultExtraInfo.Types.Position>();
    /// <summary>
    /// normal free related
    /// </summary>
    public pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.EyeOfMedusa2GameResultExtraInfo.Types.Position> NormalFreeRandomWilds {
      get { return normalFreeRandomWilds_; }
    }

    private global::DragonU3DSDK.Network.API.ILProtocol.EyeOfMedusa2GameResultExtraInfo.Types.Wheel wheel_;
    /// <summary>
    /// wheel数据
    /// </summary>
    public global::DragonU3DSDK.Network.API.ILProtocol.EyeOfMedusa2GameResultExtraInfo.Types.Wheel Wheel {
      get { return wheel_; }
      set {
        wheel_ = value;
      }
    }

    private ulong mapFreePreWin_;
    /// <summary>
    /// map free pre win
    /// </summary>
    public ulong MapFreePreWin {
      get { return mapFreePreWin_; }
      set {
        mapFreePreWin_ = value;
      }
    }

    private ulong bagWin_;
    /// <summary>
    /// bagWin
    /// </summary>
    public ulong BagWin {
      get { return bagWin_; }
      set {
        bagWin_ = value;
      }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (Level != 0) {
        output.WriteRawTag(8);
        output.WriteUInt32(Level);
      }
      if (Point != 0) {
        output.WriteRawTag(16);
        output.WriteUInt32(Point);
      }
      if (MaxPoint != 0) {
        output.WriteRawTag(24);
        output.WriteUInt32(MaxPoint);
      }
      mapRandomWilds_.WriteTo(output, _repeated_mapRandomWilds_codec);
      mapMultipliers_.WriteTo(output, _repeated_mapMultipliers_codec);
      mapStickyWilds_.WriteTo(output, _repeated_mapStickyWilds_codec);
      mapMovingWilds_.WriteTo(output, _repeated_mapMovingWilds_codec);
      if (IsFeature != false) {
        output.WriteRawTag(64);
        output.WriteBool(IsFeature);
      }
      dragReelPositionMap_.WriteTo(output, _map_dragReelPositionMap_codec);
      randomPositionedGems_.WriteTo(output, _repeated_randomPositionedGems_codec);
      if (BagLevel != 0) {
        output.WriteRawTag(88);
        output.WriteUInt32(BagLevel);
      }
      bagLevelHistory_.WriteTo(output, _repeated_bagLevelHistory_codec);
      normalFreeRandomWilds_.WriteTo(output, _repeated_normalFreeRandomWilds_codec);
      if (wheel_ != null) {
        output.WriteRawTag(114);
        output.WriteMessage(Wheel);
      }
      if (MapFreePreWin != 0UL) {
        output.WriteRawTag(120);
        output.WriteUInt64(MapFreePreWin);
      }
      if (BagWin != 0UL) {
        output.WriteRawTag(128, 1);
        output.WriteUInt64(BagWin);
      }
    }

    public int CalculateSize() {
      int size = 0;
      if (Level != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Level);
      }
      if (Point != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Point);
      }
      if (MaxPoint != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(MaxPoint);
      }
      size += mapRandomWilds_.CalculateSize(_repeated_mapRandomWilds_codec);
      size += mapMultipliers_.CalculateSize(_repeated_mapMultipliers_codec);
      size += mapStickyWilds_.CalculateSize(_repeated_mapStickyWilds_codec);
      size += mapMovingWilds_.CalculateSize(_repeated_mapMovingWilds_codec);
      if (IsFeature != false) {
        size += 1 + 1;
      }
      size += dragReelPositionMap_.CalculateSize(_map_dragReelPositionMap_codec);
      size += randomPositionedGems_.CalculateSize(_repeated_randomPositionedGems_codec);
      if (BagLevel != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(BagLevel);
      }
      size += bagLevelHistory_.CalculateSize(_repeated_bagLevelHistory_codec);
      size += normalFreeRandomWilds_.CalculateSize(_repeated_normalFreeRandomWilds_codec);
      if (wheel_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Wheel);
      }
      if (MapFreePreWin != 0UL) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(MapFreePreWin);
      }
      if (BagWin != 0UL) {
        size += 2 + pb::CodedOutputStream.ComputeUInt64Size(BagWin);
      }
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            Level = input.ReadUInt32();
            break;
          }
          case 16: {
            Point = input.ReadUInt32();
            break;
          }
          case 24: {
            MaxPoint = input.ReadUInt32();
            break;
          }
          case 34: {
            mapRandomWilds_.AddEntriesFrom(input, _repeated_mapRandomWilds_codec);
            break;
          }
          case 42:
          case 40: {
            mapMultipliers_.AddEntriesFrom(input, _repeated_mapMultipliers_codec);
            break;
          }
          case 50: {
            mapStickyWilds_.AddEntriesFrom(input, _repeated_mapStickyWilds_codec);
            break;
          }
          case 58: {
            mapMovingWilds_.AddEntriesFrom(input, _repeated_mapMovingWilds_codec);
            break;
          }
          case 64: {
            IsFeature = input.ReadBool();
            break;
          }
          case 74: {
            dragReelPositionMap_.AddEntriesFrom(input, _map_dragReelPositionMap_codec);
            break;
          }
          case 82: {
            randomPositionedGems_.AddEntriesFrom(input, _repeated_randomPositionedGems_codec);
            break;
          }
          case 88: {
            BagLevel = input.ReadUInt32();
            break;
          }
          case 98:
          case 96: {
            bagLevelHistory_.AddEntriesFrom(input, _repeated_bagLevelHistory_codec);
            break;
          }
          case 106: {
            normalFreeRandomWilds_.AddEntriesFrom(input, _repeated_normalFreeRandomWilds_codec);
            break;
          }
          case 114: {
            if (wheel_ == null) {
              wheel_ = new global::DragonU3DSDK.Network.API.ILProtocol.EyeOfMedusa2GameResultExtraInfo.Types.Wheel();
            }
            input.ReadMessage(wheel_);
            break;
          }
          case 120: {
            MapFreePreWin = input.ReadUInt64();
            break;
          }
          case 128: {
            BagWin = input.ReadUInt64();
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the EyeOfMedusa2GameResultExtraInfo message type.</summary>
    public static class Types {
      public sealed class Position : pb::IMessage {
        private static readonly pb::MessageParser<Position> _parser = new pb::MessageParser<Position>(() => new Position());
        public static pb::MessageParser<Position> Parser { get { return _parser; } }

        private uint x_;
        public uint X {
          get { return x_; }
          set {
            x_ = value;
          }
        }

        private uint y_;
        public uint Y {
          get { return y_; }
          set {
            y_ = value;
          }
        }

        public void WriteTo(pb::CodedOutputStream output) {
          if (X != 0) {
            output.WriteRawTag(8);
            output.WriteUInt32(X);
          }
          if (Y != 0) {
            output.WriteRawTag(16);
            output.WriteUInt32(Y);
          }
        }

        public int CalculateSize() {
          int size = 0;
          if (X != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(X);
          }
          if (Y != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Y);
          }
          return size;
        }

        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                input.SkipLastField();
                break;
              case 8: {
                X = input.ReadUInt32();
                break;
              }
              case 16: {
                Y = input.ReadUInt32();
                break;
              }
            }
          }
        }

      }

      public sealed class RepeatedPositions : pb::IMessage {
        private static readonly pb::MessageParser<RepeatedPositions> _parser = new pb::MessageParser<RepeatedPositions>(() => new RepeatedPositions());
        public static pb::MessageParser<RepeatedPositions> Parser { get { return _parser; } }

        private static readonly pb::FieldCodec<global::DragonU3DSDK.Network.API.ILProtocol.EyeOfMedusa2GameResultExtraInfo.Types.Position> _repeated_items_codec
            = pb::FieldCodec.ForMessage(10, global::DragonU3DSDK.Network.API.ILProtocol.EyeOfMedusa2GameResultExtraInfo.Types.Position.Parser);
        private readonly pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.EyeOfMedusa2GameResultExtraInfo.Types.Position> items_ = new pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.EyeOfMedusa2GameResultExtraInfo.Types.Position>();
        public pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.EyeOfMedusa2GameResultExtraInfo.Types.Position> Items {
          get { return items_; }
        }

        public void WriteTo(pb::CodedOutputStream output) {
          items_.WriteTo(output, _repeated_items_codec);
        }

        public int CalculateSize() {
          int size = 0;
          size += items_.CalculateSize(_repeated_items_codec);
          return size;
        }

        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                input.SkipLastField();
                break;
              case 10: {
                items_.AddEntriesFrom(input, _repeated_items_codec);
                break;
              }
            }
          }
        }

      }

      public sealed class PositionId : pb::IMessage {
        private static readonly pb::MessageParser<PositionId> _parser = new pb::MessageParser<PositionId>(() => new PositionId());
        public static pb::MessageParser<PositionId> Parser { get { return _parser; } }

        private uint x_;
        public uint X {
          get { return x_; }
          set {
            x_ = value;
          }
        }

        private uint y_;
        public uint Y {
          get { return y_; }
          set {
            y_ = value;
          }
        }

        private uint id_;
        /// <summary>
        /// symbol id
        /// </summary>
        public uint Id {
          get { return id_; }
          set {
            id_ = value;
          }
        }

        public void WriteTo(pb::CodedOutputStream output) {
          if (X != 0) {
            output.WriteRawTag(8);
            output.WriteUInt32(X);
          }
          if (Y != 0) {
            output.WriteRawTag(16);
            output.WriteUInt32(Y);
          }
          if (Id != 0) {
            output.WriteRawTag(24);
            output.WriteUInt32(Id);
          }
        }

        public int CalculateSize() {
          int size = 0;
          if (X != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(X);
          }
          if (Y != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Y);
          }
          if (Id != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Id);
          }
          return size;
        }

        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                input.SkipLastField();
                break;
              case 8: {
                X = input.ReadUInt32();
                break;
              }
              case 16: {
                Y = input.ReadUInt32();
                break;
              }
              case 24: {
                Id = input.ReadUInt32();
                break;
              }
            }
          }
        }

      }

      public sealed class RepeatedPositionIds : pb::IMessage {
        private static readonly pb::MessageParser<RepeatedPositionIds> _parser = new pb::MessageParser<RepeatedPositionIds>(() => new RepeatedPositionIds());
        public static pb::MessageParser<RepeatedPositionIds> Parser { get { return _parser; } }

        private static readonly pb::FieldCodec<global::DragonU3DSDK.Network.API.ILProtocol.EyeOfMedusa2GameResultExtraInfo.Types.PositionId> _repeated_items_codec
            = pb::FieldCodec.ForMessage(10, global::DragonU3DSDK.Network.API.ILProtocol.EyeOfMedusa2GameResultExtraInfo.Types.PositionId.Parser);
        private readonly pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.EyeOfMedusa2GameResultExtraInfo.Types.PositionId> items_ = new pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.EyeOfMedusa2GameResultExtraInfo.Types.PositionId>();
        public pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.EyeOfMedusa2GameResultExtraInfo.Types.PositionId> Items {
          get { return items_; }
        }

        public void WriteTo(pb::CodedOutputStream output) {
          items_.WriteTo(output, _repeated_items_codec);
        }

        public int CalculateSize() {
          int size = 0;
          size += items_.CalculateSize(_repeated_items_codec);
          return size;
        }

        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                input.SkipLastField();
                break;
              case 10: {
                items_.AddEntriesFrom(input, _repeated_items_codec);
                break;
              }
            }
          }
        }

      }

      public sealed class MovingPositionId : pb::IMessage {
        private static readonly pb::MessageParser<MovingPositionId> _parser = new pb::MessageParser<MovingPositionId>(() => new MovingPositionId());
        public static pb::MessageParser<MovingPositionId> Parser { get { return _parser; } }

        private bool moving_;
        /// <summary>
        /// 当前位置是否不是新转出来的(可能用词略有歧义，主要区分这一把转出来的和之前转出来的，之前转出来spin之前会moving)；新转出来的sticky moving=false
        /// </summary>
        public bool Moving {
          get { return moving_; }
          set {
            moving_ = value;
          }
        }

        private uint oldX_;
        /// <summary>
        /// 老位置， 注意有可能 老位置==新位置 and moving == true
        /// </summary>
        public uint OldX {
          get { return oldX_; }
          set {
            oldX_ = value;
          }
        }

        private uint oldY_;
        /// <summary>
        /// 老位置  当 moving == false时， 老位置 必定等于 新位置
        /// </summary>
        public uint OldY {
          get { return oldY_; }
          set {
            oldY_ = value;
          }
        }

        private uint x_;
        /// <summary>
        /// 新位置
        /// </summary>
        public uint X {
          get { return x_; }
          set {
            x_ = value;
          }
        }

        private uint y_;
        /// <summary>
        /// 新位置
        /// </summary>
        public uint Y {
          get { return y_; }
          set {
            y_ = value;
          }
        }

        private uint id_;
        public uint Id {
          get { return id_; }
          set {
            id_ = value;
          }
        }

        public void WriteTo(pb::CodedOutputStream output) {
          if (Moving != false) {
            output.WriteRawTag(8);
            output.WriteBool(Moving);
          }
          if (OldX != 0) {
            output.WriteRawTag(16);
            output.WriteUInt32(OldX);
          }
          if (OldY != 0) {
            output.WriteRawTag(24);
            output.WriteUInt32(OldY);
          }
          if (X != 0) {
            output.WriteRawTag(32);
            output.WriteUInt32(X);
          }
          if (Y != 0) {
            output.WriteRawTag(40);
            output.WriteUInt32(Y);
          }
          if (Id != 0) {
            output.WriteRawTag(48);
            output.WriteUInt32(Id);
          }
        }

        public int CalculateSize() {
          int size = 0;
          if (Moving != false) {
            size += 1 + 1;
          }
          if (OldX != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(OldX);
          }
          if (OldY != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(OldY);
          }
          if (X != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(X);
          }
          if (Y != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Y);
          }
          if (Id != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Id);
          }
          return size;
        }

        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                input.SkipLastField();
                break;
              case 8: {
                Moving = input.ReadBool();
                break;
              }
              case 16: {
                OldX = input.ReadUInt32();
                break;
              }
              case 24: {
                OldY = input.ReadUInt32();
                break;
              }
              case 32: {
                X = input.ReadUInt32();
                break;
              }
              case 40: {
                Y = input.ReadUInt32();
                break;
              }
              case 48: {
                Id = input.ReadUInt32();
                break;
              }
            }
          }
        }

      }

      public sealed class RepeatedMovingPositionIds : pb::IMessage {
        private static readonly pb::MessageParser<RepeatedMovingPositionIds> _parser = new pb::MessageParser<RepeatedMovingPositionIds>(() => new RepeatedMovingPositionIds());
        public static pb::MessageParser<RepeatedMovingPositionIds> Parser { get { return _parser; } }

        private static readonly pb::FieldCodec<global::DragonU3DSDK.Network.API.ILProtocol.EyeOfMedusa2GameResultExtraInfo.Types.MovingPositionId> _repeated_items_codec
            = pb::FieldCodec.ForMessage(10, global::DragonU3DSDK.Network.API.ILProtocol.EyeOfMedusa2GameResultExtraInfo.Types.MovingPositionId.Parser);
        private readonly pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.EyeOfMedusa2GameResultExtraInfo.Types.MovingPositionId> items_ = new pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.EyeOfMedusa2GameResultExtraInfo.Types.MovingPositionId>();
        public pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.EyeOfMedusa2GameResultExtraInfo.Types.MovingPositionId> Items {
          get { return items_; }
        }

        public void WriteTo(pb::CodedOutputStream output) {
          items_.WriteTo(output, _repeated_items_codec);
        }

        public int CalculateSize() {
          int size = 0;
          size += items_.CalculateSize(_repeated_items_codec);
          return size;
        }

        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                input.SkipLastField();
                break;
              case 10: {
                items_.AddEntriesFrom(input, _repeated_items_codec);
                break;
              }
            }
          }
        }

      }

      /// <summary>
      /// wheel related
      /// </summary>
      public sealed class Wheel : pb::IMessage {
        private static readonly pb::MessageParser<Wheel> _parser = new pb::MessageParser<Wheel>(() => new Wheel());
        public static pb::MessageParser<Wheel> Parser { get { return _parser; } }

        private ulong bet_;
        /// <summary>
        /// 进入wheel的bet
        /// </summary>
        public ulong Bet {
          get { return bet_; }
          set {
            bet_ = value;
          }
        }

        private ulong totalWin_;
        /// <summary>
        /// wheel的总赢钱；类似freeSpinInfo.freeSpinTotalWin; 包括触发的线赢甚至同时触发map时，之前map的总赢
        /// </summary>
        public ulong TotalWin {
          get { return totalWin_; }
          set {
            totalWin_ = value;
          }
        }

        private static readonly pb::FieldCodec<global::DragonU3DSDK.Network.API.ILProtocol.Panel> _repeated_triggeringPanels_codec
            = pb::FieldCodec.ForMessage(26, global::DragonU3DSDK.Network.API.ILProtocol.Panel.Parser);
        private readonly pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.Panel> triggeringPanels_ = new pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.Panel>();
        /// <summary>
        /// 触发的panel
        /// </summary>
        public pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.Panel> TriggeringPanels {
          get { return triggeringPanels_; }
        }

        private bool started_;
        /// <summary>
        /// 是否开始
        /// </summary>
        public bool Started {
          get { return started_; }
          set {
            started_ = value;
          }
        }

        private bool toSettle_;
        /// <summary>
        /// 是否结算完毕，用于判断是否该调用settle api
        /// </summary>
        public bool ToSettle {
          get { return toSettle_; }
          set {
            toSettle_ = value;
          }
        }

        private uint index_;
        /// <summary>
        /// wheel转出的结果的序号
        /// </summary>
        public uint Index {
          get { return index_; }
          set {
            index_ = value;
          }
        }

        private static readonly pb::FieldCodec<global::DragonU3DSDK.Network.API.ILProtocol.EyeOfMedusa2GameResultExtraInfo.Types.Wheel.Types.Item> _repeated_items_codec
            = pb::FieldCodec.ForMessage(58, global::DragonU3DSDK.Network.API.ILProtocol.EyeOfMedusa2GameResultExtraInfo.Types.Wheel.Types.Item.Parser);
        private readonly pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.EyeOfMedusa2GameResultExtraInfo.Types.Wheel.Types.Item> items_ = new pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.EyeOfMedusa2GameResultExtraInfo.Types.Wheel.Types.Item>();
        /// <summary>
        /// wheel里每一个item的信息
        /// </summary>
        public pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.EyeOfMedusa2GameResultExtraInfo.Types.Wheel.Types.Item> Items {
          get { return items_; }
        }

        public void WriteTo(pb::CodedOutputStream output) {
          if (Bet != 0UL) {
            output.WriteRawTag(8);
            output.WriteUInt64(Bet);
          }
          if (TotalWin != 0UL) {
            output.WriteRawTag(16);
            output.WriteUInt64(TotalWin);
          }
          triggeringPanels_.WriteTo(output, _repeated_triggeringPanels_codec);
          if (Started != false) {
            output.WriteRawTag(32);
            output.WriteBool(Started);
          }
          if (ToSettle != false) {
            output.WriteRawTag(40);
            output.WriteBool(ToSettle);
          }
          if (Index != 0) {
            output.WriteRawTag(48);
            output.WriteUInt32(Index);
          }
          items_.WriteTo(output, _repeated_items_codec);
        }

        public int CalculateSize() {
          int size = 0;
          if (Bet != 0UL) {
            size += 1 + pb::CodedOutputStream.ComputeUInt64Size(Bet);
          }
          if (TotalWin != 0UL) {
            size += 1 + pb::CodedOutputStream.ComputeUInt64Size(TotalWin);
          }
          size += triggeringPanels_.CalculateSize(_repeated_triggeringPanels_codec);
          if (Started != false) {
            size += 1 + 1;
          }
          if (ToSettle != false) {
            size += 1 + 1;
          }
          if (Index != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Index);
          }
          size += items_.CalculateSize(_repeated_items_codec);
          return size;
        }

        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                input.SkipLastField();
                break;
              case 8: {
                Bet = input.ReadUInt64();
                break;
              }
              case 16: {
                TotalWin = input.ReadUInt64();
                break;
              }
              case 26: {
                triggeringPanels_.AddEntriesFrom(input, _repeated_triggeringPanels_codec);
                break;
              }
              case 32: {
                Started = input.ReadBool();
                break;
              }
              case 40: {
                ToSettle = input.ReadBool();
                break;
              }
              case 48: {
                Index = input.ReadUInt32();
                break;
              }
              case 58: {
                items_.AddEntriesFrom(input, _repeated_items_codec);
                break;
              }
            }
          }
        }

        #region Nested types
        /// <summary>Container for nested types declared in the Wheel message type.</summary>
        public static class Types {
          public sealed class Item : pb::IMessage {
            private static readonly pb::MessageParser<Item> _parser = new pb::MessageParser<Item>(() => new Item());
            public static pb::MessageParser<Item> Parser { get { return _parser; } }

            private uint jackpotId_;
            /// <summary>
            /// 非0表示这是jackpot
            /// </summary>
            public uint JackpotId {
              get { return jackpotId_; }
              set {
                jackpotId_ = value;
              }
            }

            private bool isFeatureFree_;
            /// <summary>
            /// true表示这是触发belle free
            /// </summary>
            public bool IsFeatureFree {
              get { return isFeatureFree_; }
              set {
                isFeatureFree_ = value;
              }
            }

            private bool isNormalFree_;
            /// <summary>
            /// true表示这是触发普通free
            /// </summary>
            public bool IsNormalFree {
              get { return isNormalFree_; }
              set {
                isNormalFree_ = value;
              }
            }

            private bool isBagBonus_;
            /// <summary>
            /// true表示这是触发Bag
            /// </summary>
            public bool IsBagBonus {
              get { return isBagBonus_; }
              set {
                isBagBonus_ = value;
              }
            }

            private ulong winRate_;
            /// <summary>
            /// 如果是bag，这里是bag的winRate
            /// </summary>
            public ulong WinRate {
              get { return winRate_; }
              set {
                winRate_ = value;
              }
            }

            private ulong jackpotPay_;
            /// <summary>
            /// 如果是jackpot，这里是jackpot的winRate
            /// </summary>
            public ulong JackpotPay {
              get { return jackpotPay_; }
              set {
                jackpotPay_ = value;
              }
            }

            public void WriteTo(pb::CodedOutputStream output) {
              if (JackpotId != 0) {
                output.WriteRawTag(8);
                output.WriteUInt32(JackpotId);
              }
              if (IsFeatureFree != false) {
                output.WriteRawTag(16);
                output.WriteBool(IsFeatureFree);
              }
              if (IsNormalFree != false) {
                output.WriteRawTag(24);
                output.WriteBool(IsNormalFree);
              }
              if (IsBagBonus != false) {
                output.WriteRawTag(32);
                output.WriteBool(IsBagBonus);
              }
              if (WinRate != 0UL) {
                output.WriteRawTag(40);
                output.WriteUInt64(WinRate);
              }
              if (JackpotPay != 0UL) {
                output.WriteRawTag(48);
                output.WriteUInt64(JackpotPay);
              }
            }

            public int CalculateSize() {
              int size = 0;
              if (JackpotId != 0) {
                size += 1 + pb::CodedOutputStream.ComputeUInt32Size(JackpotId);
              }
              if (IsFeatureFree != false) {
                size += 1 + 1;
              }
              if (IsNormalFree != false) {
                size += 1 + 1;
              }
              if (IsBagBonus != false) {
                size += 1 + 1;
              }
              if (WinRate != 0UL) {
                size += 1 + pb::CodedOutputStream.ComputeUInt64Size(WinRate);
              }
              if (JackpotPay != 0UL) {
                size += 1 + pb::CodedOutputStream.ComputeUInt64Size(JackpotPay);
              }
              return size;
            }

            public void MergeFrom(pb::CodedInputStream input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    input.SkipLastField();
                    break;
                  case 8: {
                    JackpotId = input.ReadUInt32();
                    break;
                  }
                  case 16: {
                    IsFeatureFree = input.ReadBool();
                    break;
                  }
                  case 24: {
                    IsNormalFree = input.ReadBool();
                    break;
                  }
                  case 32: {
                    IsBagBonus = input.ReadBool();
                    break;
                  }
                  case 40: {
                    WinRate = input.ReadUInt64();
                    break;
                  }
                  case 48: {
                    JackpotPay = input.ReadUInt64();
                    break;
                  }
                }
              }
            }

          }

        }
        #endregion

      }

    }
    #endregion

  }

  #endregion

}

#endregion Designer generated code
