// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: spinx_game.proto
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.ilruntime.Protobuf;
using pbc = global::Google.ilruntime.Protobuf.Collections;
using scg = global::System.Collections.Generic;
namespace DragonU3DSDK.Network.API.ILProtocol {

  #region Enums
  /// <summary>
  /// 图标类型
  /// </summary>
  public enum SymbolType {
    /// <summary>
    /// </summary>
    None = 0,
    /// <summary>
    /// </summary>
    Normal = 1,
    /// <summary>
    /// </summary>
    Wild = 2,
    /// <summary>
    /// </summary>
    Jackpot = 3,
    /// <summary>
    /// </summary>
    Bonus = 4,
    /// <summary>
    /// </summary>
    Scatter = 5,
  }

  /// <summary>
  /// 赢钱线方向
  /// </summary>
  public enum LineDirection {
    /// <summary>
    /// 从左开始算
    /// </summary>
    Left = 0,
    /// <summary>
    /// 从右开始算
    /// </summary>
    Right = 1,
    /// <summary>
    /// 双向
    /// </summary>
    Both = 2,
  }

  /// <summary>
  /// 游戏模式 
  /// </summary>
  public enum GameMode {
    /// <summary>
    /// </summary>
    None = 0,
    /// <summary>
    /// </summary>
    Easy = 1,
    /// <summary>
    /// </summary>
    Normal = 2,
    /// <summary>
    /// </summary>
    Hard = 3,
  }

  /// <summary>
  /// 游戏方向
  /// </summary>
  public enum GameOrientation {
    /// <summary>
    /// 竖屏
    /// </summary>
    Portrait = 0,
    /// <summary>
    /// 横屏
    /// </summary>
    Landscape = 1,
  }

  /// <summary>
  /// jackpot类型 
  /// </summary>
  public enum JackpotType {
    /// <summary>
    /// </summary>
    None = 0,
    /// <summary>
    /// 随时间自然增长
    /// </summary>
    Progressive = 1,
    /// <summary>
    /// 随下注累计增长
    /// </summary>
    Accumulative = 2,
  }

  #endregion

  #region Messages
  /// <summary>
  /// 赔付线掩码，1表示激活，0表示未激活
  /// </summary>
  public sealed class Mask : pb::IMessage {
    private static readonly pb::MessageParser<Mask> _parser = new pb::MessageParser<Mask>(() => new Mask());
    public static pb::MessageParser<Mask> Parser { get { return _parser; } }

    private static readonly pb::FieldCodec<uint> _repeated_mask_codec
        = pb::FieldCodec.ForUInt32(10);
    private readonly pbc::RepeatedField<uint> mask_ = new pbc::RepeatedField<uint>();
    /// <summary>
    /// </summary>
    public pbc::RepeatedField<uint> Mask_ {
      get { return mask_; }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      mask_.WriteTo(output, _repeated_mask_codec);
    }

    public int CalculateSize() {
      int size = 0;
      size += mask_.CalculateSize(_repeated_mask_codec);
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10:
          case 8: {
            mask_.AddEntriesFrom(input, _repeated_mask_codec);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// 赔付线
  /// </summary>
  public sealed class PayLine : pb::IMessage {
    private static readonly pb::MessageParser<PayLine> _parser = new pb::MessageParser<PayLine>(() => new PayLine());
    public static pb::MessageParser<PayLine> Parser { get { return _parser; } }

    private uint payLineId_;
    /// <summary>
    /// </summary>
    public uint PayLineId {
      get { return payLineId_; }
      set {
        payLineId_ = value;
      }
    }

    private static readonly pb::FieldCodec<global::DragonU3DSDK.Network.API.ILProtocol.Mask> _repeated_masks_codec
        = pb::FieldCodec.ForMessage(18, global::DragonU3DSDK.Network.API.ILProtocol.Mask.Parser);
    private readonly pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.Mask> masks_ = new pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.Mask>();
    /// <summary>
    /// </summary>
    public pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.Mask> Masks {
      get { return masks_; }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (PayLineId != 0) {
        output.WriteRawTag(8);
        output.WriteUInt32(PayLineId);
      }
      masks_.WriteTo(output, _repeated_masks_codec);
    }

    public int CalculateSize() {
      int size = 0;
      if (PayLineId != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(PayLineId);
      }
      size += masks_.CalculateSize(_repeated_masks_codec);
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            PayLineId = input.ReadUInt32();
            break;
          }
          case 18: {
            masks_.AddEntriesFrom(input, _repeated_masks_codec);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// 赔付规则
  /// </summary>
  public sealed class PayRule : pb::IMessage {
    private static readonly pb::MessageParser<PayRule> _parser = new pb::MessageParser<PayRule>(() => new PayRule());
    public static pb::MessageParser<PayRule> Parser { get { return _parser; } }

    private uint payRuleId_;
    /// <summary>
    /// </summary>
    public uint PayRuleId {
      get { return payRuleId_; }
      set {
        payRuleId_ = value;
      }
    }

    private static readonly pb::FieldCodec<uint> _repeated_symbolsIds_codec
        = pb::FieldCodec.ForUInt32(18);
    private readonly pbc::RepeatedField<uint> symbolsIds_ = new pbc::RepeatedField<uint>();
    /// <summary>
    /// </summary>
    public pbc::RepeatedField<uint> SymbolsIds {
      get { return symbolsIds_; }
    }

    private uint symbolCount_;
    /// <summary>
    /// </summary>
    public uint SymbolCount {
      get { return symbolCount_; }
      set {
        symbolCount_ = value;
      }
    }

    private bool byLine_;
    /// <summary>
    /// </summary>
    public bool ByLine {
      get { return byLine_; }
      set {
        byLine_ = value;
      }
    }

    private uint pay_;
    /// <summary>
    /// </summary>
    public uint Pay {
      get { return pay_; }
      set {
        pay_ = value;
      }
    }

    private bool allowWild_;
    /// <summary>
    /// </summary>
    public bool AllowWild {
      get { return allowWild_; }
      set {
        allowWild_ = value;
      }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (PayRuleId != 0) {
        output.WriteRawTag(8);
        output.WriteUInt32(PayRuleId);
      }
      symbolsIds_.WriteTo(output, _repeated_symbolsIds_codec);
      if (SymbolCount != 0) {
        output.WriteRawTag(24);
        output.WriteUInt32(SymbolCount);
      }
      if (ByLine != false) {
        output.WriteRawTag(32);
        output.WriteBool(ByLine);
      }
      if (Pay != 0) {
        output.WriteRawTag(40);
        output.WriteUInt32(Pay);
      }
      if (AllowWild != false) {
        output.WriteRawTag(48);
        output.WriteBool(AllowWild);
      }
    }

    public int CalculateSize() {
      int size = 0;
      if (PayRuleId != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(PayRuleId);
      }
      size += symbolsIds_.CalculateSize(_repeated_symbolsIds_codec);
      if (SymbolCount != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(SymbolCount);
      }
      if (ByLine != false) {
        size += 1 + 1;
      }
      if (Pay != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Pay);
      }
      if (AllowWild != false) {
        size += 1 + 1;
      }
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            PayRuleId = input.ReadUInt32();
            break;
          }
          case 18:
          case 16: {
            symbolsIds_.AddEntriesFrom(input, _repeated_symbolsIds_codec);
            break;
          }
          case 24: {
            SymbolCount = input.ReadUInt32();
            break;
          }
          case 32: {
            ByLine = input.ReadBool();
            break;
          }
          case 40: {
            Pay = input.ReadUInt32();
            break;
          }
          case 48: {
            AllowWild = input.ReadBool();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// 坐标： 左上为(0, 0)
  /// </summary>
  public sealed class Position : pb::IMessage {
    private static readonly pb::MessageParser<Position> _parser = new pb::MessageParser<Position>(() => new Position());
    public static pb::MessageParser<Position> Parser { get { return _parser; } }

    private uint x_;
    /// <summary>
    /// </summary>
    public uint X {
      get { return x_; }
      set {
        x_ = value;
      }
    }

    private uint y_;
    /// <summary>
    /// </summary>
    public uint Y {
      get { return y_; }
      set {
        y_ = value;
      }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (X != 0) {
        output.WriteRawTag(8);
        output.WriteUInt32(X);
      }
      if (Y != 0) {
        output.WriteRawTag(16);
        output.WriteUInt32(Y);
      }
    }

    public int CalculateSize() {
      int size = 0;
      if (X != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(X);
      }
      if (Y != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Y);
      }
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            X = input.ReadUInt32();
            break;
          }
          case 16: {
            Y = input.ReadUInt32();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// 赢钱线
  /// </summary>
  public sealed class WinLine : pb::IMessage {
    private static readonly pb::MessageParser<WinLine> _parser = new pb::MessageParser<WinLine>(() => new WinLine());
    public static pb::MessageParser<WinLine> Parser { get { return _parser; } }

    private uint payLineId_;
    /// <summary>
    /// 线id，不按线的这里是0
    /// </summary>
    public uint PayLineId {
      get { return payLineId_; }
      set {
        payLineId_ = value;
      }
    }

    private uint payRuleId_;
    /// <summary>
    /// 规则id, 不按rule的这里是0
    /// </summary>
    public uint PayRuleId {
      get { return payRuleId_; }
      set {
        payRuleId_ = value;
      }
    }

    private uint pay_;
    /// <summary>
    /// 赢钱倍数
    /// </summary>
    public uint Pay {
      get { return pay_; }
      set {
        pay_ = value;
      }
    }

    private static readonly pb::FieldCodec<global::DragonU3DSDK.Network.API.ILProtocol.Position> _repeated_positions_codec
        = pb::FieldCodec.ForMessage(34, global::DragonU3DSDK.Network.API.ILProtocol.Position.Parser);
    private readonly pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.Position> positions_ = new pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.Position>();
    /// <summary>
    /// 不按线赢钱的，使用这个数组
    /// </summary>
    public pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.Position> Positions {
      get { return positions_; }
    }

    private uint jackpotId_;
    /// <summary>
    /// 触发的jackpotId
    /// </summary>
    public uint JackpotId {
      get { return jackpotId_; }
      set {
        jackpotId_ = value;
      }
    }

    private uint freeSpinCount_;
    /// <summary>
    /// 触发了free spin的次数
    /// </summary>
    public uint FreeSpinCount {
      get { return freeSpinCount_; }
      set {
        freeSpinCount_ = value;
      }
    }

    private uint bonusGame_;
    /// <summary>
    /// 触发了bonus game
    /// </summary>
    public uint BonusGame {
      get { return bonusGame_; }
      set {
        bonusGame_ = value;
      }
    }

    private uint symbolCount_;
    /// <summary>
    /// 中奖图标个数
    /// </summary>
    public uint SymbolCount {
      get { return symbolCount_; }
      set {
        symbolCount_ = value;
      }
    }

    private uint bonusGameId_;
    /// <summary>
    /// 小游戏id
    /// </summary>
    public uint BonusGameId {
      get { return bonusGameId_; }
      set {
        bonusGameId_ = value;
      }
    }

    private uint reSpinCount_;
    /// <summary>
    /// 触发了reSpin的次数
    /// </summary>
    public uint ReSpinCount {
      get { return reSpinCount_; }
      set {
        reSpinCount_ = value;
      }
    }

    private uint freeSpinChoices_;
    /// <summary>
    /// 触发了可以选择的freeSpin游戏
    /// </summary>
    public uint FreeSpinChoices {
      get { return freeSpinChoices_; }
      set {
        freeSpinChoices_ = value;
      }
    }

    private bool showSymbolAnimation_;
    /// <summary>
    /// 是否要播放动画
    /// </summary>
    public bool ShowSymbolAnimation {
      get { return showSymbolAnimation_; }
      set {
        showSymbolAnimation_ = value;
      }
    }

    private ulong mask_;
    /// <summary>
    /// mask [1,1,1,0,0]表示7
    /// </summary>
    public ulong Mask {
      get { return mask_; }
      set {
        mask_ = value;
      }
    }

    private bool isMultiway_;
    /// <summary>
    /// 是否是multiway winLine
    /// </summary>
    public bool IsMultiway {
      get { return isMultiway_; }
      set {
        isMultiway_ = value;
      }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (PayLineId != 0) {
        output.WriteRawTag(8);
        output.WriteUInt32(PayLineId);
      }
      if (PayRuleId != 0) {
        output.WriteRawTag(16);
        output.WriteUInt32(PayRuleId);
      }
      if (Pay != 0) {
        output.WriteRawTag(24);
        output.WriteUInt32(Pay);
      }
      positions_.WriteTo(output, _repeated_positions_codec);
      if (JackpotId != 0) {
        output.WriteRawTag(40);
        output.WriteUInt32(JackpotId);
      }
      if (FreeSpinCount != 0) {
        output.WriteRawTag(48);
        output.WriteUInt32(FreeSpinCount);
      }
      if (BonusGame != 0) {
        output.WriteRawTag(56);
        output.WriteUInt32(BonusGame);
      }
      if (SymbolCount != 0) {
        output.WriteRawTag(64);
        output.WriteUInt32(SymbolCount);
      }
      if (BonusGameId != 0) {
        output.WriteRawTag(72);
        output.WriteUInt32(BonusGameId);
      }
      if (ReSpinCount != 0) {
        output.WriteRawTag(80);
        output.WriteUInt32(ReSpinCount);
      }
      if (FreeSpinChoices != 0) {
        output.WriteRawTag(88);
        output.WriteUInt32(FreeSpinChoices);
      }
      if (ShowSymbolAnimation != false) {
        output.WriteRawTag(96);
        output.WriteBool(ShowSymbolAnimation);
      }
      if (Mask != 0UL) {
        output.WriteRawTag(104);
        output.WriteUInt64(Mask);
      }
      if (IsMultiway != false) {
        output.WriteRawTag(112);
        output.WriteBool(IsMultiway);
      }
    }

    public int CalculateSize() {
      int size = 0;
      if (PayLineId != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(PayLineId);
      }
      if (PayRuleId != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(PayRuleId);
      }
      if (Pay != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Pay);
      }
      size += positions_.CalculateSize(_repeated_positions_codec);
      if (JackpotId != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(JackpotId);
      }
      if (FreeSpinCount != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(FreeSpinCount);
      }
      if (BonusGame != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(BonusGame);
      }
      if (SymbolCount != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(SymbolCount);
      }
      if (BonusGameId != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(BonusGameId);
      }
      if (ReSpinCount != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(ReSpinCount);
      }
      if (FreeSpinChoices != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(FreeSpinChoices);
      }
      if (ShowSymbolAnimation != false) {
        size += 1 + 1;
      }
      if (Mask != 0UL) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(Mask);
      }
      if (IsMultiway != false) {
        size += 1 + 1;
      }
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            PayLineId = input.ReadUInt32();
            break;
          }
          case 16: {
            PayRuleId = input.ReadUInt32();
            break;
          }
          case 24: {
            Pay = input.ReadUInt32();
            break;
          }
          case 34: {
            positions_.AddEntriesFrom(input, _repeated_positions_codec);
            break;
          }
          case 40: {
            JackpotId = input.ReadUInt32();
            break;
          }
          case 48: {
            FreeSpinCount = input.ReadUInt32();
            break;
          }
          case 56: {
            BonusGame = input.ReadUInt32();
            break;
          }
          case 64: {
            SymbolCount = input.ReadUInt32();
            break;
          }
          case 72: {
            BonusGameId = input.ReadUInt32();
            break;
          }
          case 80: {
            ReSpinCount = input.ReadUInt32();
            break;
          }
          case 88: {
            FreeSpinChoices = input.ReadUInt32();
            break;
          }
          case 96: {
            ShowSymbolAnimation = input.ReadBool();
            break;
          }
          case 104: {
            Mask = input.ReadUInt64();
            break;
          }
          case 112: {
            IsMultiway = input.ReadBool();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// 单个转轴
  /// </summary>
  public sealed class Reel : pb::IMessage {
    private static readonly pb::MessageParser<Reel> _parser = new pb::MessageParser<Reel>(() => new Reel());
    public static pb::MessageParser<Reel> Parser { get { return _parser; } }

    private static readonly pb::FieldCodec<uint> _repeated_symbols_codec
        = pb::FieldCodec.ForUInt32(10);
    private readonly pbc::RepeatedField<uint> symbols_ = new pbc::RepeatedField<uint>();
    /// <summary>
    /// </summary>
    public pbc::RepeatedField<uint> Symbols {
      get { return symbols_; }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      symbols_.WriteTo(output, _repeated_symbols_codec);
    }

    public int CalculateSize() {
      int size = 0;
      size += symbols_.CalculateSize(_repeated_symbols_codec);
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10:
          case 8: {
            symbols_.AddEntriesFrom(input, _repeated_symbols_codec);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// 一组转轴
  /// </summary>
  public sealed class Reels : pb::IMessage {
    private static readonly pb::MessageParser<Reels> _parser = new pb::MessageParser<Reels>(() => new Reels());
    public static pb::MessageParser<Reels> Parser { get { return _parser; } }

    private static readonly pb::FieldCodec<global::DragonU3DSDK.Network.API.ILProtocol.Reel> _repeated_reels_codec
        = pb::FieldCodec.ForMessage(26, global::DragonU3DSDK.Network.API.ILProtocol.Reel.Parser);
    private readonly pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.Reel> reels_ = new pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.Reel>();
    /// <summary>
    /// </summary>
    public pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.Reel> Reels_ {
      get { return reels_; }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      reels_.WriteTo(output, _repeated_reels_codec);
    }

    public int CalculateSize() {
      int size = 0;
      size += reels_.CalculateSize(_repeated_reels_codec);
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 26: {
            reels_.AddEntriesFrom(input, _repeated_reels_codec);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// 一列图标
  /// </summary>
  public sealed class Column : pb::IMessage {
    private static readonly pb::MessageParser<Column> _parser = new pb::MessageParser<Column>(() => new Column());
    public static pb::MessageParser<Column> Parser { get { return _parser; } }

    private static readonly pb::FieldCodec<uint> _repeated_symbols_codec
        = pb::FieldCodec.ForUInt32(10);
    private readonly pbc::RepeatedField<uint> symbols_ = new pbc::RepeatedField<uint>();
    /// <summary>
    /// 图标
    /// </summary>
    public pbc::RepeatedField<uint> Symbols {
      get { return symbols_; }
    }

    private uint stopPosition_;
    /// <summary>
    /// 停止位置
    /// </summary>
    public uint StopPosition {
      get { return stopPosition_; }
      set {
        stopPosition_ = value;
      }
    }

    private bool drumMode_;
    /// <summary>
    /// 播放drum mode
    /// </summary>
    public bool DrumMode {
      get { return drumMode_; }
      set {
        drumMode_ = value;
      }
    }

    private static readonly pb::FieldCodec<uint> _repeated_appearingRows_codec
        = pb::FieldCodec.ForUInt32(34);
    private readonly pbc::RepeatedField<uint> appearingRows_ = new pbc::RepeatedField<uint>();
    /// <summary>
    /// 播放appear动画的行
    /// </summary>
    public pbc::RepeatedField<uint> AppearingRows {
      get { return appearingRows_; }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      symbols_.WriteTo(output, _repeated_symbols_codec);
      if (StopPosition != 0) {
        output.WriteRawTag(16);
        output.WriteUInt32(StopPosition);
      }
      if (DrumMode != false) {
        output.WriteRawTag(24);
        output.WriteBool(DrumMode);
      }
      appearingRows_.WriteTo(output, _repeated_appearingRows_codec);
    }

    public int CalculateSize() {
      int size = 0;
      size += symbols_.CalculateSize(_repeated_symbols_codec);
      if (StopPosition != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(StopPosition);
      }
      if (DrumMode != false) {
        size += 1 + 1;
      }
      size += appearingRows_.CalculateSize(_repeated_appearingRows_codec);
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10:
          case 8: {
            symbols_.AddEntriesFrom(input, _repeated_symbols_codec);
            break;
          }
          case 16: {
            StopPosition = input.ReadUInt32();
            break;
          }
          case 24: {
            DrumMode = input.ReadBool();
            break;
          }
          case 34:
          case 32: {
            appearingRows_.AddEntriesFrom(input, _repeated_appearingRows_codec);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// 图标结果
  /// </summary>
  public sealed class Panel : pb::IMessage {
    private static readonly pb::MessageParser<Panel> _parser = new pb::MessageParser<Panel>(() => new Panel());
    public static pb::MessageParser<Panel> Parser { get { return _parser; } }

    private static readonly pb::FieldCodec<global::DragonU3DSDK.Network.API.ILProtocol.Column> _repeated_columns_codec
        = pb::FieldCodec.ForMessage(10, global::DragonU3DSDK.Network.API.ILProtocol.Column.Parser);
    private readonly pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.Column> columns_ = new pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.Column>();
    /// <summary>
    /// </summary>
    public pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.Column> Columns {
      get { return columns_; }
    }

    private string reelsId_ = "";
    /// <summary>
    /// </summary>
    public string ReelsId {
      get { return reelsId_; }
      set {
        reelsId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    private ulong winRate_;
    /// <summary>
    ///  赢钱倍数
    /// </summary>
    public ulong WinRate {
      get { return winRate_; }
      set {
        winRate_ = value;
      }
    }

    private static readonly pb::FieldCodec<global::DragonU3DSDK.Network.API.ILProtocol.WinLine> _repeated_winLines_codec
        = pb::FieldCodec.ForMessage(42, global::DragonU3DSDK.Network.API.ILProtocol.WinLine.Parser);
    private readonly pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.WinLine> winLines_ = new pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.WinLine>();
    /// <summary>
    /// 赢钱线
    /// </summary>
    public pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.WinLine> WinLines {
      get { return winLines_; }
    }

    private static readonly pb::FieldCodec<global::DragonU3DSDK.Network.API.ILProtocol.Panel.Types.ReelSubstitute> _repeated_substitutes_codec
        = pb::FieldCodec.ForMessage(50, global::DragonU3DSDK.Network.API.ILProtocol.Panel.Types.ReelSubstitute.Parser);
    private readonly pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.Panel.Types.ReelSubstitute> substitutes_ = new pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.Panel.Types.ReelSubstitute>();
    /// <summary>
    /// panel轴上symbol替换
    /// </summary>
    public pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.Panel.Types.ReelSubstitute> Substitutes {
      get { return substitutes_; }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      columns_.WriteTo(output, _repeated_columns_codec);
      if (ReelsId.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(ReelsId);
      }
      if (WinRate != 0UL) {
        output.WriteRawTag(24);
        output.WriteUInt64(WinRate);
      }
      winLines_.WriteTo(output, _repeated_winLines_codec);
      substitutes_.WriteTo(output, _repeated_substitutes_codec);
    }

    public int CalculateSize() {
      int size = 0;
      size += columns_.CalculateSize(_repeated_columns_codec);
      if (ReelsId.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ReelsId);
      }
      if (WinRate != 0UL) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(WinRate);
      }
      size += winLines_.CalculateSize(_repeated_winLines_codec);
      size += substitutes_.CalculateSize(_repeated_substitutes_codec);
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            columns_.AddEntriesFrom(input, _repeated_columns_codec);
            break;
          }
          case 18: {
            ReelsId = input.ReadString();
            break;
          }
          case 24: {
            WinRate = input.ReadUInt64();
            break;
          }
          case 42: {
            winLines_.AddEntriesFrom(input, _repeated_winLines_codec);
            break;
          }
          case 50: {
            substitutes_.AddEntriesFrom(input, _repeated_substitutes_codec);
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the Panel message type.</summary>
    public static class Types {
      public sealed class ReelSubstitute : pb::IMessage {
        private static readonly pb::MessageParser<ReelSubstitute> _parser = new pb::MessageParser<ReelSubstitute>(() => new ReelSubstitute());
        public static pb::MessageParser<ReelSubstitute> Parser { get { return _parser; } }

        private uint col_;
        public uint Col {
          get { return col_; }
          set {
            col_ = value;
          }
        }

        private static readonly pb::FieldCodec<uint> _repeated_pos_codec
            = pb::FieldCodec.ForUInt32(18);
        private readonly pbc::RepeatedField<uint> pos_ = new pbc::RepeatedField<uint>();
        public pbc::RepeatedField<uint> Pos {
          get { return pos_; }
        }

        private uint to_;
        public uint To {
          get { return to_; }
          set {
            to_ = value;
          }
        }

        public void WriteTo(pb::CodedOutputStream output) {
          if (Col != 0) {
            output.WriteRawTag(8);
            output.WriteUInt32(Col);
          }
          pos_.WriteTo(output, _repeated_pos_codec);
          if (To != 0) {
            output.WriteRawTag(24);
            output.WriteUInt32(To);
          }
        }

        public int CalculateSize() {
          int size = 0;
          if (Col != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Col);
          }
          size += pos_.CalculateSize(_repeated_pos_codec);
          if (To != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(To);
          }
          return size;
        }

        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                input.SkipLastField();
                break;
              case 8: {
                Col = input.ReadUInt32();
                break;
              }
              case 18:
              case 16: {
                pos_.AddEntriesFrom(input, _repeated_pos_codec);
                break;
              }
              case 24: {
                To = input.ReadUInt32();
                break;
              }
            }
          }
        }

      }

    }
    #endregion

  }

  /// <summary>
  /// 图标配置
  /// </summary>
  public sealed class SymbolConfig : pb::IMessage {
    private static readonly pb::MessageParser<SymbolConfig> _parser = new pb::MessageParser<SymbolConfig>(() => new SymbolConfig());
    public static pb::MessageParser<SymbolConfig> Parser { get { return _parser; } }

    private uint id_;
    /// <summary>
    /// </summary>
    public uint Id {
      get { return id_; }
      set {
        id_ = value;
      }
    }

    private global::DragonU3DSDK.Network.API.ILProtocol.SymbolType type_ = 0;
    /// <summary>
    /// </summary>
    public global::DragonU3DSDK.Network.API.ILProtocol.SymbolType Type {
      get { return type_; }
      set {
        type_ = value;
      }
    }

    private string icon_ = "";
    /// <summary>
    /// </summary>
    public string Icon {
      get { return icon_; }
      set {
        icon_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    private string name_ = "";
    /// <summary>
    /// </summary>
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    private uint multiple_;
    /// <summary>
    /// </summary>
    public uint Multiple {
      get { return multiple_; }
      set {
        multiple_ = value;
      }
    }

    private uint width_;
    /// <summary>
    /// </summary>
    public uint Width {
      get { return width_; }
      set {
        width_ = value;
      }
    }

    private uint height_;
    /// <summary>
    /// </summary>
    public uint Height {
      get { return height_; }
      set {
        height_ = value;
      }
    }

    private uint position_;
    /// <summary>
    /// </summary>
    public uint Position {
      get { return position_; }
      set {
        position_ = value;
      }
    }

    private string extras_ = "";
    /// <summary>
    /// extras
    /// </summary>
    public string Extras {
      get { return extras_; }
      set {
        extras_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    private uint rarity_;
    /// <summary>
    /// 稀有度
    /// </summary>
    public uint Rarity {
      get { return rarity_; }
      set {
        rarity_ = value;
      }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (Id != 0) {
        output.WriteRawTag(8);
        output.WriteUInt32(Id);
      }
      if (Type != 0) {
        output.WriteRawTag(16);
        output.WriteEnum((int) Type);
      }
      if (Icon.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(Icon);
      }
      if (Name.Length != 0) {
        output.WriteRawTag(34);
        output.WriteString(Name);
      }
      if (Multiple != 0) {
        output.WriteRawTag(40);
        output.WriteUInt32(Multiple);
      }
      if (Width != 0) {
        output.WriteRawTag(48);
        output.WriteUInt32(Width);
      }
      if (Height != 0) {
        output.WriteRawTag(56);
        output.WriteUInt32(Height);
      }
      if (Position != 0) {
        output.WriteRawTag(64);
        output.WriteUInt32(Position);
      }
      if (Extras.Length != 0) {
        output.WriteRawTag(74);
        output.WriteString(Extras);
      }
      if (Rarity != 0) {
        output.WriteRawTag(80);
        output.WriteUInt32(Rarity);
      }
    }

    public int CalculateSize() {
      int size = 0;
      if (Id != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Id);
      }
      if (Type != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Type);
      }
      if (Icon.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Icon);
      }
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (Multiple != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Multiple);
      }
      if (Width != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Width);
      }
      if (Height != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Height);
      }
      if (Position != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Position);
      }
      if (Extras.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Extras);
      }
      if (Rarity != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Rarity);
      }
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            Id = input.ReadUInt32();
            break;
          }
          case 16: {
            type_ = (global::DragonU3DSDK.Network.API.ILProtocol.SymbolType) input.ReadEnum();
            break;
          }
          case 26: {
            Icon = input.ReadString();
            break;
          }
          case 34: {
            Name = input.ReadString();
            break;
          }
          case 40: {
            Multiple = input.ReadUInt32();
            break;
          }
          case 48: {
            Width = input.ReadUInt32();
            break;
          }
          case 56: {
            Height = input.ReadUInt32();
            break;
          }
          case 64: {
            Position = input.ReadUInt32();
            break;
          }
          case 74: {
            Extras = input.ReadString();
            break;
          }
          case 80: {
            Rarity = input.ReadUInt32();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// jackpot配置
  /// </summary>
  public sealed class JackpotConfig : pb::IMessage {
    private static readonly pb::MessageParser<JackpotConfig> _parser = new pb::MessageParser<JackpotConfig>(() => new JackpotConfig());
    public static pb::MessageParser<JackpotConfig> Parser { get { return _parser; } }

    private uint jackpotId_;
    /// <summary>
    /// </summary>
    public uint JackpotId {
      get { return jackpotId_; }
      set {
        jackpotId_ = value;
      }
    }

    private global::DragonU3DSDK.Network.API.ILProtocol.JackpotType jackpotType_ = 0;
    /// <summary>
    /// </summary>
    public global::DragonU3DSDK.Network.API.ILProtocol.JackpotType JackpotType {
      get { return jackpotType_; }
      set {
        jackpotType_ = value;
      }
    }

    private uint minPay_;
    /// <summary>
    /// </summary>
    public uint MinPay {
      get { return minPay_; }
      set {
        minPay_ = value;
      }
    }

    private uint maxPay_;
    /// <summary>
    /// </summary>
    public uint MaxPay {
      get { return maxPay_; }
      set {
        maxPay_ = value;
      }
    }

    private uint interval_;
    /// <summary>
    /// </summary>
    public uint Interval {
      get { return interval_; }
      set {
        interval_ = value;
      }
    }

    private ulong unlockBet_;
    /// <summary>
    /// </summary>
    public ulong UnlockBet {
      get { return unlockBet_; }
      set {
        unlockBet_ = value;
      }
    }

    private uint weight_;
    /// <summary>
    /// </summary>
    public uint Weight {
      get { return weight_; }
      set {
        weight_ = value;
      }
    }

    private string name_ = "";
    /// <summary>
    /// </summary>
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (JackpotId != 0) {
        output.WriteRawTag(8);
        output.WriteUInt32(JackpotId);
      }
      if (JackpotType != 0) {
        output.WriteRawTag(16);
        output.WriteEnum((int) JackpotType);
      }
      if (MinPay != 0) {
        output.WriteRawTag(24);
        output.WriteUInt32(MinPay);
      }
      if (MaxPay != 0) {
        output.WriteRawTag(32);
        output.WriteUInt32(MaxPay);
      }
      if (Interval != 0) {
        output.WriteRawTag(40);
        output.WriteUInt32(Interval);
      }
      if (UnlockBet != 0UL) {
        output.WriteRawTag(48);
        output.WriteUInt64(UnlockBet);
      }
      if (Weight != 0) {
        output.WriteRawTag(56);
        output.WriteUInt32(Weight);
      }
      if (Name.Length != 0) {
        output.WriteRawTag(66);
        output.WriteString(Name);
      }
    }

    public int CalculateSize() {
      int size = 0;
      if (JackpotId != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(JackpotId);
      }
      if (JackpotType != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) JackpotType);
      }
      if (MinPay != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(MinPay);
      }
      if (MaxPay != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(MaxPay);
      }
      if (Interval != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Interval);
      }
      if (UnlockBet != 0UL) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(UnlockBet);
      }
      if (Weight != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Weight);
      }
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            JackpotId = input.ReadUInt32();
            break;
          }
          case 16: {
            jackpotType_ = (global::DragonU3DSDK.Network.API.ILProtocol.JackpotType) input.ReadEnum();
            break;
          }
          case 24: {
            MinPay = input.ReadUInt32();
            break;
          }
          case 32: {
            MaxPay = input.ReadUInt32();
            break;
          }
          case 40: {
            Interval = input.ReadUInt32();
            break;
          }
          case 48: {
            UnlockBet = input.ReadUInt64();
            break;
          }
          case 56: {
            Weight = input.ReadUInt32();
            break;
          }
          case 66: {
            Name = input.ReadString();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// jackpot状态
  /// </summary>
  public sealed class JackpotState : pb::IMessage {
    private static readonly pb::MessageParser<JackpotState> _parser = new pb::MessageParser<JackpotState>(() => new JackpotState());
    public static pb::MessageParser<JackpotState> Parser { get { return _parser; } }

    private uint jackpotId_;
    /// <summary>
    /// </summary>
    public uint JackpotId {
      get { return jackpotId_; }
      set {
        jackpotId_ = value;
      }
    }

    private uint jackpotValue_;
    /// <summary>
    /// </summary>
    public uint JackpotValue {
      get { return jackpotValue_; }
      set {
        jackpotValue_ = value;
      }
    }

    private float jackpotProgress_;
    /// <summary>
    /// jackpot当前进度
    /// </summary>
    public float JackpotProgress {
      get { return jackpotProgress_; }
      set {
        jackpotProgress_ = value;
      }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (JackpotId != 0) {
        output.WriteRawTag(8);
        output.WriteUInt32(JackpotId);
      }
      if (JackpotValue != 0) {
        output.WriteRawTag(16);
        output.WriteUInt32(JackpotValue);
      }
      if (JackpotProgress != 0F) {
        output.WriteRawTag(29);
        output.WriteFloat(JackpotProgress);
      }
    }

    public int CalculateSize() {
      int size = 0;
      if (JackpotId != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(JackpotId);
      }
      if (JackpotValue != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(JackpotValue);
      }
      if (JackpotProgress != 0F) {
        size += 1 + 4;
      }
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            JackpotId = input.ReadUInt32();
            break;
          }
          case 16: {
            JackpotValue = input.ReadUInt32();
            break;
          }
          case 29: {
            JackpotProgress = input.ReadFloat();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// 卷轴解锁配置
  /// </summary>
  public sealed class ReelUnlock : pb::IMessage {
    private static readonly pb::MessageParser<ReelUnlock> _parser = new pb::MessageParser<ReelUnlock>(() => new ReelUnlock());
    public static pb::MessageParser<ReelUnlock> Parser { get { return _parser; } }

    private uint levelMin_;
    public uint LevelMin {
      get { return levelMin_; }
      set {
        levelMin_ = value;
      }
    }

    private uint levelMax_;
    public uint LevelMax {
      get { return levelMax_; }
      set {
        levelMax_ = value;
      }
    }

    private static readonly pb::FieldCodec<ulong> _repeated_unlockBet_codec
        = pb::FieldCodec.ForUInt64(26);
    private readonly pbc::RepeatedField<ulong> unlockBet_ = new pbc::RepeatedField<ulong>();
    /// <summary>
    /// 解锁所需bet
    /// </summary>
    public pbc::RepeatedField<ulong> UnlockBet {
      get { return unlockBet_; }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (LevelMin != 0) {
        output.WriteRawTag(8);
        output.WriteUInt32(LevelMin);
      }
      if (LevelMax != 0) {
        output.WriteRawTag(16);
        output.WriteUInt32(LevelMax);
      }
      unlockBet_.WriteTo(output, _repeated_unlockBet_codec);
    }

    public int CalculateSize() {
      int size = 0;
      if (LevelMin != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(LevelMin);
      }
      if (LevelMax != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(LevelMax);
      }
      size += unlockBet_.CalculateSize(_repeated_unlockBet_codec);
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            LevelMin = input.ReadUInt32();
            break;
          }
          case 16: {
            LevelMax = input.ReadUInt32();
            break;
          }
          case 26:
          case 24: {
            unlockBet_.AddEntriesFrom(input, _repeated_unlockBet_codec);
            break;
          }
        }
      }
    }

  }

  public sealed class MachineUnlockValue : pb::IMessage {
    private static readonly pb::MessageParser<MachineUnlockValue> _parser = new pb::MessageParser<MachineUnlockValue>(() => new MachineUnlockValue());
    public static pb::MessageParser<MachineUnlockValue> Parser { get { return _parser; } }

    private ulong value_;
    public ulong Value {
      get { return value_; }
      set {
        value_ = value;
      }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (Value != 0UL) {
        output.WriteRawTag(8);
        output.WriteUInt64(Value);
      }
    }

    public int CalculateSize() {
      int size = 0;
      if (Value != 0UL) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(Value);
      }
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            Value = input.ReadUInt64();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// 游戏配置
  /// </summary>
  public sealed class GameConfig : pb::IMessage {
    private static readonly pb::MessageParser<GameConfig> _parser = new pb::MessageParser<GameConfig>(() => new GameConfig());
    public static pb::MessageParser<GameConfig> Parser { get { return _parser; } }

    private string gameId_ = "";
    /// <summary>
    /// </summary>
    public string GameId {
      get { return gameId_; }
      set {
        gameId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    private string gameName_ = "";
    /// <summary>
    /// </summary>
    public string GameName {
      get { return gameName_; }
      set {
        gameName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    private global::DragonU3DSDK.Network.API.ILProtocol.GameMode gameMode_ = 0;
    /// <summary>
    /// </summary>
    public global::DragonU3DSDK.Network.API.ILProtocol.GameMode GameMode {
      get { return gameMode_; }
      set {
        gameMode_ = value;
      }
    }

    private static readonly pb::FieldCodec<string> _repeated_resourceUrls_codec
        = pb::FieldCodec.ForString(34);
    private readonly pbc::RepeatedField<string> resourceUrls_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// </summary>
    public pbc::RepeatedField<string> ResourceUrls {
      get { return resourceUrls_; }
    }

    private uint unlockLevel_;
    /// <summary>
    /// </summary>
    public uint UnlockLevel {
      get { return unlockLevel_; }
      set {
        unlockLevel_ = value;
      }
    }

    private static readonly pb::FieldCodec<global::DragonU3DSDK.Network.API.ILProtocol.JackpotConfig> _repeated_jackpotConfigs_codec
        = pb::FieldCodec.ForMessage(50, global::DragonU3DSDK.Network.API.ILProtocol.JackpotConfig.Parser);
    private readonly pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.JackpotConfig> jackpotConfigs_ = new pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.JackpotConfig>();
    /// <summary>
    /// </summary>
    public pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.JackpotConfig> JackpotConfigs {
      get { return jackpotConfigs_; }
    }

    private static readonly pb::FieldCodec<global::DragonU3DSDK.Network.API.ILProtocol.SymbolConfig> _repeated_symbolConfigs_codec
        = pb::FieldCodec.ForMessage(58, global::DragonU3DSDK.Network.API.ILProtocol.SymbolConfig.Parser);
    private readonly pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.SymbolConfig> symbolConfigs_ = new pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.SymbolConfig>();
    /// <summary>
    /// </summary>
    public pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.SymbolConfig> SymbolConfigs {
      get { return symbolConfigs_; }
    }

    private static readonly pb::FieldCodec<global::DragonU3DSDK.Network.API.ILProtocol.GameBetConfig> _repeated_bets_codec
        = pb::FieldCodec.ForMessage(66, global::DragonU3DSDK.Network.API.ILProtocol.GameBetConfig.Parser);
    private readonly pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.GameBetConfig> bets_ = new pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.GameBetConfig>();
    /// <summary>
    /// </summary>
    public pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.GameBetConfig> Bets {
      get { return bets_; }
    }

    private static readonly pbc::MapField<string, global::DragonU3DSDK.Network.API.ILProtocol.Reels>.Codec _map_reelsMap_codec
        = new pbc::MapField<string, global::DragonU3DSDK.Network.API.ILProtocol.Reels>.Codec(pb::FieldCodec.ForString(10), pb::FieldCodec.ForMessage(18, global::DragonU3DSDK.Network.API.ILProtocol.Reels.Parser), 74);
    private readonly pbc::MapField<string, global::DragonU3DSDK.Network.API.ILProtocol.Reels> reelsMap_ = new pbc::MapField<string, global::DragonU3DSDK.Network.API.ILProtocol.Reels>();
    /// <summary>
    /// </summary>
    public pbc::MapField<string, global::DragonU3DSDK.Network.API.ILProtocol.Reels> ReelsMap {
      get { return reelsMap_; }
    }

    private static readonly pb::FieldCodec<global::DragonU3DSDK.Network.API.ILProtocol.PayLine> _repeated_payLines_codec
        = pb::FieldCodec.ForMessage(82, global::DragonU3DSDK.Network.API.ILProtocol.PayLine.Parser);
    private readonly pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.PayLine> payLines_ = new pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.PayLine>();
    /// <summary>
    /// </summary>
    public pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.PayLine> PayLines {
      get { return payLines_; }
    }

    private static readonly pb::FieldCodec<global::DragonU3DSDK.Network.API.ILProtocol.PayRule> _repeated_payRules_codec
        = pb::FieldCodec.ForMessage(90, global::DragonU3DSDK.Network.API.ILProtocol.PayRule.Parser);
    private readonly pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.PayRule> payRules_ = new pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.PayRule>();
    /// <summary>
    /// </summary>
    public pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.PayRule> PayRules {
      get { return payRules_; }
    }

    private bool isFullLine_;
    /// <summary>
    /// 是否为满线模式
    /// </summary>
    public bool IsFullLine {
      get { return isFullLine_; }
      set {
        isFullLine_ = value;
      }
    }

    private global::DragonU3DSDK.Network.API.ILProtocol.LineDirection lineDirection_ = 0;
    /// <summary>
    /// 赢钱线方向
    /// </summary>
    public global::DragonU3DSDK.Network.API.ILProtocol.LineDirection LineDirection {
      get { return lineDirection_; }
      set {
        lineDirection_ = value;
      }
    }

    private static readonly pb::FieldCodec<global::DragonU3DSDK.Network.API.ILProtocol.GameUnlockConfig> _repeated_unlocks_codec
        = pb::FieldCodec.ForMessage(114, global::DragonU3DSDK.Network.API.ILProtocol.GameUnlockConfig.Parser);
    private readonly pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.GameUnlockConfig> unlocks_ = new pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.GameUnlockConfig>();
    /// <summary>
    /// feature解锁
    /// </summary>
    public pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.GameUnlockConfig> Unlocks {
      get { return unlocks_; }
    }

    private bool flagBig_;
    /// <summary>
    /// </summary>
    public bool FlagBig {
      get { return flagBig_; }
      set {
        flagBig_ = value;
      }
    }

    private bool flagHot_;
    /// <summary>
    /// </summary>
    public bool FlagHot {
      get { return flagHot_; }
      set {
        flagHot_ = value;
      }
    }

    private bool flagNew_;
    /// <summary>
    /// </summary>
    public bool FlagNew {
      get { return flagNew_; }
      set {
        flagNew_ = value;
      }
    }

    private bool flagTop_;
    /// <summary>
    /// </summary>
    public bool FlagTop {
      get { return flagTop_; }
      set {
        flagTop_ = value;
      }
    }

    private global::DragonU3DSDK.Network.API.ILProtocol.GameOrientation gameOrientation_ = 0;
    /// <summary>
    /// 游戏朝向
    /// </summary>
    public global::DragonU3DSDK.Network.API.ILProtocol.GameOrientation GameOrientation {
      get { return gameOrientation_; }
      set {
        gameOrientation_ = value;
      }
    }

    private static readonly pb::FieldCodec<global::DragonU3DSDK.Network.API.ILProtocol.ReelUnlock> _repeated_reelUnlock_codec
        = pb::FieldCodec.ForMessage(170, global::DragonU3DSDK.Network.API.ILProtocol.ReelUnlock.Parser);
    private readonly pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.ReelUnlock> reelUnlock_ = new pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.ReelUnlock>();
    /// <summary>
    /// 卷轴解锁配置
    /// </summary>
    public pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.ReelUnlock> ReelUnlock {
      get { return reelUnlock_; }
    }

    private string extraInfo_ = "";
    /// <summary>
    /// json扩展数据
    /// </summary>
    public string ExtraInfo {
      get { return extraInfo_; }
      set {
        extraInfo_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    private global::DragonU3DSDK.Network.API.ILProtocol.AnyStruct extraInfoPb_;
    /// <summary>
    /// pb格式扩展字段
    /// </summary>
    public global::DragonU3DSDK.Network.API.ILProtocol.AnyStruct ExtraInfoPb {
      get { return extraInfoPb_; }
      set {
        extraInfoPb_ = value;
      }
    }

    private static readonly pb::FieldCodec<string> _repeated_cheatIds_codec
        = pb::FieldCodec.ForString(194);
    private readonly pbc::RepeatedField<string> cheatIds_ = new pbc::RepeatedField<string>();
    public pbc::RepeatedField<string> CheatIds {
      get { return cheatIds_; }
    }

    private static readonly pb::FieldCodec<global::DragonU3DSDK.Network.API.ILProtocol.JackpotState> _repeated_jackpotState_codec
        = pb::FieldCodec.ForMessage(202, global::DragonU3DSDK.Network.API.ILProtocol.JackpotState.Parser);
    private readonly pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.JackpotState> jackpotState_ = new pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.JackpotState>();
    /// <summary>
    /// 大厅展示需要jackpotState, 给个数组，目前只要最大的
    /// </summary>
    public pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.JackpotState> JackpotState {
      get { return jackpotState_; }
    }

    private bool flagComingSoon_;
    /// <summary>
    /// </summary>
    public bool FlagComingSoon {
      get { return flagComingSoon_; }
      set {
        flagComingSoon_ = value;
      }
    }

    private string gameImg_ = "";
    public string GameImg {
      get { return gameImg_; }
      set {
        gameImg_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    private static readonly pbc::MapField<uint, global::DragonU3DSDK.Network.API.ILProtocol.MachineUnlockValue>.Codec _map_unlockCondition_codec
        = new pbc::MapField<uint, global::DragonU3DSDK.Network.API.ILProtocol.MachineUnlockValue>.Codec(pb::FieldCodec.ForUInt32(8), pb::FieldCodec.ForMessage(18, global::DragonU3DSDK.Network.API.ILProtocol.MachineUnlockValue.Parser), 226);
    private readonly pbc::MapField<uint, global::DragonU3DSDK.Network.API.ILProtocol.MachineUnlockValue> unlockCondition_ = new pbc::MapField<uint, global::DragonU3DSDK.Network.API.ILProtocol.MachineUnlockValue>();
    /// <summary>
    /// 机台解锁条件
    /// </summary>
    public pbc::MapField<uint, global::DragonU3DSDK.Network.API.ILProtocol.MachineUnlockValue> UnlockCondition {
      get { return unlockCondition_; }
    }

    private static readonly pbc::MapField<uint, global::DragonU3DSDK.Network.API.ILProtocol.MachineUnlockValue>.Codec _map_showUnlockCondition_codec
        = new pbc::MapField<uint, global::DragonU3DSDK.Network.API.ILProtocol.MachineUnlockValue>.Codec(pb::FieldCodec.ForUInt32(8), pb::FieldCodec.ForMessage(18, global::DragonU3DSDK.Network.API.ILProtocol.MachineUnlockValue.Parser), 234);
    private readonly pbc::MapField<uint, global::DragonU3DSDK.Network.API.ILProtocol.MachineUnlockValue> showUnlockCondition_ = new pbc::MapField<uint, global::DragonU3DSDK.Network.API.ILProtocol.MachineUnlockValue>();
    /// <summary>
    /// 机台解锁展示条件
    /// </summary>
    public pbc::MapField<uint, global::DragonU3DSDK.Network.API.ILProtocol.MachineUnlockValue> ShowUnlockCondition {
      get { return showUnlockCondition_; }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (GameId.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(GameId);
      }
      if (GameName.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(GameName);
      }
      if (GameMode != 0) {
        output.WriteRawTag(24);
        output.WriteEnum((int) GameMode);
      }
      resourceUrls_.WriteTo(output, _repeated_resourceUrls_codec);
      if (UnlockLevel != 0) {
        output.WriteRawTag(40);
        output.WriteUInt32(UnlockLevel);
      }
      jackpotConfigs_.WriteTo(output, _repeated_jackpotConfigs_codec);
      symbolConfigs_.WriteTo(output, _repeated_symbolConfigs_codec);
      bets_.WriteTo(output, _repeated_bets_codec);
      reelsMap_.WriteTo(output, _map_reelsMap_codec);
      payLines_.WriteTo(output, _repeated_payLines_codec);
      payRules_.WriteTo(output, _repeated_payRules_codec);
      if (IsFullLine != false) {
        output.WriteRawTag(96);
        output.WriteBool(IsFullLine);
      }
      if (LineDirection != 0) {
        output.WriteRawTag(104);
        output.WriteEnum((int) LineDirection);
      }
      unlocks_.WriteTo(output, _repeated_unlocks_codec);
      if (FlagBig != false) {
        output.WriteRawTag(128, 1);
        output.WriteBool(FlagBig);
      }
      if (FlagHot != false) {
        output.WriteRawTag(136, 1);
        output.WriteBool(FlagHot);
      }
      if (FlagNew != false) {
        output.WriteRawTag(144, 1);
        output.WriteBool(FlagNew);
      }
      if (FlagTop != false) {
        output.WriteRawTag(152, 1);
        output.WriteBool(FlagTop);
      }
      if (GameOrientation != 0) {
        output.WriteRawTag(160, 1);
        output.WriteEnum((int) GameOrientation);
      }
      reelUnlock_.WriteTo(output, _repeated_reelUnlock_codec);
      if (ExtraInfo.Length != 0) {
        output.WriteRawTag(178, 1);
        output.WriteString(ExtraInfo);
      }
      if (extraInfoPb_ != null) {
        output.WriteRawTag(186, 1);
        output.WriteMessage(ExtraInfoPb);
      }
      cheatIds_.WriteTo(output, _repeated_cheatIds_codec);
      jackpotState_.WriteTo(output, _repeated_jackpotState_codec);
      if (FlagComingSoon != false) {
        output.WriteRawTag(208, 1);
        output.WriteBool(FlagComingSoon);
      }
      if (GameImg.Length != 0) {
        output.WriteRawTag(218, 1);
        output.WriteString(GameImg);
      }
      unlockCondition_.WriteTo(output, _map_unlockCondition_codec);
      showUnlockCondition_.WriteTo(output, _map_showUnlockCondition_codec);
    }

    public int CalculateSize() {
      int size = 0;
      if (GameId.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(GameId);
      }
      if (GameName.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(GameName);
      }
      if (GameMode != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) GameMode);
      }
      size += resourceUrls_.CalculateSize(_repeated_resourceUrls_codec);
      if (UnlockLevel != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(UnlockLevel);
      }
      size += jackpotConfigs_.CalculateSize(_repeated_jackpotConfigs_codec);
      size += symbolConfigs_.CalculateSize(_repeated_symbolConfigs_codec);
      size += bets_.CalculateSize(_repeated_bets_codec);
      size += reelsMap_.CalculateSize(_map_reelsMap_codec);
      size += payLines_.CalculateSize(_repeated_payLines_codec);
      size += payRules_.CalculateSize(_repeated_payRules_codec);
      if (IsFullLine != false) {
        size += 1 + 1;
      }
      if (LineDirection != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) LineDirection);
      }
      size += unlocks_.CalculateSize(_repeated_unlocks_codec);
      if (FlagBig != false) {
        size += 2 + 1;
      }
      if (FlagHot != false) {
        size += 2 + 1;
      }
      if (FlagNew != false) {
        size += 2 + 1;
      }
      if (FlagTop != false) {
        size += 2 + 1;
      }
      if (GameOrientation != 0) {
        size += 2 + pb::CodedOutputStream.ComputeEnumSize((int) GameOrientation);
      }
      size += reelUnlock_.CalculateSize(_repeated_reelUnlock_codec);
      if (ExtraInfo.Length != 0) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(ExtraInfo);
      }
      if (extraInfoPb_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(ExtraInfoPb);
      }
      size += cheatIds_.CalculateSize(_repeated_cheatIds_codec);
      size += jackpotState_.CalculateSize(_repeated_jackpotState_codec);
      if (FlagComingSoon != false) {
        size += 2 + 1;
      }
      if (GameImg.Length != 0) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(GameImg);
      }
      size += unlockCondition_.CalculateSize(_map_unlockCondition_codec);
      size += showUnlockCondition_.CalculateSize(_map_showUnlockCondition_codec);
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            GameId = input.ReadString();
            break;
          }
          case 18: {
            GameName = input.ReadString();
            break;
          }
          case 24: {
            gameMode_ = (global::DragonU3DSDK.Network.API.ILProtocol.GameMode) input.ReadEnum();
            break;
          }
          case 34: {
            resourceUrls_.AddEntriesFrom(input, _repeated_resourceUrls_codec);
            break;
          }
          case 40: {
            UnlockLevel = input.ReadUInt32();
            break;
          }
          case 50: {
            jackpotConfigs_.AddEntriesFrom(input, _repeated_jackpotConfigs_codec);
            break;
          }
          case 58: {
            symbolConfigs_.AddEntriesFrom(input, _repeated_symbolConfigs_codec);
            break;
          }
          case 66: {
            bets_.AddEntriesFrom(input, _repeated_bets_codec);
            break;
          }
          case 74: {
            reelsMap_.AddEntriesFrom(input, _map_reelsMap_codec);
            break;
          }
          case 82: {
            payLines_.AddEntriesFrom(input, _repeated_payLines_codec);
            break;
          }
          case 90: {
            payRules_.AddEntriesFrom(input, _repeated_payRules_codec);
            break;
          }
          case 96: {
            IsFullLine = input.ReadBool();
            break;
          }
          case 104: {
            lineDirection_ = (global::DragonU3DSDK.Network.API.ILProtocol.LineDirection) input.ReadEnum();
            break;
          }
          case 114: {
            unlocks_.AddEntriesFrom(input, _repeated_unlocks_codec);
            break;
          }
          case 128: {
            FlagBig = input.ReadBool();
            break;
          }
          case 136: {
            FlagHot = input.ReadBool();
            break;
          }
          case 144: {
            FlagNew = input.ReadBool();
            break;
          }
          case 152: {
            FlagTop = input.ReadBool();
            break;
          }
          case 160: {
            gameOrientation_ = (global::DragonU3DSDK.Network.API.ILProtocol.GameOrientation) input.ReadEnum();
            break;
          }
          case 170: {
            reelUnlock_.AddEntriesFrom(input, _repeated_reelUnlock_codec);
            break;
          }
          case 178: {
            ExtraInfo = input.ReadString();
            break;
          }
          case 186: {
            if (extraInfoPb_ == null) {
              extraInfoPb_ = new global::DragonU3DSDK.Network.API.ILProtocol.AnyStruct();
            }
            input.ReadMessage(extraInfoPb_);
            break;
          }
          case 194: {
            cheatIds_.AddEntriesFrom(input, _repeated_cheatIds_codec);
            break;
          }
          case 202: {
            jackpotState_.AddEntriesFrom(input, _repeated_jackpotState_codec);
            break;
          }
          case 208: {
            FlagComingSoon = input.ReadBool();
            break;
          }
          case 218: {
            GameImg = input.ReadString();
            break;
          }
          case 226: {
            unlockCondition_.AddEntriesFrom(input, _map_unlockCondition_codec);
            break;
          }
          case 234: {
            showUnlockCondition_.AddEntriesFrom(input, _map_showUnlockCondition_codec);
            break;
          }
        }
      }
    }

  }

  public sealed class GameBetConfig : pb::IMessage {
    private static readonly pb::MessageParser<GameBetConfig> _parser = new pb::MessageParser<GameBetConfig>(() => new GameBetConfig());
    public static pb::MessageParser<GameBetConfig> Parser { get { return _parser; } }

    private uint levelMin_;
    public uint LevelMin {
      get { return levelMin_; }
      set {
        levelMin_ = value;
      }
    }

    private uint levelMax_;
    public uint LevelMax {
      get { return levelMax_; }
      set {
        levelMax_ = value;
      }
    }

    private static readonly pb::FieldCodec<ulong> _repeated_bets_codec
        = pb::FieldCodec.ForUInt64(26);
    private readonly pbc::RepeatedField<ulong> bets_ = new pbc::RepeatedField<ulong>();
    public pbc::RepeatedField<ulong> Bets {
      get { return bets_; }
    }

    private static readonly pb::FieldCodec<uint> _repeated_unlockJackpot_codec
        = pb::FieldCodec.ForUInt32(34);
    private readonly pbc::RepeatedField<uint> unlockJackpot_ = new pbc::RepeatedField<uint>();
    public pbc::RepeatedField<uint> UnlockJackpot {
      get { return unlockJackpot_; }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (LevelMin != 0) {
        output.WriteRawTag(8);
        output.WriteUInt32(LevelMin);
      }
      if (LevelMax != 0) {
        output.WriteRawTag(16);
        output.WriteUInt32(LevelMax);
      }
      bets_.WriteTo(output, _repeated_bets_codec);
      unlockJackpot_.WriteTo(output, _repeated_unlockJackpot_codec);
    }

    public int CalculateSize() {
      int size = 0;
      if (LevelMin != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(LevelMin);
      }
      if (LevelMax != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(LevelMax);
      }
      size += bets_.CalculateSize(_repeated_bets_codec);
      size += unlockJackpot_.CalculateSize(_repeated_unlockJackpot_codec);
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            LevelMin = input.ReadUInt32();
            break;
          }
          case 16: {
            LevelMax = input.ReadUInt32();
            break;
          }
          case 26:
          case 24: {
            bets_.AddEntriesFrom(input, _repeated_bets_codec);
            break;
          }
          case 34:
          case 32: {
            unlockJackpot_.AddEntriesFrom(input, _repeated_unlockJackpot_codec);
            break;
          }
        }
      }
    }

  }

  public sealed class GameUnlockConfig : pb::IMessage {
    private static readonly pb::MessageParser<GameUnlockConfig> _parser = new pb::MessageParser<GameUnlockConfig>(() => new GameUnlockConfig());
    public static pb::MessageParser<GameUnlockConfig> Parser { get { return _parser; } }

    private uint levelMin_;
    public uint LevelMin {
      get { return levelMin_; }
      set {
        levelMin_ = value;
      }
    }

    private uint levelMax_;
    public uint LevelMax {
      get { return levelMax_; }
      set {
        levelMax_ = value;
      }
    }

    private static readonly pb::FieldCodec<ulong> _repeated_unlockBets_codec
        = pb::FieldCodec.ForUInt64(26);
    private readonly pbc::RepeatedField<ulong> unlockBets_ = new pbc::RepeatedField<ulong>();
    public pbc::RepeatedField<ulong> UnlockBets {
      get { return unlockBets_; }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (LevelMin != 0) {
        output.WriteRawTag(8);
        output.WriteUInt32(LevelMin);
      }
      if (LevelMax != 0) {
        output.WriteRawTag(16);
        output.WriteUInt32(LevelMax);
      }
      unlockBets_.WriteTo(output, _repeated_unlockBets_codec);
    }

    public int CalculateSize() {
      int size = 0;
      if (LevelMin != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(LevelMin);
      }
      if (LevelMax != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(LevelMax);
      }
      size += unlockBets_.CalculateSize(_repeated_unlockBets_codec);
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            LevelMin = input.ReadUInt32();
            break;
          }
          case 16: {
            LevelMax = input.ReadUInt32();
            break;
          }
          case 26:
          case 24: {
            unlockBets_.AddEntriesFrom(input, _repeated_unlockBets_codec);
            break;
          }
        }
      }
    }

  }

  public sealed class FreeSpinInfo : pb::IMessage {
    private static readonly pb::MessageParser<FreeSpinInfo> _parser = new pb::MessageParser<FreeSpinInfo>(() => new FreeSpinInfo());
    public static pb::MessageParser<FreeSpinInfo> Parser { get { return _parser; } }

    private uint freeSpinCount_;
    /// <summary>
    /// 免费游戏剩余次数
    /// </summary>
    public uint FreeSpinCount {
      get { return freeSpinCount_; }
      set {
        freeSpinCount_ = value;
      }
    }

    private ulong freeSpinBet_;
    /// <summary>
    /// 免费游戏投注金额
    /// </summary>
    public ulong FreeSpinBet {
      get { return freeSpinBet_; }
      set {
        freeSpinBet_ = value;
      }
    }

    private uint freeSpinTotalCount_;
    /// <summary>
    /// 免费游戏最大次数
    /// </summary>
    public uint FreeSpinTotalCount {
      get { return freeSpinTotalCount_; }
      set {
        freeSpinTotalCount_ = value;
      }
    }

    private ulong freeSpinTotalWin_;
    /// <summary>
    ///免费游戏总赢钱数量
    /// </summary>
    public ulong FreeSpinTotalWin {
      get { return freeSpinTotalWin_; }
      set {
        freeSpinTotalWin_ = value;
      }
    }

    private uint freeSpinId_;
    /// <summary>
    /// 可选free spin的id
    /// </summary>
    public uint FreeSpinId {
      get { return freeSpinId_; }
      set {
        freeSpinId_ = value;
      }
    }

    private uint freeSpinChoices_;
    /// <summary>
    /// 剩余的可以选择的freeSpin游戏
    /// </summary>
    public uint FreeSpinChoices {
      get { return freeSpinChoices_; }
      set {
        freeSpinChoices_ = value;
      }
    }

    private static readonly pb::FieldCodec<global::DragonU3DSDK.Network.API.ILProtocol.Panel> _repeated_triggeringPanels_codec
        = pb::FieldCodec.ForMessage(58, global::DragonU3DSDK.Network.API.ILProtocol.Panel.Parser);
    private readonly pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.Panel> triggeringPanels_ = new pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.Panel>();
    /// <summary>
    /// 触发此状态时的panels
    /// </summary>
    public pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.Panel> TriggeringPanels {
      get { return triggeringPanels_; }
    }

    private bool isOver_;
    /// <summary>
    /// 是否freeSpin结束，结算完毕
    /// </summary>
    public bool IsOver {
      get { return isOver_; }
      set {
        isOver_ = value;
      }
    }

    private bool isAvgBet_;
    /// <summary>
    ///是否是avgBet
    /// </summary>
    public bool IsAvgBet {
      get { return isAvgBet_; }
      set {
        isAvgBet_ = value;
      }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (FreeSpinCount != 0) {
        output.WriteRawTag(8);
        output.WriteUInt32(FreeSpinCount);
      }
      if (FreeSpinBet != 0UL) {
        output.WriteRawTag(16);
        output.WriteUInt64(FreeSpinBet);
      }
      if (FreeSpinTotalCount != 0) {
        output.WriteRawTag(24);
        output.WriteUInt32(FreeSpinTotalCount);
      }
      if (FreeSpinTotalWin != 0UL) {
        output.WriteRawTag(32);
        output.WriteUInt64(FreeSpinTotalWin);
      }
      if (FreeSpinId != 0) {
        output.WriteRawTag(40);
        output.WriteUInt32(FreeSpinId);
      }
      if (FreeSpinChoices != 0) {
        output.WriteRawTag(48);
        output.WriteUInt32(FreeSpinChoices);
      }
      triggeringPanels_.WriteTo(output, _repeated_triggeringPanels_codec);
      if (IsOver != false) {
        output.WriteRawTag(64);
        output.WriteBool(IsOver);
      }
      if (IsAvgBet != false) {
        output.WriteRawTag(72);
        output.WriteBool(IsAvgBet);
      }
    }

    public int CalculateSize() {
      int size = 0;
      if (FreeSpinCount != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(FreeSpinCount);
      }
      if (FreeSpinBet != 0UL) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(FreeSpinBet);
      }
      if (FreeSpinTotalCount != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(FreeSpinTotalCount);
      }
      if (FreeSpinTotalWin != 0UL) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(FreeSpinTotalWin);
      }
      if (FreeSpinId != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(FreeSpinId);
      }
      if (FreeSpinChoices != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(FreeSpinChoices);
      }
      size += triggeringPanels_.CalculateSize(_repeated_triggeringPanels_codec);
      if (IsOver != false) {
        size += 1 + 1;
      }
      if (IsAvgBet != false) {
        size += 1 + 1;
      }
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            FreeSpinCount = input.ReadUInt32();
            break;
          }
          case 16: {
            FreeSpinBet = input.ReadUInt64();
            break;
          }
          case 24: {
            FreeSpinTotalCount = input.ReadUInt32();
            break;
          }
          case 32: {
            FreeSpinTotalWin = input.ReadUInt64();
            break;
          }
          case 40: {
            FreeSpinId = input.ReadUInt32();
            break;
          }
          case 48: {
            FreeSpinChoices = input.ReadUInt32();
            break;
          }
          case 58: {
            triggeringPanels_.AddEntriesFrom(input, _repeated_triggeringPanels_codec);
            break;
          }
          case 64: {
            IsOver = input.ReadBool();
            break;
          }
          case 72: {
            IsAvgBet = input.ReadBool();
            break;
          }
        }
      }
    }

  }

  public sealed class ReSpinInfo : pb::IMessage {
    private static readonly pb::MessageParser<ReSpinInfo> _parser = new pb::MessageParser<ReSpinInfo>(() => new ReSpinInfo());
    public static pb::MessageParser<ReSpinInfo> Parser { get { return _parser; } }

    private uint reSpinCount_;
    /// <summary>
    /// 剩余ReSpin次数
    /// </summary>
    public uint ReSpinCount {
      get { return reSpinCount_; }
      set {
        reSpinCount_ = value;
      }
    }

    private uint reSpinLimit_;
    /// <summary>
    /// ReSpin上限
    /// </summary>
    public uint ReSpinLimit {
      get { return reSpinLimit_; }
      set {
        reSpinLimit_ = value;
      }
    }

    private ulong reSpinBet_;
    /// <summary>
    /// ReSpin的投注
    /// </summary>
    public ulong ReSpinBet {
      get { return reSpinBet_; }
      set {
        reSpinBet_ = value;
      }
    }

    private ulong reSpinTotalWin_;
    /// <summary>
    /// ReSpinTotalWin
    /// </summary>
    public ulong ReSpinTotalWin {
      get { return reSpinTotalWin_; }
      set {
        reSpinTotalWin_ = value;
      }
    }

    private static readonly pb::FieldCodec<global::DragonU3DSDK.Network.API.ILProtocol.Panel> _repeated_triggeringPanels_codec
        = pb::FieldCodec.ForMessage(42, global::DragonU3DSDK.Network.API.ILProtocol.Panel.Parser);
    private readonly pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.Panel> triggeringPanels_ = new pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.Panel>();
    /// <summary>
    /// 触发此状态时的panels
    /// </summary>
    public pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.Panel> TriggeringPanels {
      get { return triggeringPanels_; }
    }

    private static readonly pb::FieldCodec<uint> _repeated_reelsMapping_codec
        = pb::FieldCodec.ForUInt32(50);
    private readonly pbc::RepeatedField<uint> reelsMapping_ = new pbc::RepeatedField<uint>();
    /// <summary>
    /// link玩法位置与卷轴映射表
    /// </summary>
    public pbc::RepeatedField<uint> ReelsMapping {
      get { return reelsMapping_; }
    }

    private bool isOver_;
    /// <summary>
    /// 是否reSpin结束,结算完毕
    /// </summary>
    public bool IsOver {
      get { return isOver_; }
      set {
        isOver_ = value;
      }
    }

    private bool isAvgBet_;
    /// <summary>
    ///是否是avgBet
    /// </summary>
    public bool IsAvgBet {
      get { return isAvgBet_; }
      set {
        isAvgBet_ = value;
      }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (ReSpinCount != 0) {
        output.WriteRawTag(8);
        output.WriteUInt32(ReSpinCount);
      }
      if (ReSpinLimit != 0) {
        output.WriteRawTag(16);
        output.WriteUInt32(ReSpinLimit);
      }
      if (ReSpinBet != 0UL) {
        output.WriteRawTag(24);
        output.WriteUInt64(ReSpinBet);
      }
      if (ReSpinTotalWin != 0UL) {
        output.WriteRawTag(32);
        output.WriteUInt64(ReSpinTotalWin);
      }
      triggeringPanels_.WriteTo(output, _repeated_triggeringPanels_codec);
      reelsMapping_.WriteTo(output, _repeated_reelsMapping_codec);
      if (IsOver != false) {
        output.WriteRawTag(56);
        output.WriteBool(IsOver);
      }
      if (IsAvgBet != false) {
        output.WriteRawTag(72);
        output.WriteBool(IsAvgBet);
      }
    }

    public int CalculateSize() {
      int size = 0;
      if (ReSpinCount != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(ReSpinCount);
      }
      if (ReSpinLimit != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(ReSpinLimit);
      }
      if (ReSpinBet != 0UL) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(ReSpinBet);
      }
      if (ReSpinTotalWin != 0UL) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(ReSpinTotalWin);
      }
      size += triggeringPanels_.CalculateSize(_repeated_triggeringPanels_codec);
      size += reelsMapping_.CalculateSize(_repeated_reelsMapping_codec);
      if (IsOver != false) {
        size += 1 + 1;
      }
      if (IsAvgBet != false) {
        size += 1 + 1;
      }
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            ReSpinCount = input.ReadUInt32();
            break;
          }
          case 16: {
            ReSpinLimit = input.ReadUInt32();
            break;
          }
          case 24: {
            ReSpinBet = input.ReadUInt64();
            break;
          }
          case 32: {
            ReSpinTotalWin = input.ReadUInt64();
            break;
          }
          case 42: {
            triggeringPanels_.AddEntriesFrom(input, _repeated_triggeringPanels_codec);
            break;
          }
          case 50:
          case 48: {
            reelsMapping_.AddEntriesFrom(input, _repeated_reelsMapping_codec);
            break;
          }
          case 56: {
            IsOver = input.ReadBool();
            break;
          }
          case 72: {
            IsAvgBet = input.ReadBool();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// 通用reSpin扩展数据
  /// </summary>
  public sealed class NormalReSpinExtraInfo : pb::IMessage {
    private static readonly pb::MessageParser<NormalReSpinExtraInfo> _parser = new pb::MessageParser<NormalReSpinExtraInfo>(() => new NormalReSpinExtraInfo());
    public static pb::MessageParser<NormalReSpinExtraInfo> Parser { get { return _parser; } }

    private static readonly pbc::MapField<uint, global::DragonU3DSDK.Network.API.ILProtocol.NormalReSpinExtraInfo.Types.LinkItem>.Codec _map_linkItems_codec
        = new pbc::MapField<uint, global::DragonU3DSDK.Network.API.ILProtocol.NormalReSpinExtraInfo.Types.LinkItem>.Codec(pb::FieldCodec.ForUInt32(8), pb::FieldCodec.ForMessage(18, global::DragonU3DSDK.Network.API.ILProtocol.NormalReSpinExtraInfo.Types.LinkItem.Parser), 10);
    private readonly pbc::MapField<uint, global::DragonU3DSDK.Network.API.ILProtocol.NormalReSpinExtraInfo.Types.LinkItem> linkItems_ = new pbc::MapField<uint, global::DragonU3DSDK.Network.API.ILProtocol.NormalReSpinExtraInfo.Types.LinkItem>();
    public pbc::MapField<uint, global::DragonU3DSDK.Network.API.ILProtocol.NormalReSpinExtraInfo.Types.LinkItem> LinkItems {
      get { return linkItems_; }
    }

    private static readonly pbc::MapField<uint, uint>.Codec _map_reelsIndex_codec
        = new pbc::MapField<uint, uint>.Codec(pb::FieldCodec.ForUInt32(8), pb::FieldCodec.ForUInt32(16), 18);
    private readonly pbc::MapField<uint, uint> reelsIndex_ = new pbc::MapField<uint, uint>();
    /// <summary>
    /// 记录每个格子所用的卷轴index
    /// </summary>
    public pbc::MapField<uint, uint> ReelsIndex {
      get { return reelsIndex_; }
    }

    private static readonly pb::FieldCodec<uint> _repeated_hitJackpotIds_codec
        = pb::FieldCodec.ForUInt32(26);
    private readonly pbc::RepeatedField<uint> hitJackpotIds_ = new pbc::RepeatedField<uint>();
    /// <summary>
    /// 在reSpin期间中的jackpot，因为reSpin期间jackpot是要锁定的，reSpin结束后要将这些jackpot重置
    /// </summary>
    public pbc::RepeatedField<uint> HitJackpotIds {
      get { return hitJackpotIds_; }
    }

    private uint newItemCount_;
    /// <summary>
    /// 新的图标数量
    /// </summary>
    public uint NewItemCount {
      get { return newItemCount_; }
      set {
        newItemCount_ = value;
      }
    }

    private global::DragonU3DSDK.Network.API.ILProtocol.NormalReSpinExtraInfo.Types.JackpotInfo jackpotInfo_;
    /// <summary>
    /// jackpot信息，link满的时候中grand用这个
    /// </summary>
    public global::DragonU3DSDK.Network.API.ILProtocol.NormalReSpinExtraInfo.Types.JackpotInfo JackpotInfo {
      get { return jackpotInfo_; }
      set {
        jackpotInfo_ = value;
      }
    }

    private static readonly pbc::MapField<uint, uint>.Codec _map_newItemMap_codec
        = new pbc::MapField<uint, uint>.Codec(pb::FieldCodec.ForUInt32(8), pb::FieldCodec.ForUInt32(16), 50);
    private readonly pbc::MapField<uint, uint> newItemMap_ = new pbc::MapField<uint, uint>();
    /// <summary>
    /// 新出现的元素都记下来
    /// </summary>
    public pbc::MapField<uint, uint> NewItemMap {
      get { return newItemMap_; }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      linkItems_.WriteTo(output, _map_linkItems_codec);
      reelsIndex_.WriteTo(output, _map_reelsIndex_codec);
      hitJackpotIds_.WriteTo(output, _repeated_hitJackpotIds_codec);
      if (NewItemCount != 0) {
        output.WriteRawTag(32);
        output.WriteUInt32(NewItemCount);
      }
      if (jackpotInfo_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(JackpotInfo);
      }
      newItemMap_.WriteTo(output, _map_newItemMap_codec);
    }

    public int CalculateSize() {
      int size = 0;
      size += linkItems_.CalculateSize(_map_linkItems_codec);
      size += reelsIndex_.CalculateSize(_map_reelsIndex_codec);
      size += hitJackpotIds_.CalculateSize(_repeated_hitJackpotIds_codec);
      if (NewItemCount != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(NewItemCount);
      }
      if (jackpotInfo_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(JackpotInfo);
      }
      size += newItemMap_.CalculateSize(_map_newItemMap_codec);
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            linkItems_.AddEntriesFrom(input, _map_linkItems_codec);
            break;
          }
          case 18: {
            reelsIndex_.AddEntriesFrom(input, _map_reelsIndex_codec);
            break;
          }
          case 26:
          case 24: {
            hitJackpotIds_.AddEntriesFrom(input, _repeated_hitJackpotIds_codec);
            break;
          }
          case 32: {
            NewItemCount = input.ReadUInt32();
            break;
          }
          case 42: {
            if (jackpotInfo_ == null) {
              jackpotInfo_ = new global::DragonU3DSDK.Network.API.ILProtocol.NormalReSpinExtraInfo.Types.JackpotInfo();
            }
            input.ReadMessage(jackpotInfo_);
            break;
          }
          case 50: {
            newItemMap_.AddEntriesFrom(input, _map_newItemMap_codec);
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the NormalReSpinExtraInfo message type.</summary>
    public static class Types {
      public sealed class LinkItem : pb::IMessage {
        private static readonly pb::MessageParser<LinkItem> _parser = new pb::MessageParser<LinkItem>(() => new LinkItem());
        public static pb::MessageParser<LinkItem> Parser { get { return _parser; } }

        private uint positionId_;
        /// <summary>
        /// 位置
        /// </summary>
        public uint PositionId {
          get { return positionId_; }
          set {
            positionId_ = value;
          }
        }

        private uint symbolId_;
        /// <summary>
        /// 图标
        /// </summary>
        public uint SymbolId {
          get { return symbolId_; }
          set {
            symbolId_ = value;
          }
        }

        private ulong winRate_;
        /// <summary>
        /// 赢钱倍率
        /// </summary>
        public ulong WinRate {
          get { return winRate_; }
          set {
            winRate_ = value;
          }
        }

        private uint jackpotId_;
        /// <summary>
        /// jackpotId
        /// </summary>
        public uint JackpotId {
          get { return jackpotId_; }
          set {
            jackpotId_ = value;
          }
        }

        private ulong jackpotPay_;
        /// <summary>
        /// jackpot倍率
        /// </summary>
        public ulong JackpotPay {
          get { return jackpotPay_; }
          set {
            jackpotPay_ = value;
          }
        }

        public void WriteTo(pb::CodedOutputStream output) {
          if (PositionId != 0) {
            output.WriteRawTag(8);
            output.WriteUInt32(PositionId);
          }
          if (SymbolId != 0) {
            output.WriteRawTag(16);
            output.WriteUInt32(SymbolId);
          }
          if (WinRate != 0UL) {
            output.WriteRawTag(24);
            output.WriteUInt64(WinRate);
          }
          if (JackpotId != 0) {
            output.WriteRawTag(32);
            output.WriteUInt32(JackpotId);
          }
          if (JackpotPay != 0UL) {
            output.WriteRawTag(40);
            output.WriteUInt64(JackpotPay);
          }
        }

        public int CalculateSize() {
          int size = 0;
          if (PositionId != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(PositionId);
          }
          if (SymbolId != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(SymbolId);
          }
          if (WinRate != 0UL) {
            size += 1 + pb::CodedOutputStream.ComputeUInt64Size(WinRate);
          }
          if (JackpotId != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(JackpotId);
          }
          if (JackpotPay != 0UL) {
            size += 1 + pb::CodedOutputStream.ComputeUInt64Size(JackpotPay);
          }
          return size;
        }

        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                input.SkipLastField();
                break;
              case 8: {
                PositionId = input.ReadUInt32();
                break;
              }
              case 16: {
                SymbolId = input.ReadUInt32();
                break;
              }
              case 24: {
                WinRate = input.ReadUInt64();
                break;
              }
              case 32: {
                JackpotId = input.ReadUInt32();
                break;
              }
              case 40: {
                JackpotPay = input.ReadUInt64();
                break;
              }
            }
          }
        }

      }

      public sealed class JackpotInfo : pb::IMessage {
        private static readonly pb::MessageParser<JackpotInfo> _parser = new pb::MessageParser<JackpotInfo>(() => new JackpotInfo());
        public static pb::MessageParser<JackpotInfo> Parser { get { return _parser; } }

        private uint jackpotId_;
        public uint JackpotId {
          get { return jackpotId_; }
          set {
            jackpotId_ = value;
          }
        }

        private ulong jackpotPay_;
        public ulong JackpotPay {
          get { return jackpotPay_; }
          set {
            jackpotPay_ = value;
          }
        }

        private ulong totalWin_;
        public ulong TotalWin {
          get { return totalWin_; }
          set {
            totalWin_ = value;
          }
        }

        public void WriteTo(pb::CodedOutputStream output) {
          if (JackpotId != 0) {
            output.WriteRawTag(8);
            output.WriteUInt32(JackpotId);
          }
          if (JackpotPay != 0UL) {
            output.WriteRawTag(16);
            output.WriteUInt64(JackpotPay);
          }
          if (TotalWin != 0UL) {
            output.WriteRawTag(24);
            output.WriteUInt64(TotalWin);
          }
        }

        public int CalculateSize() {
          int size = 0;
          if (JackpotId != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(JackpotId);
          }
          if (JackpotPay != 0UL) {
            size += 1 + pb::CodedOutputStream.ComputeUInt64Size(JackpotPay);
          }
          if (TotalWin != 0UL) {
            size += 1 + pb::CodedOutputStream.ComputeUInt64Size(TotalWin);
          }
          return size;
        }

        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                input.SkipLastField();
                break;
              case 8: {
                JackpotId = input.ReadUInt32();
                break;
              }
              case 16: {
                JackpotPay = input.ReadUInt64();
                break;
              }
              case 24: {
                TotalWin = input.ReadUInt64();
                break;
              }
            }
          }
        }

      }

    }
    #endregion

  }

  public sealed class SuperBonusInfo : pb::IMessage {
    private static readonly pb::MessageParser<SuperBonusInfo> _parser = new pb::MessageParser<SuperBonusInfo>(() => new SuperBonusInfo());
    public static pb::MessageParser<SuperBonusInfo> Parser { get { return _parser; } }

    private uint progress_;
    /// <summary>
    /// superBonus进度
    /// </summary>
    public uint Progress {
      get { return progress_; }
      set {
        progress_ = value;
      }
    }

    private ulong avgBet_;
    /// <summary>
    /// super bonus 平均下注
    /// </summary>
    public ulong AvgBet {
      get { return avgBet_; }
      set {
        avgBet_ = value;
      }
    }

    private bool triggered_;
    /// <summary>
    /// superBonus触发状态
    /// </summary>
    public bool Triggered {
      get { return triggered_; }
      set {
        triggered_ = value;
      }
    }

    private ulong startTime_;
    /// <summary>
    /// superBonus开启时间
    /// </summary>
    public ulong StartTime {
      get { return startTime_; }
      set {
        startTime_ = value;
      }
    }

    private ulong totalBet_;
    public ulong TotalBet {
      get { return totalBet_; }
      set {
        totalBet_ = value;
      }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (Progress != 0) {
        output.WriteRawTag(8);
        output.WriteUInt32(Progress);
      }
      if (AvgBet != 0UL) {
        output.WriteRawTag(16);
        output.WriteUInt64(AvgBet);
      }
      if (Triggered != false) {
        output.WriteRawTag(24);
        output.WriteBool(Triggered);
      }
      if (StartTime != 0UL) {
        output.WriteRawTag(32);
        output.WriteUInt64(StartTime);
      }
      if (TotalBet != 0UL) {
        output.WriteRawTag(40);
        output.WriteUInt64(TotalBet);
      }
    }

    public int CalculateSize() {
      int size = 0;
      if (Progress != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Progress);
      }
      if (AvgBet != 0UL) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(AvgBet);
      }
      if (Triggered != false) {
        size += 1 + 1;
      }
      if (StartTime != 0UL) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(StartTime);
      }
      if (TotalBet != 0UL) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(TotalBet);
      }
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            Progress = input.ReadUInt32();
            break;
          }
          case 16: {
            AvgBet = input.ReadUInt64();
            break;
          }
          case 24: {
            Triggered = input.ReadBool();
            break;
          }
          case 32: {
            StartTime = input.ReadUInt64();
            break;
          }
          case 40: {
            TotalBet = input.ReadUInt64();
            break;
          }
        }
      }
    }

  }

  public sealed class GameResult : pb::IMessage {
    private static readonly pb::MessageParser<GameResult> _parser = new pb::MessageParser<GameResult>(() => new GameResult());
    public static pb::MessageParser<GameResult> Parser { get { return _parser; } }

    private ulong bet_;
    /// <summary>
    /// 投注金额
    /// </summary>
    public ulong Bet {
      get { return bet_; }
      set {
        bet_ = value;
      }
    }

    private static readonly pb::FieldCodec<global::DragonU3DSDK.Network.API.ILProtocol.Panel> _repeated_panels_codec
        = pb::FieldCodec.ForMessage(18, global::DragonU3DSDK.Network.API.ILProtocol.Panel.Parser);
    private readonly pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.Panel> panels_ = new pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.Panel>();
    /// <summary>
    /// 图标结果
    /// </summary>
    public pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.Panel> Panels {
      get { return panels_; }
    }

    private ulong totalWin_;
    /// <summary>
    /// 总赢钱，解决(bet*win_rate/100)算式带来的最多(bet/100)误差。
    /// </summary>
    public ulong TotalWin {
      get { return totalWin_; }
      set {
        totalWin_ = value;
      }
    }

    private uint winLevel_;
    /// <summary>
    /// 赢钱等级
    /// </summary>
    public uint WinLevel {
      get { return winLevel_; }
      set {
        winLevel_ = value;
      }
    }

    private uint jackpotId_;
    /// <summary>
    /// 本局触发的jackpotId
    /// </summary>
    public uint JackpotId {
      get { return jackpotId_; }
      set {
        jackpotId_ = value;
      }
    }

    private ulong jackpotPay_;
    /// <summary>
    /// 本局jackpot赢钱
    /// </summary>
    public ulong JackpotPay {
      get { return jackpotPay_; }
      set {
        jackpotPay_ = value;
      }
    }

    private static readonly pb::FieldCodec<global::DragonU3DSDK.Network.API.ILProtocol.JackpotState> _repeated_jackpotStates_codec
        = pb::FieldCodec.ForMessage(66, global::DragonU3DSDK.Network.API.ILProtocol.JackpotState.Parser);
    private readonly pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.JackpotState> jackpotStates_ = new pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.JackpotState>();
    /// <summary>
    /// jackpot当前状态
    /// </summary>
    public pbc::RepeatedField<global::DragonU3DSDK.Network.API.ILProtocol.JackpotState> JackpotStates {
      get { return jackpotStates_; }
    }

    private uint freeSpinCount_;
    /// <summary>
    /// 本局新增免费游戏次数
    /// </summary>
    public uint FreeSpinCount {
      get { return freeSpinCount_; }
      set {
        freeSpinCount_ = value;
      }
    }

    private uint reSpinCount_;
    /// <summary>
    /// reSpinCount
    /// </summary>
    public uint ReSpinCount {
      get { return reSpinCount_; }
      set {
        reSpinCount_ = value;
      }
    }

    private uint bonusGame_;
    /// <summary>
    /// 本局触发了小游戏
    /// </summary>
    public uint BonusGame {
      get { return bonusGame_; }
      set {
        bonusGame_ = value;
      }
    }

    private string fsm_ = "";
    /// <summary>
    /// fsm状态
    /// </summary>
    public string Fsm {
      get { return fsm_; }
      set {
        fsm_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    private string payControl_ = "";
    /// <summary>
    /// 赢钱控制
    /// </summary>
    public string PayControl {
      get { return payControl_; }
      set {
        payControl_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    private uint freeSpinChoices_;
    /// <summary>
    /// 触发了可以选择的freeSpin游戏的次数
    /// </summary>
    public uint FreeSpinChoices {
      get { return freeSpinChoices_; }
      set {
        freeSpinChoices_ = value;
      }
    }

    private string extraInfo_ = "";
    /// <summary>
    /// 扩展信息, 不同游戏对应的具体内容参考spinx_extra_info.proto
    /// </summary>
    public string ExtraInfo {
      get { return extraInfo_; }
      set {
        extraInfo_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    private global::DragonU3DSDK.Network.API.ILProtocol.AnyStruct extraInfoPb_;
    /// <summary>
    /// pb格式的扩展字段
    /// </summary>
    public global::DragonU3DSDK.Network.API.ILProtocol.AnyStruct ExtraInfoPb {
      get { return extraInfoPb_; }
      set {
        extraInfoPb_ = value;
      }
    }

    private bool isJackpotStatic_;
    /// <summary>
    /// jackpot是否固定
    /// </summary>
    public bool IsJackpotStatic {
      get { return isJackpotStatic_; }
      set {
        isJackpotStatic_ = value;
      }
    }

    private ulong displayTotalWin_;
    /// <summary>
    /// 累计赢钱数，freeGame，reSpin之类的会用到，普通游戏的话等于display_cur_win，客户端显示用
    /// </summary>
    public ulong DisplayTotalWin {
      get { return displayTotalWin_; }
      set {
        displayTotalWin_ = value;
      }
    }

    private ulong displayCurrentWin_;
    /// <summary>
    /// 当前这局的赢钱数
    /// </summary>
    public ulong DisplayCurrentWin {
      get { return displayCurrentWin_; }
      set {
        displayCurrentWin_ = value;
      }
    }

    private ulong timestamp_;
    /// <summary>
    /// 服务器时间戳
    /// </summary>
    public ulong Timestamp {
      get { return timestamp_; }
      set {
        timestamp_ = value;
      }
    }

    private bool hasAd_;
    /// <summary>
    /// 是否有激励广告
    /// </summary>
    public bool HasAd {
      get { return hasAd_; }
      set {
        hasAd_ = value;
      }
    }

    private uint freeSpinId_;
    /// <summary>
    /// free game Id
    /// </summary>
    public uint FreeSpinId {
      get { return freeSpinId_; }
      set {
        freeSpinId_ = value;
      }
    }

    private uint sfxId_;
    /// <summary>
    /// 播放特效id通用字段； 目前用于按概率播放的必中动画，以后可扩展
    /// </summary>
    public uint SfxId {
      get { return sfxId_; }
      set {
        sfxId_ = value;
      }
    }

    private bool isFreeSpin_;
    /// <summary>
    /// 本局是free spin
    /// </summary>
    public bool IsFreeSpin {
      get { return isFreeSpin_; }
      set {
        isFreeSpin_ = value;
      }
    }

    private bool isBonusGame_;
    /// <summary>
    /// 本局是bonus_game
    /// </summary>
    public bool IsBonusGame {
      get { return isBonusGame_; }
      set {
        isBonusGame_ = value;
      }
    }

    private bool isReSpin_;
    /// <summary>
    /// 本局是reSpin
    /// </summary>
    public bool IsReSpin {
      get { return isReSpin_; }
      set {
        isReSpin_ = value;
      }
    }

    private bool isAvgBet_;
    /// <summary>
    /// 当前Spin使用AvgBet
    /// </summary>
    public bool IsAvgBet {
      get { return isAvgBet_; }
      set {
        isAvgBet_ = value;
      }
    }

    private uint adButtonShowParam_;
    /// <summary>
    /// bigWin广告按钮上的显示参数
    /// </summary>
    public uint AdButtonShowParam {
      get { return adButtonShowParam_; }
      set {
        adButtonShowParam_ = value;
      }
    }

    private global::DragonU3DSDK.Network.API.ILProtocol.FreeSpinInfo freeSpinInfo_;
    public global::DragonU3DSDK.Network.API.ILProtocol.FreeSpinInfo FreeSpinInfo {
      get { return freeSpinInfo_; }
      set {
        freeSpinInfo_ = value;
      }
    }

    private global::DragonU3DSDK.Network.API.ILProtocol.ReSpinInfo reSpinInfo_;
    public global::DragonU3DSDK.Network.API.ILProtocol.ReSpinInfo ReSpinInfo {
      get { return reSpinInfo_; }
      set {
        reSpinInfo_ = value;
      }
    }

    private global::DragonU3DSDK.Network.API.ILProtocol.SuperBonusInfo superBonusInfo_;
    public global::DragonU3DSDK.Network.API.ILProtocol.SuperBonusInfo SuperBonusInfo {
      get { return superBonusInfo_; }
      set {
        superBonusInfo_ = value;
      }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (Bet != 0UL) {
        output.WriteRawTag(8);
        output.WriteUInt64(Bet);
      }
      panels_.WriteTo(output, _repeated_panels_codec);
      if (TotalWin != 0UL) {
        output.WriteRawTag(24);
        output.WriteUInt64(TotalWin);
      }
      if (WinLevel != 0) {
        output.WriteRawTag(32);
        output.WriteUInt32(WinLevel);
      }
      if (JackpotId != 0) {
        output.WriteRawTag(48);
        output.WriteUInt32(JackpotId);
      }
      if (JackpotPay != 0UL) {
        output.WriteRawTag(56);
        output.WriteUInt64(JackpotPay);
      }
      jackpotStates_.WriteTo(output, _repeated_jackpotStates_codec);
      if (FreeSpinCount != 0) {
        output.WriteRawTag(72);
        output.WriteUInt32(FreeSpinCount);
      }
      if (ReSpinCount != 0) {
        output.WriteRawTag(80);
        output.WriteUInt32(ReSpinCount);
      }
      if (BonusGame != 0) {
        output.WriteRawTag(88);
        output.WriteUInt32(BonusGame);
      }
      if (Fsm.Length != 0) {
        output.WriteRawTag(98);
        output.WriteString(Fsm);
      }
      if (PayControl.Length != 0) {
        output.WriteRawTag(106);
        output.WriteString(PayControl);
      }
      if (FreeSpinChoices != 0) {
        output.WriteRawTag(112);
        output.WriteUInt32(FreeSpinChoices);
      }
      if (ExtraInfo.Length != 0) {
        output.WriteRawTag(122);
        output.WriteString(ExtraInfo);
      }
      if (extraInfoPb_ != null) {
        output.WriteRawTag(130, 1);
        output.WriteMessage(ExtraInfoPb);
      }
      if (IsJackpotStatic != false) {
        output.WriteRawTag(136, 1);
        output.WriteBool(IsJackpotStatic);
      }
      if (DisplayTotalWin != 0UL) {
        output.WriteRawTag(144, 1);
        output.WriteUInt64(DisplayTotalWin);
      }
      if (DisplayCurrentWin != 0UL) {
        output.WriteRawTag(152, 1);
        output.WriteUInt64(DisplayCurrentWin);
      }
      if (Timestamp != 0UL) {
        output.WriteRawTag(160, 1);
        output.WriteUInt64(Timestamp);
      }
      if (HasAd != false) {
        output.WriteRawTag(168, 1);
        output.WriteBool(HasAd);
      }
      if (FreeSpinId != 0) {
        output.WriteRawTag(176, 1);
        output.WriteUInt32(FreeSpinId);
      }
      if (SfxId != 0) {
        output.WriteRawTag(184, 1);
        output.WriteUInt32(SfxId);
      }
      if (IsFreeSpin != false) {
        output.WriteRawTag(128, 2);
        output.WriteBool(IsFreeSpin);
      }
      if (IsBonusGame != false) {
        output.WriteRawTag(136, 2);
        output.WriteBool(IsBonusGame);
      }
      if (IsReSpin != false) {
        output.WriteRawTag(144, 2);
        output.WriteBool(IsReSpin);
      }
      if (IsAvgBet != false) {
        output.WriteRawTag(152, 2);
        output.WriteBool(IsAvgBet);
      }
      if (AdButtonShowParam != 0) {
        output.WriteRawTag(160, 2);
        output.WriteUInt32(AdButtonShowParam);
      }
      if (freeSpinInfo_ != null) {
        output.WriteRawTag(130, 4);
        output.WriteMessage(FreeSpinInfo);
      }
      if (reSpinInfo_ != null) {
        output.WriteRawTag(138, 4);
        output.WriteMessage(ReSpinInfo);
      }
      if (superBonusInfo_ != null) {
        output.WriteRawTag(146, 4);
        output.WriteMessage(SuperBonusInfo);
      }
    }

    public int CalculateSize() {
      int size = 0;
      if (Bet != 0UL) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(Bet);
      }
      size += panels_.CalculateSize(_repeated_panels_codec);
      if (TotalWin != 0UL) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(TotalWin);
      }
      if (WinLevel != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(WinLevel);
      }
      if (JackpotId != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(JackpotId);
      }
      if (JackpotPay != 0UL) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(JackpotPay);
      }
      size += jackpotStates_.CalculateSize(_repeated_jackpotStates_codec);
      if (FreeSpinCount != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(FreeSpinCount);
      }
      if (ReSpinCount != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(ReSpinCount);
      }
      if (BonusGame != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(BonusGame);
      }
      if (Fsm.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Fsm);
      }
      if (PayControl.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(PayControl);
      }
      if (FreeSpinChoices != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(FreeSpinChoices);
      }
      if (ExtraInfo.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ExtraInfo);
      }
      if (extraInfoPb_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(ExtraInfoPb);
      }
      if (IsJackpotStatic != false) {
        size += 2 + 1;
      }
      if (DisplayTotalWin != 0UL) {
        size += 2 + pb::CodedOutputStream.ComputeUInt64Size(DisplayTotalWin);
      }
      if (DisplayCurrentWin != 0UL) {
        size += 2 + pb::CodedOutputStream.ComputeUInt64Size(DisplayCurrentWin);
      }
      if (Timestamp != 0UL) {
        size += 2 + pb::CodedOutputStream.ComputeUInt64Size(Timestamp);
      }
      if (HasAd != false) {
        size += 2 + 1;
      }
      if (FreeSpinId != 0) {
        size += 2 + pb::CodedOutputStream.ComputeUInt32Size(FreeSpinId);
      }
      if (SfxId != 0) {
        size += 2 + pb::CodedOutputStream.ComputeUInt32Size(SfxId);
      }
      if (IsFreeSpin != false) {
        size += 2 + 1;
      }
      if (IsBonusGame != false) {
        size += 2 + 1;
      }
      if (IsReSpin != false) {
        size += 2 + 1;
      }
      if (IsAvgBet != false) {
        size += 2 + 1;
      }
      if (AdButtonShowParam != 0) {
        size += 2 + pb::CodedOutputStream.ComputeUInt32Size(AdButtonShowParam);
      }
      if (freeSpinInfo_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(FreeSpinInfo);
      }
      if (reSpinInfo_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(ReSpinInfo);
      }
      if (superBonusInfo_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(SuperBonusInfo);
      }
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            Bet = input.ReadUInt64();
            break;
          }
          case 18: {
            panels_.AddEntriesFrom(input, _repeated_panels_codec);
            break;
          }
          case 24: {
            TotalWin = input.ReadUInt64();
            break;
          }
          case 32: {
            WinLevel = input.ReadUInt32();
            break;
          }
          case 48: {
            JackpotId = input.ReadUInt32();
            break;
          }
          case 56: {
            JackpotPay = input.ReadUInt64();
            break;
          }
          case 66: {
            jackpotStates_.AddEntriesFrom(input, _repeated_jackpotStates_codec);
            break;
          }
          case 72: {
            FreeSpinCount = input.ReadUInt32();
            break;
          }
          case 80: {
            ReSpinCount = input.ReadUInt32();
            break;
          }
          case 88: {
            BonusGame = input.ReadUInt32();
            break;
          }
          case 98: {
            Fsm = input.ReadString();
            break;
          }
          case 106: {
            PayControl = input.ReadString();
            break;
          }
          case 112: {
            FreeSpinChoices = input.ReadUInt32();
            break;
          }
          case 122: {
            ExtraInfo = input.ReadString();
            break;
          }
          case 130: {
            if (extraInfoPb_ == null) {
              extraInfoPb_ = new global::DragonU3DSDK.Network.API.ILProtocol.AnyStruct();
            }
            input.ReadMessage(extraInfoPb_);
            break;
          }
          case 136: {
            IsJackpotStatic = input.ReadBool();
            break;
          }
          case 144: {
            DisplayTotalWin = input.ReadUInt64();
            break;
          }
          case 152: {
            DisplayCurrentWin = input.ReadUInt64();
            break;
          }
          case 160: {
            Timestamp = input.ReadUInt64();
            break;
          }
          case 168: {
            HasAd = input.ReadBool();
            break;
          }
          case 176: {
            FreeSpinId = input.ReadUInt32();
            break;
          }
          case 184: {
            SfxId = input.ReadUInt32();
            break;
          }
          case 256: {
            IsFreeSpin = input.ReadBool();
            break;
          }
          case 264: {
            IsBonusGame = input.ReadBool();
            break;
          }
          case 272: {
            IsReSpin = input.ReadBool();
            break;
          }
          case 280: {
            IsAvgBet = input.ReadBool();
            break;
          }
          case 288: {
            AdButtonShowParam = input.ReadUInt32();
            break;
          }
          case 514: {
            if (freeSpinInfo_ == null) {
              freeSpinInfo_ = new global::DragonU3DSDK.Network.API.ILProtocol.FreeSpinInfo();
            }
            input.ReadMessage(freeSpinInfo_);
            break;
          }
          case 522: {
            if (reSpinInfo_ == null) {
              reSpinInfo_ = new global::DragonU3DSDK.Network.API.ILProtocol.ReSpinInfo();
            }
            input.ReadMessage(reSpinInfo_);
            break;
          }
          case 530: {
            if (superBonusInfo_ == null) {
              superBonusInfo_ = new global::DragonU3DSDK.Network.API.ILProtocol.SuperBonusInfo();
            }
            input.ReadMessage(superBonusInfo_);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// 玩家所在房间信息
  /// </summary>
  public sealed class UserRoomInfo : pb::IMessage {
    private static readonly pb::MessageParser<UserRoomInfo> _parser = new pb::MessageParser<UserRoomInfo>(() => new UserRoomInfo());
    public static pb::MessageParser<UserRoomInfo> Parser { get { return _parser; } }

    private string roomId_ = "";
    /// <summary>
    /// 房间id
    /// </summary>
    public string RoomId {
      get { return roomId_; }
      set {
        roomId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    private uint camp_;
    /// <summary>
    /// 阵营id
    /// </summary>
    public uint Camp {
      get { return camp_; }
      set {
        camp_ = value;
      }
    }

    private uint index_;
    /// <summary>
    /// 座位索引
    /// </summary>
    public uint Index {
      get { return index_; }
      set {
        index_ = value;
      }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (RoomId.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(RoomId);
      }
      if (Camp != 0) {
        output.WriteRawTag(16);
        output.WriteUInt32(Camp);
      }
      if (Index != 0) {
        output.WriteRawTag(24);
        output.WriteUInt32(Index);
      }
    }

    public int CalculateSize() {
      int size = 0;
      if (RoomId.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(RoomId);
      }
      if (Camp != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Camp);
      }
      if (Index != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Index);
      }
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            RoomId = input.ReadString();
            break;
          }
          case 16: {
            Camp = input.ReadUInt32();
            break;
          }
          case 24: {
            Index = input.ReadUInt32();
            break;
          }
        }
      }
    }

  }

  #endregion

}

#endregion Designer generated code
